{"version":3,"sources":["webpack://JavaScriptObfuscator/webpack/bootstrap","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/interopRequireDefault\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/classCallCheck\"","webpack://JavaScriptObfuscator/external \"inversify\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/createClass\"","webpack://JavaScriptObfuscator/external \"tslib\"","webpack://JavaScriptObfuscator/./src/container/ServiceIdentifiers.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/possibleConstructorReturn\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/getPrototypeOf\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/inherits\"","webpack://JavaScriptObfuscator/./src/node/NodeGuards.ts","webpack://JavaScriptObfuscator/./src/decorators/Initializable.ts","webpack://JavaScriptObfuscator/./src/node/NodeUtils.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/TransformationStage.ts","webpack://JavaScriptObfuscator/./src/node-transformers/AbstractNodeTransformer.ts","webpack://JavaScriptObfuscator/./src/node/NodeFactory.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/AbstractCustomNode.ts","webpack://JavaScriptObfuscator/external \"estraverse\"","webpack://JavaScriptObfuscator/./src/node/NodeMetadata.ts","webpack://JavaScriptObfuscator/external \"string-template\"","webpack://JavaScriptObfuscator/./src/enums/node/NodeType.ts","webpack://JavaScriptObfuscator/./src/container/InversifyContainerFacade.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/ControlFlowCustomNode.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/enums/ObfuscationTarget.ts","webpack://JavaScriptObfuscator/./src/node/NodeStatementUtils.ts","webpack://JavaScriptObfuscator/./src/node/NodeAppender.ts","webpack://JavaScriptObfuscator/./src/enums/event-emitters/ObfuscationEvent.ts","webpack://JavaScriptObfuscator/./src/node/NodeLexicalScopeUtils.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/toConsumableArray\"","webpack://JavaScriptObfuscator/./src/enums/node-transformers/NodeTransformer.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/slicedToArray\"","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/CustomNode.ts","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscatorFacade.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/AbstractCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/utils/Utils.ts","webpack://JavaScriptObfuscator/./src/enums/generators/identifier-names-generators/IdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/enums/source-map/SourceMapMode.ts","webpack://JavaScriptObfuscator/./src/enums/StringArrayEncoding.ts","webpack://JavaScriptObfuscator/./src/options/presets/NoCustomNodes.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/get\"","webpack://JavaScriptObfuscator/./src/utils/NumberUtils.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/AbstractObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/AbstractCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/AbstractControlFlowReplacer.ts","webpack://JavaScriptObfuscator/external \"escodegen-wallaby\"","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableNoEvalTemplate.ts","webpack://JavaScriptObfuscator/./src/options/presets/Default.ts","webpack://JavaScriptObfuscator/./src/enums/analyzers/stack-trace-analyzer/CalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/ExpressionWithOperatorControlFlowReplacer.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/typeof\"","webpack://JavaScriptObfuscator/external \"espree\"","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/DeadCodeInjectionCustomNode.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/AbstractPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/CustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/AbstractIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/storages/MapStorage.ts","webpack://JavaScriptObfuscator/./src/utils/RandomGenerator.ts","webpack://JavaScriptObfuscator/external \"chalk\"","webpack://JavaScriptObfuscator/external \"reflect-metadata\"","webpack://JavaScriptObfuscator/./src/logger/Logger.ts","webpack://JavaScriptObfuscator/./src/enums/logger/LoggingPrefix.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/construct\"","webpack://JavaScriptObfuscator/./src/container/modules/analyzers/AnalyzersModule.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/StackTraceAnalyzer.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ControlFlowTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/FunctionControlFlowTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ConvertingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/AssignmentExpressionPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/MemberExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/MethodDefinitionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/ObjectExpressionKeysTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/ObjectExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/TemplateLiteralTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/VariableDeclaratorPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/container/modules/custom-nodes/CustomNodesModule.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableTemplate1.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableTemplate2.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode.ts","webpack://JavaScriptObfuscator/./src/templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/domain-lock-nodes/DomainLockNode.ts","webpack://JavaScriptObfuscator/./src/templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/SingleNodeCallControllerTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode.ts","webpack://JavaScriptObfuscator/./src/templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayCallsWrapper.ts","webpack://JavaScriptObfuscator/./src/templates/AtobTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/Rc4Template.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayNode.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-node/StringArrayTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayRotateFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/StringLiteralNode.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/FinalizingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/container/modules/generators/GeneratorsModule.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/MangledIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/NodeTransformersModule.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ObfuscatingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/CatchClauseTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/ClassDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/FunctionDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/FunctionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/ImportDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/LabeledStatementTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/LiteralTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/VariableDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node/NodeBlockLexicalScopeUtils.ts","webpack://JavaScriptObfuscator/./src/container/modules/options/OptionsModule.ts","webpack://JavaScriptObfuscator/./src/options/Options.ts","webpack://JavaScriptObfuscator/external \"class-validator\"","webpack://JavaScriptObfuscator/./src/options/ValidationErrorsFormatter.ts","webpack://JavaScriptObfuscator/./src/options/OptionsNormalizer.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/ControlFlowFlatteningThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DeadCodeInjectionRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DeadCodeInjectionThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DomainLockRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/InputFileNameRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SelfDefendingRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SourceMapBaseUrlRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SourceMapFileNameRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayEncodingRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayThresholdRule.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/PreparingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/CommentsTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/CustomNodesTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/EvaCallExpressionTransformer.ts","webpack://JavaScriptObfuscator/external \"js-string-escape\"","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/MetadataTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/ObfuscatingGuardsTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/ParentificationTransformer.ts","webpack://JavaScriptObfuscator/./src/container/modules/storages/StoragesModule.ts","webpack://JavaScriptObfuscator/./src/storages/control-flow/ControlFlowStorage.ts","webpack://JavaScriptObfuscator/./src/storages/custom-node-group/CustomNodeGroupStorage.ts","webpack://JavaScriptObfuscator/./src/storages/string-array/StringArrayStorage.ts","webpack://JavaScriptObfuscator/./src/storages/ArrayStorage.ts","webpack://JavaScriptObfuscator/./src/container/modules/utils/UtilsModule.ts","webpack://JavaScriptObfuscator/./src/utils/ArrayUtils.ts","webpack://JavaScriptObfuscator/./src/utils/CryptUtils.ts","webpack://JavaScriptObfuscator/external \"md5\"","webpack://JavaScriptObfuscator/external \"chance\"","webpack://JavaScriptObfuscator/./src/utils/EscapeSequenceEncoder.ts","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscator.ts","webpack://JavaScriptObfuscator/./src/enums/logger/LoggingMessage.ts","webpack://JavaScriptObfuscator/./src/EspreeFacade.ts","webpack://JavaScriptObfuscator/./src/event-emitters/ObfuscationEventEmitter.ts","webpack://JavaScriptObfuscator/external \"events\"","webpack://JavaScriptObfuscator/./src/source-code/ObfuscatedCode.ts","webpack://JavaScriptObfuscator/./src/source-code/SourceCode.ts","webpack://JavaScriptObfuscator/./src/node-transformers/TransformersRunner.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/VisitorDirection.ts","webpack://JavaScriptObfuscator/./src/cli/JavaScriptObfuscatorCLI.ts","webpack://JavaScriptObfuscator/external \"path\"","webpack://JavaScriptObfuscator/external \"fs\"","webpack://JavaScriptObfuscator/./index.cli.ts","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscatorCLIFacade.ts","webpack://JavaScriptObfuscator/external \"commander\"","webpack://JavaScriptObfuscator/./src/cli/sanitizers/ArraySanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/BooleanSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/IdentifierNamesGeneratorSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/ObfuscatingTargetSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/SourceMapModeSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/StringArrayEncodingSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/utils/CLIUtils.ts","webpack://JavaScriptObfuscator/external \"mkdirp\"","webpack://JavaScriptObfuscator/./src/cli/utils sync","webpack://JavaScriptObfuscator/./src/cli/utils/SourceCodeReader.ts","webpack://JavaScriptObfuscator/external \"multimatch\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","ServiceIdentifiers","NodeType_1","NodeGuards","node","type","NodeType","ArrayPattern","ArrowFunctionExpression","AssignmentPattern","AwaitExpression","BlockStatement","BreakStatement","CallExpression","CatchClause","ClassDeclaration","ContinueStatement","ExportNamedDeclaration","ExpressionStatement","isFunctionDeclarationNode","isFunctionExpressionNode","isArrowFunctionExpressionNode","FunctionDeclaration","FunctionExpression","Identifier","ImportDeclaration","ImportSpecifier","parentNode","parentNodeIsLabeledStatementNode","isLabeledStatementNode","label","parentNodeIsContinueStatementNode","isContinueStatementNode","parentNodeIsBreakStatementNode","isBreakStatementNode","LabeledStatement","Literal","MemberExpression","MethodDefinition","undefined","isProgramNode","isFunctionNode","isNodeWithLexicalScope","isBlockStatementNode","nodesWithLexicalStatements","includes","isSwitchCaseNode","Boolean","leadingComments","trailingComments","ObjectPattern","ObjectExpression","Program","Property","isIdentifierNode","parentNodeIsPropertyNode","isPropertyNode","computed","parentNodeIsMemberExpressionNode","isMemberExpressionNode","parentNodeIsMethodDefinitionNode","isMethodDefinitionNode","isLabelIdentifierNode","RestElement","ReturnStatement","Super","SwitchCase","TaggedTemplateExpression","TemplateLiteral","UnaryExpression","directive","VariableDeclaration","VariableDeclarator","WhileStatement","defaultDescriptor","configurable","initializedTargetMetadataKey","initializablePropertiesSetMetadataKey","wrappedMethodsSetMetadataKey","constructorMethodName","initializeTargetMetadata","metadataKey","metadataValue","target","Reflect","hasMetadata","defineMetadata","initializable","initializeMethodName","arguments","length","decoratorName","keys","this","propertyKey","initializeMethod","Error","concat","Set","ownPropertyNames","getOwnPropertyNames","prohibitedPropertyNames","forEach","propertyName","initializablePropertiesSet","getMetadata","wrappedMethodsSet","isProhibitedPropertyName","has","targetProperty","methodDescriptor","getOwnPropertyDescriptor","originalMethod","assign","apply","add","wrapTargetMethodsInInitializedCheck","result","wrapInitializeMethodInInitializeCheck","initializablePropertyMetadataKey","toString","propertyDescriptor","set","newVal","wrapInitializableProperty","escodegen","tslib_1","__importStar","espree","estraverse","NodeGuards_1","NodeMetadata_1","NodeUtils","literalNode","content","raw","precedence","Precedence","Primary","astTree","parentizeAst","cloneRecursive","code","structure","parse","sourceType","replace","enter","parentizeNode","isLiteralNode","addXVerbatimPropertyTo","NodeMetadata","ignoredNode","body","reduce","generate","sourceMapWithCode","unaryExpressionNode","isUnaryExpressionNode","argument","getUnaryExpressionArgumentNode","copy","clonedValue","RegExp","Array","isArray","map","_typeof2","default","TransformationStage","inversify_1","ServiceIdentifiers_1","AbstractNodeTransformer","randomGenerator","options","_classCallCheck2","__decorate","injectable","__param","inject","IRandomGenerator","IOptions","NodeFactory","metadata","elements","ArrayExpression","operator","left","right","AssignmentExpression","BinaryExpression","callee","args","expression","functionName","params","id","identifierNode","generator","test","consequent","alternate","IfStatement","x-verbatim-property","LogicalExpression","kind","static","properties","method","shorthand","discriminant","cases","SwitchStatement","prefix","argumentExpr","UpdateExpression","declarations","init","GlobalVariableTemplate1_1","GlobalVariableTemplate2_1","AbstractCustomNode","AbstractCustomNode_1","identifierNamesGeneratorFactory","cachedNode","identifierNamesGenerator","_createClass2","getNodeStructure","getRandomGenerator","pickone","globalVariableTemplateFunctions","GlobalVariableTemplate1","GlobalVariableTemplate2","Factory__IIdentifierNamesGenerator","AnalyzersModule_1","ControlFlowTransformersModule_1","ConvertingTransformersModule_1","CustomNodesModule_1","FinalizingTransformersModule_1","GeneratorsModule_1","NodeTransformersModule_1","ObfuscatingTransformersModule_1","OptionsModule_1","PreparingTransformersModule_1","StoragesModule_1","UtilsModule_1","JavaScriptObfuscator_1","Logger_1","ObfuscationEventEmitter_1","ObfuscatedCode_1","SourceCode_1","TransformersRunner_1","InversifyContainerFacade","container","Container","serviceIdentifier","named","getNamed","sourceCode","sourceMap","ISourceCode","toDynamicValue","SourceCode","inSingletonScope","TInputOptions","ILogger","to","Logger","IJavaScriptObfuscator","JavaScriptObfuscator","ITransformersRunner","TransformersRunner","IObfuscatedCode","ObfuscatedCode","Factory__IObfuscatedCode","toFactory","context","obfuscatedCodeAsString","sourceMapAsString","obfuscatedCode","initialize","IObfuscationEventEmitter","ObfuscationEventEmitter","load","analyzersModule","controlFlowTransformersModule","convertingTransformersModule","customNodesModule","finalizingTransformersModule","generatorsModule","nodeTransformersModule","obfuscatingTransformersModule","optionsModule","preparingTransformersModule","storagesModule","utilsModule","unbindAll","bindingName","cache","Map","_len","dependencies","_key","cachedDependencies","dependency","index","_construct2","constructor","ControlFlowCustomNode","IdentifierObfuscatingReplacer","ObfuscationTarget","NodeStatementUtils","getParentNodesWithStatementsRecursive","statement","getSiblingStatementByOffset","ReferenceError","isNodeWithStatements","getRootStatementOfNode","getScopeOfNode","maxSize","Infinity","nodesWithStatements","depth","isNodeWithLexicalScopeStatements","push","offset","scopeNode","scopeBody","indexOf","NodeAppender","nodeWithStatements","statements","parentizeScopeStatementsBeforeAppend","setScopeStatements","_toConsumableArray2","getScopeStatements","stackTraceData","bodyStatements","targetBlockScope","getOptimalBlockScope","prepend","deep","firstCall","stackTrace","indexInScopeStatement","insertAtIndex","slice","ObfuscationEvent","NodeLexicalScopeUtils","getLexicalScopesRecursive","nodesWithLexicalScope","NodeTransformer","CustomNode","InversifyContainerFacade_1","JavaScriptObfuscatorFacade","inputOptions","inversifyContainerFacade","obfuscate","unload","version","AbstractCustomNodeGroup","appendEvent","customNodes","customNodeName","callback","customNode","stackTraceLength","getRandomInteger","Math","max","round","Utils","url","split","hexadecimalPrefix","IdentifierNamesGenerator","SourceMapMode","StringArrayEncoding","IdentifierNamesGenerator_1","ObfuscationTarget_1","SourceMapMode_1","NO_ADDITIONAL_NODES_PRESET","freeze","compact","controlFlowFlattening","controlFlowFlatteningThreshold","deadCodeInjection","deadCodeInjectionThreshold","debugProtection","debugProtectionInterval","disableConsoleOutput","domainLock","exclude","HexadecimalIdentifierNamesGenerator","identifiersPrefix","inputFileName","log","renameGlobals","reservedNames","reservedStrings","rotateStringArray","seed","selfDefending","sourceMapBaseUrl","sourceMapFileName","sourceMapMode","Separate","stringArray","stringArrayEncoding","stringArrayThreshold","Browser","transformObjectKeys","unicodeEscapeSequence","NumberUtils","dec","number","AbstractObfuscatingReplacer","AbstractCalleeDataExtractor","AbstractControlFlowReplacer","AbstractControlFlowReplacer_1","controlFlowCustomNodeFactory","replacerDataByControlFlowStorageId","controlFlowStorage","replacerId","usingExistingIdentifierChance","_this","controlFlowStorageId","getStorageId","storageKeysById","getStorageKeysByIdForCurrentStorage","storageKeysForCurrentId","getMathRandom","storageKey","generateStorageKey","getRandomString","getStorage","identifierDataByControlFlowStorageId","Factory__IControlFlowCustomNode","GlobalVariableNoEvalTemplate","DEFAULT_PRESET","config","CalleeDataExtractor","ControlFlowReplacer","ControlFlowCustomNode_1","ExpressionWithOperatorControlFlowReplacer","_AbstractControlFlowR","_possibleConstructorReturn2","_getPrototypeOf2","_inherits2","leftExpression","rightExpression","controlFlowStorageCallCustomNode","ExpressionWithOperatorControlFlowStorageCallNode","statementNode","getNode","isExpressionStatementNode","DeadCodeInjectionCustomNode","PropertiesExtractor","NodeAppender_1","NodeFactory_1","NodeStatementUtils_1","AbstractPropertiesExtractor","AbstractPropertiesExtractor_1","cachedHostNodesWithStatementsMap","cachedHostStatementsMap","memberExpressionHostNode","propertiesLength","expressionStatements","removablePropertyIds","propertyValue","isProhibitedPattern","propertyKeyName","getPropertyNodeKeyName","memberExpressionProperty","memberExpressionNode","expressionStatementNode","assignmentExpressionNode","isObjectExpressionNode","transformObjectExpressionNode","objectExpressionNode","filter","_this$extractProperti","extractPropertiesToExpressionStatements","_this$extractProperti2","_slicedToArray2","hostStatement","getHostStatement","hostNodeWithStatements","getHostNodeWithStatements","filterExtractedObjectExpressionProperties","insertAfter","propertyNode","propertyKeyNode","isObjectPatternNode","isArrayPatternNode","isAssignmentPatternNode","isRestElementNode","CustomNodeGroup","AbstractIdentifierNamesGenerator","some","reservedName","exec","LiteralObfuscatingReplacer","ObfuscatingGuard","Initializable_1","MapStorage","storage","storageId","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","iterator","next","done","_step$value","err","return","size","mergeId","postConstruct","md5_1","__importDefault","chance_1","RandomGenerator","RandomGenerator_1","min","md5Hash","floor","random","Chance","getSourceCode","Number","integer","pool","randomGeneratorPool","string","chalk_1","LoggingPrefix_1","loggingMessage","colorInfo","LoggingPrefix","Base","colorSuccess","colorWarn","loggingLevelColor","loggingPrefix","processedMessage","console","cyan","green","yellow","CalleeDataExtractor_1","FunctionDeclarationCalleeDataExtractor_1","FunctionExpressionCalleeDataExtractor_1","ObjectExpressionCalleeDataExtractor_1","StackTraceAnalyzer_1","ContainerModule","IStackTraceAnalyzer","StackTraceAnalyzer","ICalleeDataExtractor","FunctionDeclarationCalleeDataExtractor","whenTargetNamed","FunctionExpressionCalleeDataExtractor","ObjectExpressionCalleeDataExtractor","Factory__ICalleeDataExtractor","getCacheFactory","AbstractCalleeDataExtractor_1","_AbstractCalleeDataEx","blockScopeBody","calleeBlockStatement","getCalleeBlockStatement","getParentNodeWithStatements","targetNode","traverse","VisitorOption","Break","isVariableDeclaratorNode","objectMembersCallsChain","createObjectMembersCallsChain","functionExpressionName","currentChain","memberExpression","unshift","objectName","shift","findCalleeBlockStatement","objectExpressionProperties","nextItemInCallsChain","isValidTargetPropertyNode","isTargetPropertyNodeWithIdentifierKey","isTargetPropertyNodeWithLiteralKey","calleeDataExtractorFactory","analyzeRecursive","limitIndex","getLimitIndex","blockScopeBodyLength","_loop","blockScopeBodyNode","isCallExpressionNode","Skip","analyzeCallExpressionNode","callExpressionNode","_this2","calleeDataExtractorsList","calleeDataExtractorName","calleeData","extract","lastIndex","limitThresholdActivationIndex","limitThresholdActivationLength","limitThreshold","ControlFlowReplacer_1","NodeTransformer_1","BinaryExpressionControlFlowReplacer_1","BlockStatementControlFlowTransformer_1","CallExpressionControlFlowReplacer_1","DeadCodeInjectionTransformer_1","FunctionControlFlowTransformer_1","LogicalExpressionControlFlowReplacer_1","StringLiteralControlFlowReplacer_1","INodeTransformer","BlockStatementControlFlowTransformer","DeadCodeInjectionTransformer","FunctionControlFlowTransformer","IControlFlowReplacer","BinaryExpressionControlFlowReplacer","CallExpressionControlFlowReplacer","LogicalExpressionControlFlowReplacer","StringLiteralControlFlowReplacer","Factory__IControlFlowReplacer","ExpressionWithOperatorControlFlowReplacer_1","_ExpressionWithOperat","binaryExpressionNode","binaryExpressionFunctionCustomNode","BinaryExpressionFunctionNode","insertCustomNodeToControlFlowStorage","getControlFlowStorageCallNode","TransformationStage_1","AbstractNodeTransformer_1","NodeUtils_1","_AbstractNodeTransfor","arrayUtils","transformationStage","ControlFlowFlattening","leave","transformNode","blockStatementNode","canTransformBlockStatementNode","blockStatementBody","originalKeys","createWithRange","shuffledKeys","shuffle","originalKeysIndexesInShuffledArray","blockStatementControlFlowFlatteningCustomNode","BlockStatementControlFlowFlatteningNode","newBlockStatementNode","isBreakOrContinueStatement","isVariableDeclarationWithLetOrConstKind","isVariableDeclarationNode","isClassDeclaration","isClassDeclarationNode","canTransform","isWhileStatementNode","isProhibitedStatementNode","IArrayUtils","String","callExpressionFunctionCustomNode","CallExpressionFunctionNode","expressionArguments","CallExpressionControlFlowStorageCallNode","DeadCodeInjectionCustomNode_1","deadCodeInjectionCustomNodeFactory","transformersRunner","deadCodeInjectionRootAstHostNodeSet","collectedBlockStatements","collectedBlockStatementsTotalLength","DeadCodeInjection","analyzeNode","Finalizing","isDeadCodeInjectionRootAstHostNode","restoreNode","programNode","_this3","clonedBlockStatementNode","clone","isValidCollectedBlockStatementNode","transformedBlockStatementNode","makeClonedBlockStatementNodeUnique","minCollectedBlockStatementsCount","isValidWrappedBlockStatementNode","maxInteger","randomIndex","randomBlockStatementNode","splice","replaceBlockStatementNode","deadCodeInjectionRootAstHostNode","hostNodeFirstStatement","hostNode","functionExpressionNode","transform","transformersToRenameBlockScopeIdentifiers","Obfuscating","functionDeclarationNode","deadCodeInjectionRootAstHostNodeName","blockStatementDeadCodeInjectionCustomNode","BlockStatementDeadCodeInjectionNode","isAwaitExpressionNode","isSuperNode","indexInScope","slicedBody","hostBlockStatementNode","functionDeclarationName","isScopeHoistedFunctionDeclaration","nestedBlockStatementsCount","isValidBlockStatementNode","maxNestedBlockStatementsCount","isProhibitedNodeInsideCollectedBlockStatement","isScopeHoistingFunctionDeclaration","CatchClauseTransformer","ClassDeclarationTransformer","FunctionDeclarationTransformer","FunctionTransformer","LabeledStatementTransformer","VariableDeclarationTransformer","Factory__IDeadCodeInjectionCustomNode","controlFlowStorageFactory","controlFlowReplacerFactory","controlFlowData","visitedFunctionNodes","hostNodesWithControlFlowNode","functionNode","getHostNode","getControlFlowStorage","transformFunctionBody","getLength","controlFlowStorageCustomNode","ControlFlowStorageNode","hostControlFlowStorage","mergeWith","functionNodeBody","blockScopesOfNode","getParentNodesWithStatements","pop","hostNodeSearchMinDepth","hostNodeSearchMaxDepth","isIgnoredNode","isVisitedFunctionNode","controlFlowReplacersMap","controlFlowReplacerName","Factory__TControlFlowStorage","logicalExpressionNode","checkForProhibitedExpressions","logicalExpressionFunctionCustomNode","LogicalExpressionFunctionNode","expressionNode","nodeForCheck","literalFunctionCustomNode","StringLiteralNode","StringLiteralControlFlowStorageCallNode","PropertiesExtractor_1","AssignmentExpressionPropertiesExtractor_1","MemberExpressionTransformer_1","MethodDefinitionTransformer_1","ObjectExpressionKeysTransformer_1","ObjectExpressionTransformer_1","TemplateLiteralTransformer_1","VariableDeclaratorPropertiesExtractor_1","MemberExpressionTransformer","MethodDefinitionTransformer","ObjectExpressionKeysTransformer","ObjectExpressionTransformer","TemplateLiteralTransformer","IPropertiesExtractor","AssignmentExpressionPropertiesExtractor","VariableDeclaratorPropertiesExtractor","Factory__IPropertiesExtractor","_AbstractPropertiesEx","hostParentNode","leftNode","isProhibitedHostParent","Converting","methodDefinitionNode","ignoredNames","propertiesExtractorFactory","propertiesExtractorName","propertiesExtractorsMap","escapeSequenceEncoder","transformComputedProperty","transformBaseProperty","getPropertyKeyValue","inputValue","encode","IEscapeSequenceEncoder","isValidTemplateLiteralNode","templateLiteralNode","transformedNode","templateLiteralExpressions","expressions","nodes","quasis","templateElement","cooked","isLiteralNodeWithStringValue","root","isTemplateLiteralNode","isTaggedTemplateExpressionNode","isProhibitedObjectExpressionNode","variableDeclaratorNode","hostVariableDeclarator","getHostVariableDeclaratorNode","getHostVariableDeclarationNode","indexOfDeclarator","variableDeclarator","CustomNode_1","CustomNodeGroup_1","ConsoleOutputCustomNodeGroup_1","DebugProtectionCustomNodeGroup_1","DomainLockCustomNodeGroup_1","SelfDefendingCustomNodeGroup_1","StringArrayCustomNodeGroup_1","BinaryExpressionFunctionNode_1","BlockStatementControlFlowFlatteningNode_1","BlockStatementDeadCodeInjectionNode_1","CallExpressionControlFlowStorageCallNode_1","CallExpressionFunctionNode_1","ControlFlowStorageNode_1","ConsoleOutputDisableExpressionNode_1","DebugProtectionFunctionCallNode_1","DebugProtectionFunctionIntervalNode_1","DebugProtectionFunctionNode_1","DomainLockNode_1","ExpressionWithOperatorControlFlowStorageCallNode_1","LogicalExpressionFunctionNode_1","NodeCallsControllerFunctionNode_1","SelfDefendingUnicodeNode_1","StringArrayCallsWrapper_1","StringArrayNode_1","StringArrayRotateFunctionNode_1","StringLiteralControlFlowStorageCallNode_1","StringLiteralNode_1","ICustomNode","ConsoleOutputDisableExpressionNode","DebugProtectionFunctionCallNode","DebugProtectionFunctionIntervalNode","DebugProtectionFunctionNode","DomainLockNode","NodeCallsControllerFunctionNode","SelfDefendingUnicodeNode","StringArrayCallsWrapper","StringArrayNode","StringArrayRotateFunctionNode","Newable__ICustomNode","toConstructor","ICustomNodeGroup","ConsoleOutputCustomNodeGroup","DebugProtectionCustomNodeGroup","DomainLockCustomNodeGroup","SelfDefendingCustomNodeGroup","StringArrayCustomNodeGroup","Factory__ICustomNode","getFactory","getConstructorFactory","Factory__ICustomNodeGroup","ObfuscationEvent_1","AbstractCustomNodeGroup_1","_AbstractCustomNodeGr","customNodeFactory","BeforeObfuscation","randomStackTraceIndex","getRandomStackTraceIndex","appendCustomNodeIfExist","appendToOptimalBlockScope","targetNodeWithStatements","callsControllerFunctionName","consoleOutputDisableExpressionNode","nodeCallsControllerFunctionNode","append","programBodyLength","debugProtectionFunctionName","debugProtectionFunctionNode","debugProtectionFunctionCallNode","debugProtectionFunctionIntervalNode","domainLockNode","AfterObfuscation","selfDefendingUnicodeNode","stringArrayStorage","stringArrayRotateValue","stringArrayNode","stringArrayCallsWrapper","stringArrayRotateFunctionNode","_stringArrayStorageId","_stringArrayStorageId2","stringArrayName","stringArrayCallsWrapperName","TStringArrayStorage","_AbstractCustomNode_","returnStatementNode","controllerIdentifierName","indexIdentifierName","variableDeclarationNode","join","whileStatementNode","switchStatementNode","updateExpressionNode","isReturnStatementNode","continueStatement","switchCaseNode","breakStatement","random1","random2","leftString","rightString","_ref","_ref2","ifStatementNode","controlFlowStorageName","controlFlowStorageKey","calleeIdentifier","argumentsLength","propertyNodes","from","string_template_1","ConsoleOutputDisableExpressionTemplate_1","GlobalVariableNoEvalTemplate_1","convertCodeToStructure","getTemplate","globalVariableTemplate","BrowserNoEval","getGlobalVariableTemplate","ConsoleOutputDisableExpressionTemplate","consoleLogDisableFunctionName","singleNodeCallControllerFunctionName","DebugProtectionFunctionCallTemplate_1","DebugProtectionFunctionCallTemplate","DebugProtectionFunctionIntervalTemplate_1","DebugProtectionFunctionIntervalTemplate","DebuggerTemplate_1","DebuggerTemplateNoEval_1","DebugProtectionFunctionTemplate_1","debuggerTemplate","DebuggerTemplate","DebuggerTemplateNoEval","DebugProtectionFunctionTemplate","DomainLockNodeTemplate_1","cryptUtils","domainsString","_this$cryptUtils$hide","hideString","_this$cryptUtils$hide2","hiddenDomainsString","diff","DomainLockNodeTemplate","domainLockFunctionName","domains","ICryptUtils","leftValue","rightValue","SingleNodeCallControllerTemplate_1","NoCustomNodes_1","JavaScriptObfuscatorFacade_1","SingleNodeCallControllerTemplate","getObfuscatedCode","SelfDefendingTemplate_1","SelfDefendingTemplate","selfDefendingFunctionName","StringArrayEncoding_1","AtobTemplate_1","Rc4Template_1","StringArrayBase64DecodeNodeTemplate_1","StringArrayCallsWrapperTemplate_1","StringArrayRC4DecodeNodeTemplate_1","decodeNodeTemplate","getDecodeStringArrayTemplate","StringArrayCallsWrapperTemplate","atobPolyfill","AtobTemplate","decodeStringArrayTemplate","selfDefendingCode","Rc4","StringArrayRc4DecodeNodeTemplate","rc4Polyfill","Rc4Template","Base64","StringArrayBase64DecodeNodeTemplate","rc4BytesIdentifier","statesIdentifier","newStateIdentifier","firstStateIdentifier","secondStateIdentifier","checkStateIdentifier","runStateIdentifier","getStateIdentifier","stateResultIdentifier","initializedIdentifier","base64DecodeFunctionIdentifier","dataIdentifier","rc4Identifier","onceIdentifier","StringArrayTemplate_1","rotateArray","_get2","StringArrayTemplate","StringArrayRotateFunctionTemplate_1","NumberUtils_1","timesName","whileFunctionName","StringArrayRotateFunctionTemplate","toHex","literalValue","HexadecimalIdentifierNamesGenerator_1","MangledIdentifierNamesGenerator_1","IIdentifierNamesGenerator","MangledIdentifierNamesGenerator","cachedIdentifierNamesGenerator","AbstractIdentifierNamesGenerator_1","Utils_1","_AbstractIdentifierNa","randomVariableNameSet","nameLength","randomInteger","hexadecimalNumber","prefixLength","baseNameLength","baseIdentifierNameLength","baseIdentifierName","substr","identifierName","previousMangledName","initMangledNameCharacter","generateNewMangledName","mangledName","nameSequence","zeroSequence","num","repeat","character","charAt","indexInSequence","substring","newMangledName","isValidIdentifierName","Factory__INodeTransformer","IdentifierObfuscatingReplacer_1","LiteralObfuscatingReplacer_1","BaseIdentifierObfuscatingReplacer_1","BooleanLiteralObfuscatingReplacer_1","CatchClauseTransformer_1","ClassDeclarationTransformer_1","FunctionDeclarationTransformer_1","FunctionTransformer_1","ImportDeclarationTransformer_1","LabeledStatementTransformer_1","LiteralTransformer_1","NumberLiteralObfuscatingReplacer_1","StringLiteralObfuscatingReplacer_1","VariableDeclarationTransformer_1","ImportDeclarationTransformer","LiteralTransformer","IObfuscatingReplacer","BooleanLiteralObfuscatingReplacer","NumberLiteralObfuscatingReplacer","StringLiteralObfuscatingReplacer","IIdentifierObfuscatingReplacer","BaseIdentifierObfuscatingReplacer","Factory__IObfuscatingReplacer","Factory__IIdentifierObfuscatingReplacer","AbstractObfuscatingReplacer_1","_AbstractObfuscatingR","blockScopesMap","nodeValue","lexicalScopeNode","namesMap","nodeName","isReservedName","generateWithPrefix","getTrueUnaryExpressionNode","getFalseUnaryExpressionNode","arrayExpressionNode","NodeLexicalScopeUtils_1","identifierObfuscatingReplacerFactory","identifierObfuscatingReplacer","isCatchClauseNode","catchClauseNode","getLexicalScope","storeCatchClauseParam","replaceCatchClauseParam","param","storeLocalName","isReplaceableIdentifierNode","newIdentifierName","renamedIdentifier","replaceableIdentifiers","isExportNamedDeclarationNode","classDeclarationNode","isGlobalDeclaration","storeClassName","replaceScopeCachedIdentifiers","replaceScopeIdentifiers","storeGlobalName","cachedReplaceableIdentifiers","cachedReplaceableIdentifierLength","replaceableIdentifier","newReplaceableIdentifier","storedReplaceableIdentifiersNamesMap","isRenamedIdentifier","storedReplaceableIdentifiers","storeFunctionName","storeFunctionParams","replaceFunctionParams","getLexicalScopes","visitor","isProhibitedIdentifierOfPropertyNode","paramsNode","_this4","ignoredIdentifierNamesSet","isProhibitedIdentifierOfShorthandPropertyNode","isGlobalFunctionDeclarationIdentifier","isImportDeclarationNode","importDeclarationNode","storeImportSpecifierNames","specifiers","importSpecifierNode","isProhibitedImportSpecifierNode","local","_this5","isImportSpecifierNode","imported","labeledStatementNode","storeLabeledStatementName","replaceLabeledStatementName","newIdentifier","literalObfuscatingReplacerFactory","isReplacedLiteral","isProhibitedNode","newLiteralNode","numberLiteralCache","rawValue","isCeil","nodesCache","stringLiteralHexadecimalIndexCache","rc4Keys","rc4KeyLength","rc4KeysCount","isReservedString","replaceWithReservedLiteralNode","useStringArray","canUseStringArray","cacheKey","resultNode","replaceWithStringArrayCallNode","replaceWithLiteralNode","minimumLengthForStringArray","stringArrayStorageLength","fromCache","hexadecimalRawIndex","hexadecimalIndex","encodedValue","btoa","rc4","_this$getEncodedValue","getEncodedValue","escapedValue","stringArrayStorageCallsWrapperName","_this$getStringArrayH","getStringArrayHexadecimalIndex","callExpressionArgs","getHexadecimalLiteralNode","getRc4KeyLiteralNode","stringArrayIdentifierNode","reservedString","hexadecimalLiteralNode","replacedLiteral","rc4KeyLiteralNode","NodeBlockLexicalScopeUtils_1","NodeBlockLexicalScopeUtils","storeVariableNames","traverseDeclarationIdentifiers","cachedReplaceableIdentifiersNamesMap","identifierNames","declarationNode","isNodeWithBlockLexicalScope","Options_1","OptionsNormalizer_1","Options","IOptionsNormalizer","OptionsNormalizer","class_validator_1","Default_1","ValidationErrorsFormatter_1","optionsNormalizer","errors","validateSync","validatorOptions","ValidationErrorsFormatter","format","normalize","validationError","IsBoolean","IsNumber","Min","Max","IsArray","ArrayUnique","IsString","each","IsIn","ValidateIf","IsUrl","require_protocol","require_tld","require_valid_protocol","Inline","Node","errorMessages","error","formatWithNestedConstraints","constraints","rootError","nestedErrors","constraint","ControlFlowFlatteningThresholdRule_1","DeadCodeInjectionRule_1","DeadCodeInjectionThresholdRule_1","DomainLockRule_1","InputFileNameRule_1","SelfDefendingRule_1","SourceMapBaseUrlRule_1","SourceMapFileNameRule_1","StringArrayRule_1","StringArrayEncodingRule_1","StringArrayThresholdRule_1","normalizedOptions","normalizerRules","normalizerRule","ControlFlowFlatteningThresholdRule","DeadCodeInjectionRule","DeadCodeInjectionThresholdRule","DomainLockRule","InputFileNameRule","SelfDefendingRule","SourceMapBaseUrlRule","SourceMapFileNameRule","StringArrayRule","StringArrayEncodingRule","StringArrayThresholdRule","normalizedDomains","domain","extractDomainFrom","endsWith","ObfuscatingGuard_1","BlackListObfuscatingGuard_1","CommentsTransformer_1","ConditionalCommentObfuscatingGuard_1","CustomNodesTransformer_1","EvaCallExpressionTransformer_1","MetadataTransformer_1","ObfuscatingGuardsTransformer_1","ParentificationTransformer_1","CommentsTransformer","CustomNodesTransformer","EvalCallExpressionTransformer","MetadataTransformer","ObfuscatingGuardsTransformer","ParentificationTransformer","INodeGuard","BlackListObfuscatingGuard","BlackListNodeGuard","ConditionalCommentObfuscatingGuard","ConditionalCommentNodeGuard","Factory__INodeGuard","blackListGuardsLength","blackListGuards","isUseStrictOperator","Preparing","isNodeWithComments","transformComments","comments","comment","preservedWords","preservedWord","obfuscationAllowedForCurrentNode","obfuscationAllowedForNextNode","checkComments","commentsLength","obfuscationAllowed","obfuscationEnableCommentRegExp","obfuscationDisableCommentRegExp","stackTraceAnalyzer","obfuscationEventEmitter","customNodeGroupStorage","appendCustomNodesBeforeObfuscation","appendCustomNodesAfterObfuscation","analyze","customNodeGroup","once","getAppendEvent","appendCustomNodes","emit","TCustomNodeGroupStorage","js_string_escape_1","EvalCallExpressionTransformer_1","evalRootAstHostNodeSet","isEvalRootAstHostNode","callExpressionFirstArgument","ast","evalString","extractEvalStringFromCallExpressionArgument","_a","evalRootAstHostNode","targetAst","convertStructureToCode","extractEvalStringFromLiteralNode","extractEvalStringFromTemplateLiteralNode","obfuscatingGuardFactory","obfuscatingGuards","obfuscatingGuardsList","every","nodeGuard","check","ControlFlowStorage_1","CustomNodeGroupStorage_1","StringArrayStorage_1","CustomNodeGroupStorage","StringArrayStorage","Newable__TControlFlowStorage","ControlFlowStorage","_MapStorage_1$MapStor","MapStorage_1","customNodeGroupFactory","customNodeGroupsList","customNodeGroupName","ArrayStorage_1","_ArrayStorage_1$Array","baseStringArrayName","stringArrayNameLength","baseStringArrayCallsWrapperName","rotationValue","rotate","ArrayStorage","storageLength","ArrayUtils_1","CryptUtils_1","EscapeSequenceEncoder_1","ArrayUtils","CryptUtils","EscapeSequenceEncoder","range","array","times","temp","newArray","shuffledArray","j","output","encodeURIComponent","match","p1","fromCharCode","parseInt","block","charCode","idx","charCodeAt","str","randomStringDiff","randomStringDiffArray","s1","s2","i1","i2","randomMerge","x","y","stringsCache","encodeAllSymbols","template","replaceRegExp","escapeSequenceRegExp","regExp","LoggingMessage_1","EspreeFacade_1","obfuscatedCodeFactory","logger","timeStart","Date","now","info","LoggingMessage","Version","ObfuscationStarted","RandomGeneratorSeed","getSeed","parseCode","obfuscatedAstTree","transformAstTree","generatorOutput","generateCode","obfuscationTime","success","ObfuscationCompleted","EspreeFacade","espreeParseOptions","runTransformationStage","warn","EmptySourceCode","escodegenParams","sourceContent","transformersList","attachComment","ecmaFeatures","experimentalObjectRestSpread","ecmaVersion","loc","verbatim","input","sourceTypeLength","sourceTypes","parseType","processParsingError","message","line","lineNumber","column","inputConfig","errorMessage","position","errorLine","startErrorIndex","nearestSymbolsCount","endErrorIndex","formattedPointer","colorError","formattedCodeSlice","red","events_1","decorate","EventEmitter","_events_1$EventEmitte","correctObfuscatedCode","sourceMapUrl","sourceMappingUrl","VisitorDirection_1","nodeTransformerFactory","nodeTransformers","enterVisitors","leaveVisitors","nodeTransformersLength","getVisitor","mergeVisitorsForDirection","VisitorDirection","Enter","Leave","visitors","direction","visitorsLength","visitorFunction","visitorResult","isNode","commander","path","ArraySanitizer_1","BooleanSanitizer_1","IdentifierNamesGeneratorSanitizer_1","ObfuscatingTargetSanitizer_1","SourceMapModeSanitizer_1","StringArrayEncodingSanitizer_1","CLIUtils_1","SourceCodeReader_1","JavaScriptObfuscatorCLI","argv","rawArguments","inputPath","commands","Command","configureCommands","configureHelp","inputCLIOptions","opts","outputHelp","sourceCodeData","SourceCodeReader","readSourceCode","processSourceCodeData","filterOptions","configFilePath","configFileLocation","resolve","configFileOptions","CLIUtils","getUserConfig","basename","usage","option","BooleanSanitizer","parseFloat","ArraySanitizer","IdentifierNamesGeneratorSanitizer","SourceMapModeSanitizer","StringArrayEncodingSanitizer","ObfuscationTargetSanitizer","on","outputPath","filePath","outputCodePath","getOutputCodePath","processSourceCode","sourceCodeIndex","buildOptions","baseIdentifiersPrefix","processSourceCodeWithSourceMap","processSourceCodeWithoutSourceMap","filteredOptions","writeFile","outputSourceMapPath","getOutputSourceMapPath","getSourceMap","encoding","obfuscatedFilePrefix","JavaScriptObfuscatorCLIFacade_1","JavaScriptObfuscatorCLI_1","JavaScriptObfuscatorCLIFacade","javaScriptObfuscatorCLI","run","SyntaxError","trim","fs","mkdirp","lastIndexOf","configPath","_b","data","sync","dirname","writeFileSync","webpackEmptyContext","req","e","multimatch_1","isFilePath","isValidFile","readFile","isDirectoryPath","isValidDirectory","readDirectoryRecursive","availableFilePaths","availableInputExtensions","extension","directoryPath","fileData","readdirSync","fileName","logFilePath","readFileSync","isExcludedPath","extname","excludePatterns","isExcludedFilePathByGlobPattern","excludePattern","statSync","isDirectory","isFile","normalizedFilePath","CLI"],"mappings":"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","file":"index.cli.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 202);\n","module.exports = require(\"@babel/runtime/helpers/interopRequireDefault\");","module.exports = require(\"@babel/runtime/helpers/classCallCheck\");","module.exports = require(\"inversify\");","module.exports = require(\"@babel/runtime/helpers/createClass\");","module.exports = require(\"tslib\");","export enum ServiceIdentifiers {\n    Factory__ICalleeDataExtractor = 'Factory<ICalleeDataExtractor>',\n    Factory__IControlFlowCustomNode = 'Factory<IControlFlowCustomNode>',\n    Factory__IControlFlowReplacer = 'Factory<IControlFlowReplacer>',\n    Factory__ICustomNode = 'Factory<ICustomNode>',\n    Factory__ICustomNodeGroup = 'Factory<ICustomNodeGroup>',\n    Factory__IDeadCodeInjectionCustomNode = 'Factory<IDeadCodeInjectionCustomNode>',\n    Factory__IIdentifierNamesGenerator = 'Factory<IIdentifierNamesGenerator>',\n    Factory__IIdentifierObfuscatingReplacer = 'Factory<IIdentifierObfuscatingReplacer>',\n    Factory__INodeGuard = 'Factory<INodeGuard>',\n    Factory__INodeTransformer = 'Factory<INodeTransformer[]>',\n    Factory__IObfuscatedCode = 'Factory<IObfuscatedCode>',\n    Factory__IObfuscatingReplacer = 'Factory<IObfuscatingReplacer>',\n    Factory__IPropertiesExtractor = 'Factory<IPropertiesExtractor>',\n    Factory__TControlFlowStorage = 'Factory<TControlFlowStorage>',\n    IArrayUtils = 'IArrayUtils',\n    ICalleeDataExtractor = 'ICalleeDataExtractor',\n    ICryptUtils = 'ICryptUtils',\n    ICustomNode = 'ICustomNode',\n    ICustomNodeGroup = 'ICustomNodeGroup',\n    IControlFlowReplacer = 'IControlFlowReplacer',\n    IEscapeSequenceEncoder = 'IEscapeSequenceEncoder',\n    IIdentifierNamesGenerator = 'IIdentifierNamesGenerator',\n    IIdentifierObfuscatingReplacer = 'IIdentifierObfuscatingReplacer',\n    IJavaScriptObfuscator = 'IJavaScriptObfuscator',\n    ILogger = 'ILogger',\n    INodeGuard = 'INodeGuard',\n    INodeTransformer = 'INodeTransformer',\n    IObfuscationEventEmitter = 'IObfuscationEventEmitter',\n    IObfuscatedCode = 'IObfuscatedCode',\n    IOptions = 'IOptions',\n    IOptionsNormalizer = 'IOptionsNormalizer',\n    IObfuscatingReplacer = 'IObfuscatingReplacer',\n    IPropertiesExtractor = 'IPropertiesExtractor',\n    IRandomGenerator = 'IRandomGenerator',\n    ISourceCode = 'ISourceCode',\n    ISourceMapCorrector = 'ISourceMapCorrector',\n    IStackTraceAnalyzer = 'IStackTraceAnalyzer',\n    ITransformersRunner = 'ITransformersRunner',\n    Newable__ICustomNode = 'Newable<ICustomNode>',\n    Newable__TControlFlowStorage = 'Newable<TControlFlowStorage>',\n    TCustomNodeGroupStorage = 'TCustomNodeGroupStorage',\n    TInputOptions = 'TInputOptions',\n    TStringArrayStorage = 'TStringArrayStorage'\n}\n","module.exports = require(\"@babel/runtime/helpers/possibleConstructorReturn\");","module.exports = require(\"@babel/runtime/helpers/getPrototypeOf\");","module.exports = require(\"@babel/runtime/helpers/inherits\");","import * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../types/node/TNodeWithLexicalScope';\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\n\nimport { NodeType } from '../enums/node/NodeType';\n\nexport class NodeGuards {\n    /**\n     * @type {string[]}\n     */\n    private static readonly nodesWithLexicalStatements: string[] = [\n        NodeType.ArrowFunctionExpression,\n        NodeType.FunctionDeclaration,\n        NodeType.FunctionExpression,\n        NodeType.MethodDefinition,\n    ];\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isArrayPatternNode (node: ESTree.Node): node is ESTree.ArrayPattern {\n        return node.type === NodeType.ArrayPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isArrowFunctionExpressionNode (node: ESTree.Node): node is ESTree.ArrowFunctionExpression {\n        return node.type === NodeType.ArrowFunctionExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAssignmentPatternNode (node: ESTree.Node): node is ESTree.AssignmentPattern {\n        return node.type === NodeType.AssignmentPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAwaitExpressionNode (node: ESTree.Node): node is ESTree.AwaitExpression {\n        return node.type === NodeType.AwaitExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isBlockStatementNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return node.type === NodeType.BlockStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isBreakStatementNode (node: ESTree.Node): node is ESTree.BreakStatement {\n        return node.type === NodeType.BreakStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isCallExpressionNode (node: ESTree.Node): node is ESTree.CallExpression {\n        return node.type === NodeType.CallExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isCatchClauseNode (node: ESTree.Node): node is ESTree.CatchClause {\n        return node.type === NodeType.CatchClause;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isClassDeclarationNode (node: ESTree.Node): node is ESTree.ClassDeclaration {\n        return node.type === NodeType.ClassDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isContinueStatementNode (node: ESTree.Node): node is ESTree.ContinueStatement {\n        return node.type === NodeType.ContinueStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isExportNamedDeclarationNode (node: ESTree.Node): node is ESTree.ExportNamedDeclaration {\n        return node.type === NodeType.ExportNamedDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isExpressionStatementNode (node: ESTree.Node): node is ESTree.ExpressionStatement {\n        return node.type === NodeType.ExpressionStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionNode (node: ESTree.Node): node is ESTree.Function {\n        return NodeGuards.isFunctionDeclarationNode(node) ||\n            NodeGuards.isFunctionExpressionNode(node) ||\n            NodeGuards.isArrowFunctionExpressionNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionDeclarationNode (node: ESTree.Node): node is ESTree.FunctionDeclaration {\n        return node.type === NodeType.FunctionDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionExpressionNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return node.type === NodeType.FunctionExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIdentifierNode (node: ESTree.Node): node is ESTree.Identifier {\n        return node.type === NodeType.Identifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportDeclarationNode (node: ESTree.Node): node is ESTree.ImportDeclaration {\n        return node.type === NodeType.ImportDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportSpecifierNode (node: ESTree.Node): node is ESTree.ImportSpecifier {\n        return node.type === NodeType.ImportSpecifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isLabelIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        const parentNodeIsLabeledStatementNode: boolean = NodeGuards.isLabeledStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsContinueStatementNode: boolean = NodeGuards.isContinueStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsBreakStatementNode: boolean = NodeGuards.isBreakStatementNode(parentNode) && parentNode.label === node;\n\n        return parentNodeIsLabeledStatementNode || parentNodeIsContinueStatementNode || parentNodeIsBreakStatementNode;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isLabeledStatementNode (node: ESTree.Node): node is ESTree.LabeledStatement {\n        return node.type === NodeType.LabeledStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isLiteralNode (node: ESTree.Node): node is ESTree.Literal {\n        return node.type === NodeType.Literal;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isMemberExpressionNode (node: ESTree.Node): node is ESTree.MemberExpression {\n        return node.type === NodeType.MemberExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isMethodDefinitionNode (node: ESTree.Node): node is ESTree.MethodDefinition {\n        return node.type === NodeType.MethodDefinition;\n    }\n\n    /**\n     * @param {Object} object\n     * @returns {boolean}\n     */\n    public static isNode (object: Object & { type?: string }): object is ESTree.Node {\n        return object && !object.type !== undefined;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithLexicalScope (node: ESTree.Node): node is TNodeWithLexicalScope {\n        return NodeGuards.isProgramNode(node) || NodeGuards.isFunctionNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithBlockLexicalScope (node: ESTree.Node): node is TNodeWithLexicalScope {\n        return NodeGuards.isNodeWithLexicalScope(node) || NodeGuards.isBlockStatementNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isNodeWithLexicalScopeStatements (\n        node: ESTree.Node,\n        parentNode: ESTree.Node\n    ): node is TNodeWithStatements {\n        return NodeGuards.isProgramNode(node)\n            || (NodeGuards.isBlockStatementNode(node) && NodeGuards.nodesWithLexicalStatements.includes(parentNode.type));\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithStatements (node: ESTree.Node): node is TNodeWithStatements {\n        return NodeGuards.isProgramNode(node)\n            || NodeGuards.isBlockStatementNode(node)\n            || NodeGuards.isSwitchCaseNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithComments (node: ESTree.Node): node is ESTree.Node {\n        return Boolean(node.leadingComments) || Boolean(node.trailingComments);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isObjectPatternNode (node: ESTree.Node): node is ESTree.ObjectPattern {\n        return node.type === NodeType.ObjectPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isObjectExpressionNode (node: ESTree.Node): node is ESTree.ObjectExpression {\n        return node.type === NodeType.ObjectExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isProgramNode (node: ESTree.Node): node is ESTree.Program {\n        return node.type === NodeType.Program;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isPropertyNode (node: ESTree.Node): node is ESTree.Property {\n        return node.type === NodeType.Property;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isReplaceableIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        if (!NodeGuards.isIdentifierNode(node)) {\n            return false;\n        }\n\n        const parentNodeIsPropertyNode: boolean = NodeGuards.isPropertyNode(parentNode) &&\n            !parentNode.computed &&\n            parentNode.key === node;\n        const parentNodeIsMemberExpressionNode: boolean = (\n            NodeGuards.isMemberExpressionNode(parentNode) &&\n            !parentNode.computed &&\n            parentNode.property === node\n        );\n        const parentNodeIsMethodDefinitionNode: boolean = NodeGuards.isMethodDefinitionNode(parentNode) &&\n            !parentNode.computed;\n        const isLabelIdentifierNode: boolean = NodeGuards.isLabelIdentifierNode(node, parentNode);\n\n        return !parentNodeIsPropertyNode &&\n            !parentNodeIsMemberExpressionNode &&\n            !parentNodeIsMethodDefinitionNode &&\n            !isLabelIdentifierNode;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isRestElementNode (node: ESTree.Node): node is ESTree.RestElement {\n        return node.type === NodeType.RestElement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isReturnStatementNode (node: ESTree.Node): node is ESTree.ReturnStatement {\n        return node.type === NodeType.ReturnStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isSuperNode (node: ESTree.Node): node is ESTree.Super {\n        return node.type === NodeType.Super;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isSwitchCaseNode (node: ESTree.Node): node is ESTree.SwitchCase {\n        return node.type === NodeType.SwitchCase;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isTaggedTemplateExpressionNode (node: ESTree.Node): node is ESTree.TaggedTemplateExpression {\n        return node.type === NodeType.TaggedTemplateExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isTemplateLiteralNode (node: ESTree.Node): node is ESTree.TemplateLiteral {\n        return node.type === NodeType.TemplateLiteral;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isUnaryExpressionNode (node: ESTree.Node): node is ESTree.UnaryExpression {\n        return node.type === NodeType.UnaryExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isUseStrictOperator (node: ESTree.Node): node is ESTree.ExpressionStatement {\n        return node.type === NodeType.ExpressionStatement && node.directive === 'use strict';\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isVariableDeclarationNode (node: ESTree.Node): node is ESTree.VariableDeclaration {\n        return node.type === NodeType.VariableDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isVariableDeclaratorNode (node: ESTree.Node): node is ESTree.VariableDeclarator {\n        return node.type === NodeType.VariableDeclarator;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isWhileStatementNode (node: ESTree.Node): node is ESTree.WhileStatement {\n        return node.type === NodeType.WhileStatement;\n    }\n}\n","/* tslint:disable:no-invalid-this */\n\nimport { IInitializable } from '../interfaces/IInitializable';\n\nconst defaultDescriptor: PropertyDescriptor = {\n    configurable: true,\n    enumerable: true\n};\nconst initializedTargetMetadataKey: string = '_initialized';\nconst initializablePropertiesSetMetadataKey: string = '_initializablePropertiesSet';\nconst wrappedMethodsSetMetadataKey: string = '_wrappedMethodsSet';\nconst constructorMethodName: string = 'constructor';\n\n/**\n * @param {string} initializeMethodName\n * @returns {(target: IInitializable, propertyKey: (string | symbol)) => any}\n */\nexport function initializable (\n    initializeMethodName: string = 'initialize'\n): (target: IInitializable, propertyKey: string | symbol) => any {\n    const decoratorName: string = Object.keys(this)[0];\n\n    return (target: IInitializable, propertyKey: string | symbol): PropertyDescriptor => {\n        const initializeMethod: Function = target[initializeMethodName];\n\n        if (!initializeMethod || typeof initializeMethod !== 'function') {\n            throw new Error(`\\`${initializeMethodName}\\` method with initialization logic not ` +\n                `found. \\`@${decoratorName}\\` decorator requires \\`${initializeMethodName}\\` method`);\n        }\n\n        /**\n         * Stage #1: initialize target metadata\n         */\n        initializeTargetMetadata(initializedTargetMetadataKey, false, target);\n        initializeTargetMetadata(initializablePropertiesSetMetadataKey, new Set(), target);\n        initializeTargetMetadata(wrappedMethodsSetMetadataKey, new Set(), target);\n\n        /**\n         * Stage #2: wrap target methods\n         */\n        wrapTargetMethodsInInitializedCheck(target, initializeMethodName);\n        wrapInitializeMethodInInitializeCheck(target, initializeMethodName, propertyKey);\n\n        /**\n         * Stage #3: wrap target properties\n         */\n        return wrapInitializableProperty(target, propertyKey);\n    };\n}\n\n/**\n * @param {string} metadataKey\n * @param metadataValue\n * @param {IInitializable} target\n */\nfunction initializeTargetMetadata (metadataKey: string, metadataValue: any, target: IInitializable): void {\n    const hasInitializedMetadata: boolean = Reflect.hasMetadata(metadataKey, target);\n\n    if (!hasInitializedMetadata) {\n        Reflect.defineMetadata(metadataKey, metadataValue, target);\n    }\n}\n\n/**\n * Wraps all target methods with additional logic that check that this methods will called after `initialize` method\n *\n * @param {IInitializable} target\n * @param {string} initializeMethodName\n */\nfunction wrapTargetMethodsInInitializedCheck (target: IInitializable, initializeMethodName: string): void {\n    const ownPropertyNames: string[] = Object.getOwnPropertyNames(target);\n    const prohibitedPropertyNames: string[] = [initializeMethodName, constructorMethodName];\n\n    ownPropertyNames.forEach((propertyName: string) => {\n        const initializablePropertiesSet: Set <string | symbol> = Reflect\n            .getMetadata(initializablePropertiesSetMetadataKey, target);\n        const wrappedMethodsSet: Set <string | symbol> = Reflect\n            .getMetadata(wrappedMethodsSetMetadataKey, target);\n\n        const isProhibitedPropertyName: boolean = prohibitedPropertyNames.includes(propertyName)\n            || initializablePropertiesSet.has(propertyName)\n            || wrappedMethodsSet.has(propertyName);\n\n        if (isProhibitedPropertyName) {\n            return;\n        }\n\n        const targetProperty: IInitializable[keyof IInitializable] = target[propertyName];\n\n        if (typeof targetProperty !== 'function') {\n            return;\n        }\n\n        const methodDescriptor: PropertyDescriptor = Object\n            .getOwnPropertyDescriptor(target, propertyName) || defaultDescriptor;\n        const originalMethod: Function = methodDescriptor.value;\n\n        Object.defineProperty(target, propertyName, {\n            ...methodDescriptor,\n            value: function (): void {\n                if (!Reflect.getMetadata(initializedTargetMetadataKey, this)) {\n                    throw new Error(`Class should be initialized with \\`${initializeMethodName}()\\` method`);\n                }\n\n                return originalMethod.apply(this, arguments);\n            }\n        });\n\n        wrappedMethodsSet.add(propertyName);\n    });\n}\n\n/**\n * Wraps `initialize` method with additional logic to check that `initialized` properties will set\n *\n * @param {IInitializable} target\n * @param {string} initializeMethodName\n * @param {string | symbol} propertyKey\n */\nfunction wrapInitializeMethodInInitializeCheck (\n    target: IInitializable,\n    initializeMethodName: string,\n    propertyKey: string | symbol\n): void {\n    const methodDescriptor: PropertyDescriptor = Object\n        .getOwnPropertyDescriptor(target, initializeMethodName) || defaultDescriptor;\n    const originalMethod: Function = methodDescriptor.value;\n\n    Object.defineProperty(target, initializeMethodName, {\n        ...methodDescriptor,\n        value: function (): typeof originalMethod {\n            /**\n             * should define metadata before `initialize` method call,\n             * because of cases when other methods will called inside `initialize` method\n             */\n            Reflect.defineMetadata(initializedTargetMetadataKey, true, this);\n\n            const result: typeof originalMethod = originalMethod.apply(this, arguments);\n\n            if (this[propertyKey]) {}\n\n            return result;\n        }\n    });\n}\n\n/**\n * Wraps initializable property in additional checks\n *\n * @param {IInitializable} target\n * @param {string | symbol} propertyKey\n * @returns {PropertyDescriptor}\n */\nfunction wrapInitializableProperty (target: IInitializable, propertyKey: string | symbol): PropertyDescriptor {\n    const initializablePropertiesSet: Set <string | symbol> = Reflect\n        .getMetadata(initializablePropertiesSetMetadataKey, target);\n\n    initializablePropertiesSet.add(propertyKey);\n\n    const initializablePropertyMetadataKey: string = `_${propertyKey.toString()}`;\n    const propertyDescriptor: PropertyDescriptor = Object\n            .getOwnPropertyDescriptor(target, initializablePropertyMetadataKey) || defaultDescriptor;\n\n    Object.defineProperty(target, propertyKey, {\n        ...propertyDescriptor,\n        get: function (): any {\n            if (this[initializablePropertyMetadataKey] === undefined) {\n                throw new Error(`Property \\`${propertyKey.toString()}\\` is not initialized! Initialize it first!`);\n            }\n\n            return this[initializablePropertyMetadataKey];\n        },\n        set: function (newVal: any): void {\n            this[initializablePropertyMetadataKey] = newVal;\n        }\n    });\n\n    return propertyDescriptor;\n}\n","import * as escodegen from 'escodegen-wallaby';\nimport * as espree from 'espree';\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TObject } from '../types/TObject';\n\nimport { NodeGuards } from './NodeGuards';\nimport { NodeMetadata } from './NodeMetadata';\n\nexport class NodeUtils {\n    /**\n     * @param {T} literalNode\n     * @returns {T}\n     */\n    public static addXVerbatimPropertyTo (literalNode: ESTree.Literal): ESTree.Literal {\n        literalNode['x-verbatim-property'] = {\n            content: literalNode.raw,\n            precedence: escodegen.Precedence.Primary\n        };\n\n        return literalNode;\n    }\n\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static clone <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        return NodeUtils.parentizeAst(NodeUtils.cloneRecursive(astTree));\n    }\n\n    /**\n     * @param {string} code\n     * @returns {Statement[]}\n     */\n    public static convertCodeToStructure (code: string): ESTree.Statement[] {\n        const structure: ESTree.Program = espree.parse(code, { sourceType: 'script' });\n\n        estraverse.replace(structure, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node => {\n                NodeUtils.parentizeNode(node, parentNode);\n\n                if (NodeGuards.isLiteralNode(node)) {\n                    NodeUtils.addXVerbatimPropertyTo(node);\n                }\n\n                NodeMetadata.set(node, { ignoredNode: false });\n\n                return node;\n            }\n        });\n\n        return <ESTree.Statement[]>structure.body;\n    }\n\n    /**\n     * @param {NodeGuards[]} structure\n     * @returns {string}\n     */\n    public static convertStructureToCode (structure: ESTree.Node[]): string {\n        return structure.reduce((code: string, node: ESTree.Node) => {\n            return code + escodegen.generate(node, {\n                sourceMapWithCode: true\n            }).code;\n        }, '');\n    }\n\n    /**\n     * @param {UnaryExpression} unaryExpressionNode\n     * @returns {NodeGuards}\n     */\n    public static getUnaryExpressionArgumentNode (unaryExpressionNode: ESTree.UnaryExpression): ESTree.Node {\n        if (NodeGuards.isUnaryExpressionNode(unaryExpressionNode.argument)) {\n            return NodeUtils.getUnaryExpressionArgumentNode(unaryExpressionNode.argument);\n        }\n\n        return unaryExpressionNode.argument;\n    }\n\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static parentizeAst <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        estraverse.replace(astTree, {\n            enter: NodeUtils.parentizeNode\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param {T} node\n     * @param {Node} parentNode\n     * @returns {T}\n     */\n    public static parentizeNode <T extends ESTree.Node = ESTree.Node> (node: T, parentNode: ESTree.Node | null): T {\n        node.parentNode = parentNode || node;\n\n        return node;\n    }\n\n    /**\n     * @param {T} node\n     * @returns {T}\n     */\n    private static cloneRecursive <T> (node: T): T {\n        if (node === null) {\n            return node;\n        }\n\n        const copy: TObject = {};\n\n        Object\n            .keys(node)\n            .forEach((property: string) => {\n                if (property === 'parentNode') {\n                    return;\n                }\n\n                const value: T[keyof T] = node[<keyof T>property];\n\n                let clonedValue: T[keyof T] | T[keyof T][] | null;\n\n                if (value === null || value instanceof RegExp) {\n                    clonedValue = value;\n                } else if (Array.isArray(value)) {\n                    clonedValue = value.map(NodeUtils.cloneRecursive);\n                } else if (typeof value === 'object') {\n                    clonedValue = NodeUtils.cloneRecursive(value);\n                } else {\n                    clonedValue = value;\n                }\n\n                copy[property] = clonedValue;\n            });\n\n        return <T>copy;\n    }\n}\n","export enum TransformationStage {\n    Preparing = 'Preparing',\n    DeadCodeInjection = 'DeadCodeInjection',\n    ControlFlowFlattening = 'ControlFlowFlattening',\n    Converting = 'Converting',\n    Obfuscating = 'Obfuscating',\n    Finalizing = 'Finalizing'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { INodeTransformer } from '../interfaces/node-transformers/INodeTransformer';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../enums/node-transformers/TransformationStage';\n\n@injectable()\nexport abstract class AbstractNodeTransformer implements INodeTransformer {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public abstract getVisitor (transformationStage: TransformationStage): IVisitor | null;\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node | VisitorOption}\n     */\n    public abstract transformNode (node: ESTree.Node, parentNode: ESTree.Node): ESTree.Node | estraverse.VisitorOption;\n}\n","/* tslint:disable:max-file-line-count */\n\nimport * as escodegen from 'escodegen-wallaby';\nimport * as ESTree from 'estree';\n\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeType } from '../enums/node/NodeType';\n\nexport class NodeFactory {\n    /**\n     * @param {TStatement[]} body\n     * @returns {Program}\n     */\n    public static programNode (body: TStatement[] = []): ESTree.Program {\n        return {\n            type: NodeType.Program,\n            body,\n            sourceType: 'script',\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {(Expression | SpreadElement)[]} elements\n     * @returns {ArrayExpression}\n     */\n    public static arrayExpressionNode (\n        elements: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.ArrayExpression {\n        return {\n            type: NodeType.ArrayExpression,\n            elements,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {AssignmentOperator} operator\n     * @param {Pattern | MemberExpression} left\n     * @param {Expression} right\n     * @returns {AssignmentExpression}\n     */\n    public static assignmentExpressionNode (\n        operator: ESTree.AssignmentOperator,\n        left: ESTree.Pattern | ESTree.MemberExpression,\n        right: ESTree.Expression\n    ): ESTree.AssignmentExpression {\n        return {\n            type: NodeType.AssignmentExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {BinaryOperator} operator\n     * @param {Expression} left\n     * @param {Expression} right\n     * @returns {BinaryExpression}\n     */\n    public static binaryExpressionNode (\n        operator: ESTree.BinaryOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.BinaryExpression {\n        return {\n            type: NodeType.BinaryExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Statement[]} body\n     * @returns {BlockStatement}\n     */\n    public static blockStatementNode (body: ESTree.Statement[] = []): ESTree.BlockStatement {\n        return {\n            type: NodeType.BlockStatement,\n            body,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} label\n     * @returns {BreakStatement}\n     */\n    public static breakStatement (label?: ESTree.Identifier): ESTree.BreakStatement {\n        return {\n            type: NodeType.BreakStatement,\n            label,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} args\n     * @returns {CallExpression}\n     */\n    public static callExpressionNode (\n        callee: ESTree.Expression,\n        args: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.CallExpression {\n        return {\n            type: NodeType.CallExpression,\n            callee,\n            arguments: args,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} label\n     * @returns {ContinueStatement}\n     */\n    public static continueStatement (label?: ESTree.Identifier): ESTree.ContinueStatement {\n        return {\n            type: NodeType.ContinueStatement,\n            label,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} expression\n     * @returns {ExpressionStatement}\n     */\n    public static expressionStatementNode (expression: ESTree.Expression): ESTree.ExpressionStatement {\n        return {\n            type: NodeType.ExpressionStatement,\n            expression,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {string} functionName\n     * @param {Identifier[]} params\n     * @param {BlockStatement} body\n     * @returns {FunctionDeclaration}\n     */\n    public static functionDeclarationNode (\n        functionName: string,\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionDeclaration {\n        return {\n            type: NodeType.FunctionDeclaration,\n            id: NodeFactory.identifierNode(functionName),\n            params,\n            body,\n            generator: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier[]} params\n     * @param {BlockStatement} body\n     * @returns {FunctionExpression}\n     */\n    public static functionExpressionNode (\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionExpression {\n        return {\n            type: NodeType.FunctionExpression,\n            params,\n            body,\n            generator: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {BlockStatement} consequent\n     * @param {BlockStatement} alternate\n     * @returns {IfStatement}\n     */\n    public static ifStatementNode (\n        test: ESTree.Expression,\n        consequent: ESTree.BlockStatement,\n        alternate?: ESTree.BlockStatement\n    ): ESTree.IfStatement {\n        return {\n            type: NodeType.IfStatement,\n            test,\n            consequent,\n            ...alternate && { alternate },\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {string} name\n     * @returns {Identifier}\n     */\n    public static identifierNode (name: string): ESTree.Identifier {\n        return {\n            type: NodeType.Identifier,\n            name,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {boolean | number | string} value\n     * @param {string} raw\n     * @returns {Literal}\n     */\n    public static literalNode (value: boolean | number | string, raw?: string): ESTree.Literal {\n        raw = raw !== undefined ? raw : `'${value}'`;\n\n        return {\n            type: NodeType.Literal,\n            value,\n            raw,\n            'x-verbatim-property': {\n                content: raw,\n                precedence: escodegen.Precedence.Primary\n            },\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {LogicalOperator} operator\n     * @param {Expression} left\n     * @param {Expression} right\n     * @returns {LogicalExpression}\n     */\n    public static logicalExpressionNode (\n        operator: ESTree.LogicalOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.LogicalExpression {\n        return {\n            type: NodeType.LogicalExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression | Super} object\n     * @param {Expression} property\n     * @param {boolean} computed\n     * @returns {MemberExpression}\n     */\n    public static memberExpressionNode (\n        object: ESTree.Expression | ESTree.Super,\n        property: ESTree.Expression,\n        computed: boolean = false\n    ): ESTree.MemberExpression {\n        return {\n            type: NodeType.MemberExpression,\n            computed,\n            object,\n            property,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} key\n     * @param {FunctionExpression} value\n     * @param {\"constructor\" | \"method\" | \"get\" | \"set\"} kind\n     * @param {boolean} computed\n     * @returns {MethodDefinition}\n     */\n    public static methodDefinitionNode (\n        key: ESTree.Expression,\n        value: ESTree.FunctionExpression,\n        kind: 'constructor' | 'method' | 'get' | 'set',\n        computed: boolean,\n    ): ESTree.MethodDefinition {\n        return {\n            type: NodeType.MethodDefinition,\n            key,\n            value,\n            kind,\n            computed,\n            static: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Property[]} properties\n     * @returns {ObjectExpression}\n     */\n    public static objectExpressionNode (properties: ESTree.Property[]): ESTree.ObjectExpression {\n        return {\n            type: NodeType.ObjectExpression,\n            properties,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} key\n     * @param {Expression | Pattern} value\n     * @param {boolean} computed\n     * @returns {Property}\n     */\n    public static propertyNode (\n        key: ESTree.Expression,\n        value: ESTree.Expression | ESTree.Pattern,\n        computed: boolean = false\n    ): ESTree.Property {\n        return {\n            type: NodeType.Property,\n            key,\n            value,\n            kind: 'init',\n            method: false,\n            shorthand: false,\n            computed,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} argument\n     * @returns {ReturnStatement}\n     */\n    public static returnStatementNode (argument: ESTree.Expression): ESTree.ReturnStatement {\n        return {\n            type: NodeType.ReturnStatement,\n            argument,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} discriminant\n     * @param {SwitchCase[]} cases\n     * @returns {SwitchStatement}\n     */\n    public static switchStatementNode (\n        discriminant: ESTree.Expression,\n        cases: ESTree.SwitchCase[]\n    ): ESTree.SwitchStatement {\n        return {\n            type: NodeType.SwitchStatement,\n            discriminant,\n            cases,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {Statement[]} consequent\n     * @returns {SwitchCase}\n     */\n    public static switchCaseNode (test: ESTree.Expression, consequent: ESTree.Statement[]): ESTree.SwitchCase {\n        return {\n            type: NodeType.SwitchCase,\n            test,\n            consequent,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {UnaryOperator} operator\n     * @param {Expression} argument\n     * @param {true} prefix\n     * @returns {UnaryExpression}\n     */\n    public static unaryExpressionNode (\n        operator: ESTree.UnaryOperator,\n        argument: ESTree.Expression,\n        prefix: true = true\n    ): ESTree.UnaryExpression {\n        return {\n            type: NodeType.UnaryExpression,\n            operator,\n            argument,\n            prefix,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {UpdateOperator} operator\n     * @param {Expression} argumentExpr\n     * @returns {UpdateExpression}\n     */\n    public static updateExpressionNode (operator: ESTree.UpdateOperator, argumentExpr: ESTree.Expression): ESTree.UpdateExpression {\n        return {\n            type: NodeType.UpdateExpression,\n            operator,\n            argument: argumentExpr,\n            prefix: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {VariableDeclarator[]} declarations\n     * @param {string} kind\n     * @returns {VariableDeclaration}\n     */\n    public static variableDeclarationNode (\n        declarations: ESTree.VariableDeclarator[] = [],\n        kind: 'var' | 'let' | 'const' = 'var'\n    ): ESTree.VariableDeclaration {\n        return {\n            type: NodeType.VariableDeclaration,\n            declarations,\n            kind,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} id\n     * @param {Expression | null} init\n     * @returns {VariableDeclarator}\n     */\n    public static variableDeclaratorNode (id: ESTree.Identifier, init: ESTree.Expression | null): ESTree.VariableDeclarator {\n        return {\n            type: NodeType.VariableDeclarator,\n            id,\n            init,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {Statement} body\n     * @returns {WhileStatement}\n     */\n    public static whileStatementNode (test: ESTree.Expression, body: ESTree.Statement): ESTree.WhileStatement {\n        return {\n            type: NodeType.WhileStatement,\n            test,\n            body,\n            metadata: { ignoredNode: false }\n        };\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { IIdentifierNamesGenerator } from '../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { GlobalVariableTemplate1 } from '../templates/GlobalVariableTemplate1';\nimport { GlobalVariableTemplate2 } from '../templates/GlobalVariableTemplate2';\n\n@injectable()\nexport abstract class AbstractCustomNode implements ICustomNode {\n    /**\n     * @type {string[]}\n     */\n    private static readonly globalVariableTemplateFunctions: string[] = [\n        GlobalVariableTemplate1(),\n        GlobalVariableTemplate2()\n    ];\n\n    /**\n     * @type {TStatement[] | null}\n     */\n    protected cachedNode: TStatement[] | null = null;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    protected readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {unknown[]} args\n     */\n    public abstract initialize (...args: unknown[]): void;\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        if (!this.cachedNode) {\n            this.cachedNode = this.getNodeStructure();\n        }\n\n        return this.cachedNode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getGlobalVariableTemplate (): string {\n        return this.randomGenerator\n            .getRandomGenerator()\n            .pickone(AbstractCustomNode.globalVariableTemplateFunctions);\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected abstract getNodeStructure (): TStatement[];\n}\n","module.exports = require(\"estraverse\");","import * as ESTree from 'estree';\n\nexport class NodeMetadata {\n    /**\n     * @param {T} node\n     * @param {Partial<T[\"metadata\"]>} metadata\n     */\n    public static set <T extends ESTree.Node = ESTree.Node> (node: T, metadata: Partial<T['metadata']>): void {\n        node.metadata = Object.assign(node.metadata || {}, metadata);\n    }\n\n    /**\n     * @param {Node} node\n     * @param {keyof T} metadataKey\n     * @returns {T[keyof T] | undefined}\n     */\n    public static get <T extends ESTree.BaseNodeMetadata> (node: ESTree.Node, metadataKey: keyof T): T[keyof T] | undefined {\n        return node.metadata !== undefined\n            ? (<T>node.metadata)[metadataKey]\n            : undefined;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIgnoredNode (node: ESTree.Node): boolean {\n        return NodeMetadata.get(node, 'ignoredNode') === true;\n    }\n\n    /**\n     * @param {Node} identifierNode\n     * @returns {boolean}\n     */\n    public static isRenamedIdentifier (identifierNode: ESTree.Identifier): boolean {\n        return NodeMetadata.get<ESTree.IdentifierNodeMetadata>(identifierNode, 'renamedIdentifier') === true;\n    }\n\n    /**\n     * @param {Node} literalNode\n     * @returns {boolean}\n     */\n    public static isReplacedLiteral (literalNode: ESTree.Literal): boolean {\n        return NodeMetadata.get<ESTree.LiteralNodeMetadata>(literalNode, 'replacedLiteral') === true;\n    }\n}\n","module.exports = require(\"string-template\");","export enum NodeType {\n    ArrayExpression = 'ArrayExpression',\n    ArrayPattern = 'ArrayPattern',\n    ArrowFunctionExpression = 'ArrowFunctionExpression',\n    AssignmentExpression = 'AssignmentExpression',\n    AssignmentPattern = 'AssignmentPattern',\n    AwaitExpression = 'AwaitExpression',\n    BinaryExpression = 'BinaryExpression',\n    BlockStatement = 'BlockStatement',\n    BreakStatement = 'BreakStatement',\n    CallExpression = 'CallExpression',\n    CatchClause = 'CatchClause',\n    ClassDeclaration = 'ClassDeclaration',\n    ContinueStatement = 'ContinueStatement',\n    ExportNamedDeclaration = 'ExportNamedDeclaration',\n    ExpressionStatement = 'ExpressionStatement',\n    FunctionDeclaration = 'FunctionDeclaration',\n    FunctionExpression = 'FunctionExpression',\n    Identifier = 'Identifier',\n    IfStatement = 'IfStatement',\n    ImportDeclaration = 'ImportDeclaration',\n    ImportDefaultSpecifier = 'ImportDefaultSpecifier',\n    ImportNamespaceSpecifier = 'ImportNamespaceSpecifier',\n    ImportSpecifier = 'ImportSpecifier',\n    LabeledStatement = 'LabeledStatement',\n    Literal = 'Literal',\n    LogicalExpression = 'LogicalExpression',\n    MemberExpression = 'MemberExpression',\n    MethodDefinition = 'MethodDefinition',\n    ObjectExpression = 'ObjectExpression',\n    ObjectPattern = 'ObjectPattern',\n    Program = 'Program',\n    Property = 'Property',\n    RestElement = 'RestElement',\n    ReturnStatement = 'ReturnStatement',\n    Super = 'Super',\n    SwitchCase = 'SwitchCase',\n    SwitchStatement = 'SwitchStatement',\n    TaggedTemplateExpression = 'TaggedTemplateExpression',\n    TemplateLiteral = 'TemplateLiteral',\n    TryStatement = 'TryStatement',\n    UnaryExpression = 'UnaryExpression',\n    UpdateExpression = 'UpdateExpression',\n    VariableDeclaration = 'VariableDeclaration',\n    VariableDeclarator = 'VariableDeclarator',\n    WhileStatement = 'WhileStatement'\n}\n","import { Container, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from './ServiceIdentifiers';\n\nimport { analyzersModule } from './modules/analyzers/AnalyzersModule';\nimport { controlFlowTransformersModule } from './modules/node-transformers/ControlFlowTransformersModule';\nimport { convertingTransformersModule } from './modules/node-transformers/ConvertingTransformersModule';\nimport { customNodesModule } from './modules/custom-nodes/CustomNodesModule';\nimport { finalizingTransformersModule } from './modules/node-transformers/FinalizingTransformersModule';\nimport { generatorsModule } from './modules/generators/GeneratorsModule';\nimport { nodeTransformersModule } from './modules/node-transformers/NodeTransformersModule';\nimport { obfuscatingTransformersModule } from './modules/node-transformers/ObfuscatingTransformersModule';\nimport { optionsModule } from './modules/options/OptionsModule';\nimport { preparingTransformersModule } from './modules/node-transformers/PreparingTransformersModule';\nimport { storagesModule } from './modules/storages/StoragesModule';\nimport { utilsModule } from './modules/utils/UtilsModule';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from '../interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from '../interfaces/IJavaScriptObfsucator';\nimport { ILogger } from '../interfaces/logger/ILogger';\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IObfuscatedCode } from '../interfaces/source-code/IObfuscatedCode';\nimport { ISourceCode } from '../interfaces/source-code/ISourceCode';\nimport { ITransformersRunner } from '../interfaces/node-transformers/ITransformersRunner';\n\nimport { JavaScriptObfuscator } from '../JavaScriptObfuscator';\nimport { Logger } from '../logger/Logger';\nimport { ObfuscationEventEmitter } from '../event-emitters/ObfuscationEventEmitter';\nimport { ObfuscatedCode } from '../source-code/ObfuscatedCode';\nimport { SourceCode } from '../source-code/SourceCode';\nimport { TransformersRunner } from '../node-transformers/TransformersRunner';\n\nexport class InversifyContainerFacade implements IInversifyContainerFacade {\n    /**\n     * @type {interfaces.Container}\n     */\n    private readonly container: interfaces.Container;\n\n    constructor () {\n        this.container = new Container();\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<U>} serviceIdentifier\n     * @returns {U}\n     */\n    public static getFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<U>\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            return (bindingName: T) => {\n                return context.container.getNamed<U>(serviceIdentifier, bindingName);\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<U>} serviceIdentifier\n     * @returns {U}\n     */\n    public static getCacheFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<U>\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            const cache: Map <T, U> = new Map();\n\n            return (bindingName: T) => {\n                if (cache.has(bindingName)) {\n                    return <U>cache.get(bindingName);\n                }\n\n                const object: U = context.container.getNamed<U>(serviceIdentifier, bindingName);\n\n                cache.set(bindingName, object);\n\n                return object;\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<interfaces.Newable<U>>} serviceIdentifier\n     * @param {interfaces.ServiceIdentifier<interfaces.Newable<Object>>[]} dependencies\n     * @returns {U}\n     */\n    public static getConstructorFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<interfaces.Newable<U>>,\n        ...dependencies: interfaces.ServiceIdentifier<interfaces.Newable<Object>>[]\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            const cache: Map<T, interfaces.Newable<U>> = new Map();\n            const cachedDependencies: Object[] = [];\n\n            return (bindingName: T) => {\n                dependencies.forEach((\n                    dependency: interfaces.ServiceIdentifier<interfaces.Newable<Object>>,\n                    index: number\n                ) => {\n                    if (!cachedDependencies[index]) {\n                        cachedDependencies[index] = context.container.get(dependency);\n                    }\n                });\n\n                if (cache.has(bindingName)) {\n                    return new (<interfaces.Newable<U>>cache.get(bindingName))(...cachedDependencies);\n                }\n\n                const constructor: interfaces.Newable<U> = context.container\n                    .getNamed<interfaces.Newable<U>>(\n                        serviceIdentifier,\n                        bindingName\n                    );\n\n                cache.set(bindingName, constructor);\n\n                return new constructor(...cachedDependencies);\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<T>} serviceIdentifier\n     * @returns {T}\n     */\n    public get <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>): T {\n        return this.container.get<T>(serviceIdentifier);\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<T>} serviceIdentifier\n     * @param {string | number | symbol} named\n     * @returns {T}\n     */\n    public getNamed <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T {\n        return this.container.getNamed<T>(serviceIdentifier, named);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} sourceMap\n     * @param {TInputOptions} options\n     */\n    public load (sourceCode: string, sourceMap: string, options: TInputOptions): void {\n        this.container\n            .bind<ISourceCode>(ServiceIdentifiers.ISourceCode)\n            .toDynamicValue(() => new SourceCode(sourceCode, sourceMap))\n            .inSingletonScope();\n\n        this.container\n            .bind<TInputOptions>(ServiceIdentifiers.TInputOptions)\n            .toDynamicValue(() => options)\n            .inSingletonScope();\n\n        this.container\n            .bind<ILogger>(ServiceIdentifiers.ILogger)\n            .to(Logger)\n            .inSingletonScope();\n\n        this.container\n            .bind<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator)\n            .to(JavaScriptObfuscator)\n            .inSingletonScope();\n\n        this.container\n            .bind<ITransformersRunner>(ServiceIdentifiers.ITransformersRunner)\n            .to(TransformersRunner)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscatedCode>(ServiceIdentifiers.IObfuscatedCode)\n            .to(ObfuscatedCode);\n\n        this.container\n            .bind<IObfuscatedCode>(ServiceIdentifiers.Factory__IObfuscatedCode)\n            .toFactory<IObfuscatedCode>((context: interfaces.Context) => {\n                return (obfuscatedCodeAsString: string, sourceMapAsString: string) => {\n                    const obfuscatedCode: IObfuscatedCode = context.container\n                        .get<IObfuscatedCode>(ServiceIdentifiers.IObfuscatedCode);\n\n                    obfuscatedCode.initialize(obfuscatedCodeAsString, sourceMapAsString);\n\n                    return obfuscatedCode;\n                };\n            });\n\n        this.container\n            .bind<IObfuscationEventEmitter>(ServiceIdentifiers.IObfuscationEventEmitter)\n            .to(ObfuscationEventEmitter)\n            .inSingletonScope();\n\n        // modules\n        this.container.load(analyzersModule);\n        this.container.load(controlFlowTransformersModule);\n        this.container.load(convertingTransformersModule);\n        this.container.load(customNodesModule);\n        this.container.load(finalizingTransformersModule);\n        this.container.load(generatorsModule);\n        this.container.load(nodeTransformersModule);\n        this.container.load(obfuscatingTransformersModule);\n        this.container.load(optionsModule);\n        this.container.load(preparingTransformersModule);\n        this.container.load(storagesModule);\n        this.container.load(utilsModule);\n    }\n\n    public unload (): void {\n        this.container.unbindAll();\n    }\n}\n","export enum ControlFlowCustomNode {\n    BinaryExpressionFunctionNode = 'BinaryExpressionFunctionNode',\n    BlockStatementControlFlowFlatteningNode = 'BlockStatementControlFlowFlatteningNode',\n    CallExpressionControlFlowStorageCallNode = 'CallExpressionControlFlowStorageCallNode',\n    CallExpressionFunctionNode = 'CallExpressionFunctionNode',\n    ControlFlowStorageNode = 'ControlFlowStorageNode',\n    ExpressionWithOperatorControlFlowStorageCallNode = 'ExpressionWithOperatorControlFlowStorageCallNode',\n    LogicalExpressionFunctionNode = 'LogicalExpressionFunctionNode',\n    StringLiteralControlFlowStorageCallNode = 'StringLiteralControlFlowStorageCallNode',\n    StringLiteralNode = 'StringLiteralNode'\n}\n","export enum IdentifierObfuscatingReplacer {\n    BaseIdentifierObfuscatingReplacer = 'BaseIdentifierObfuscatingReplacer'\n}\n","export enum ObfuscationTarget {\n    Browser = 'browser',\n    BrowserNoEval = 'browser-no-eval',\n    Node = 'node'\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeStatementUtils {\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithStatements}\n     */\n    public static getParentNodeWithStatements (node: ESTree.Node): TNodeWithStatements {\n        return NodeStatementUtils.getParentNodesWithStatementsRecursive(node, 1)[0];\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithStatements[]}\n     */\n    public static getParentNodesWithStatements (node: ESTree.Node): TNodeWithStatements[] {\n        return NodeStatementUtils.getParentNodesWithStatementsRecursive(node);\n    }\n\n    /**\n     * @param {Statement} statement\n     * @returns {TStatement | null}\n     */\n    public static getNextSiblingStatement (statement: ESTree.Statement): TStatement | null {\n        return NodeStatementUtils.getSiblingStatementByOffset(statement, 1);\n    }\n\n    /**\n     * @param {Statement} statement\n     * @returns {TStatement | null}\n     */\n    public static getPreviousSiblingStatement (statement: ESTree.Statement): TStatement | null {\n        return NodeStatementUtils.getSiblingStatementByOffset(statement, -1);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {Statement}\n     */\n    public static getRootStatementOfNode (node: ESTree.Node): ESTree.Statement {\n        if (NodeGuards.isProgramNode(node)) {\n            throw new Error('Unable to find root statement for `Program` node');\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (!NodeGuards.isNodeWithStatements(parentNode)) {\n            return NodeStatementUtils.getRootStatementOfNode(parentNode);\n        }\n\n        return <ESTree.Statement>node;\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {TNodeWithStatements}\n     */\n    public static getScopeOfNode (node: ESTree.Node): TNodeWithStatements {\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (!NodeGuards.isNodeWithStatements(parentNode)) {\n            return NodeStatementUtils.getScopeOfNode(parentNode);\n        }\n\n        return parentNode;\n    }\n\n    /***\n     * @param {Node} node\n     * @param {number} maxSize\n     * @param {TNodeWithStatements[]} nodesWithStatements\n     * @param {number} depth\n     * @returns {TNodeWithStatements[]}\n     */\n    private static getParentNodesWithStatementsRecursive (\n        node: ESTree.Node,\n        maxSize: number = Infinity,\n        nodesWithStatements: TNodeWithStatements[] = [],\n        depth: number = 0\n    ): TNodeWithStatements[] {\n        if (nodesWithStatements.length >= maxSize) {\n            return nodesWithStatements;\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (\n            /**\n             * we can add program node instantly\n             */\n            NodeGuards.isProgramNode(node) ||\n            (NodeGuards.isNodeWithLexicalScopeStatements(node, parentNode) && depth > 0)\n        ) {\n            nodesWithStatements.push(node);\n        }\n\n        if (node !== parentNode) {\n            return NodeStatementUtils.getParentNodesWithStatementsRecursive(parentNode, maxSize, nodesWithStatements, ++depth);\n        }\n\n        return nodesWithStatements;\n    }\n\n    /**\n     * @param {Statement} statement\n     * @param {number} offset\n     * @returns {TStatement | null}\n     */\n    private static getSiblingStatementByOffset (statement: ESTree.Statement, offset: number): TStatement | null {\n        const scopeNode: TNodeWithStatements = NodeStatementUtils.getScopeOfNode(statement);\n        const scopeBody: TStatement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(statement);\n\n        return scopeBody[indexInScope + offset] || null;\n    }\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { IStackTraceData } from '../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeAppender {\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     */\n    public static append (nodeWithStatements: TNodeWithStatements, statements: TStatement[]): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(nodeWithStatements, statements);\n\n        NodeAppender.setScopeStatements(nodeWithStatements, [\n            ...NodeAppender.getScopeStatements(nodeWithStatements),\n            ...statements\n        ]);\n    }\n\n    /**\n     * Appends node into a first deepest BlockStatement in order of function calls\n     *\n     * For example:\n     *\n     * function Foo () {\n     *     var baz = function () {\n     *\n     *     }\n     *\n     *     baz();\n     * }\n     *\n     * foo();\n     *\n     * Appends node into block statement of `baz` function expression\n     *\n     * @param {IStackTraceData[]} stackTraceData\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} bodyStatements\n     * @param {number} index\n     */\n    public static appendToOptimalBlockScope (\n        stackTraceData: IStackTraceData[],\n        nodeWithStatements: TNodeWithStatements,\n        bodyStatements: TStatement[],\n        index: number = 0\n    ): void {\n        const targetBlockScope: TNodeWithStatements = stackTraceData.length\n            ? NodeAppender.getOptimalBlockScope(stackTraceData, index)\n            : nodeWithStatements;\n\n        NodeAppender.prepend(targetBlockScope, bodyStatements);\n    }\n\n    /**\n     * Returns deepest block scope node at given deep.\n     *\n     * @param {IStackTraceData[]} stackTraceData\n     * @param {number} index\n     * @param {number} deep\n     * @returns {BlockStatement}\n     */\n    public static getOptimalBlockScope (\n        stackTraceData: IStackTraceData[],\n        index: number,\n        deep: number = Infinity\n    ): ESTree.BlockStatement {\n        const firstCall: IStackTraceData = stackTraceData[index];\n\n        if (deep <= 0) {\n            throw new Error('Invalid `deep` argument value. Value should be bigger then 0.');\n        }\n\n        if (deep > 1 && firstCall.stackTrace.length) {\n            return NodeAppender.getOptimalBlockScope(firstCall.stackTrace, 0, --deep);\n        } else {\n            return firstCall.callee;\n        }\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @param {Node} target\n     */\n    public static insertAfter (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[],\n        target: ESTree.Statement\n    ): void {\n        const indexInScopeStatement: number = NodeAppender\n            .getScopeStatements(nodeWithStatements)\n            .indexOf(target);\n\n        NodeAppender.insertAtIndex(nodeWithStatements, statements, indexInScopeStatement + 1);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @param {number} index\n     */\n    public static insertAtIndex (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[],\n        index: number\n    ): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(nodeWithStatements, statements);\n\n        NodeAppender.setScopeStatements(nodeWithStatements, [\n            ...NodeAppender.getScopeStatements(nodeWithStatements).slice(0, index),\n            ...statements,\n            ...NodeAppender.getScopeStatements(nodeWithStatements).slice(index)\n        ]);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     */\n    public static prepend (nodeWithStatements: TNodeWithStatements, statements: TStatement[]): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(nodeWithStatements, statements);\n\n        NodeAppender.setScopeStatements(nodeWithStatements, [\n            ...statements,\n            ...NodeAppender.getScopeStatements(nodeWithStatements),\n        ]);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @returns {TStatement[]}\n     */\n    private static getScopeStatements (nodeWithStatements: TNodeWithStatements): TStatement[] {\n        if (NodeGuards.isSwitchCaseNode(nodeWithStatements)) {\n            return nodeWithStatements.consequent;\n        }\n\n        return nodeWithStatements.body;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @returns {TStatement[]}\n     */\n    private static parentizeScopeStatementsBeforeAppend (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[]\n    ): TStatement[] {\n        statements.forEach((statement: TStatement) => {\n            statement.parentNode = nodeWithStatements;\n        });\n\n        return statements;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     */\n    private static setScopeStatements (nodeWithStatements: TNodeWithStatements, statements: TStatement[]): void {\n        if (NodeGuards.isSwitchCaseNode(nodeWithStatements)) {\n            nodeWithStatements.consequent = <ESTree.Statement[]>statements;\n\n            return;\n        }\n\n        nodeWithStatements.body = statements;\n    }\n}\n","export enum ObfuscationEvent {\n    AfterObfuscation = 'afterObfuscation',\n    BeforeObfuscation = 'beforeObfuscation'\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../types/node/TNodeWithLexicalScope';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeLexicalScopeUtils {\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithLexicalScope}\n     */\n    public static getLexicalScope (node: ESTree.Node): TNodeWithLexicalScope | undefined {\n        return NodeLexicalScopeUtils.getLexicalScopesRecursive(node, 1)[0];\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithLexicalScope[]}\n     */\n    public static getLexicalScopes (node: ESTree.Node): TNodeWithLexicalScope[] {\n        return NodeLexicalScopeUtils.getLexicalScopesRecursive(node);\n    }\n\n    /***\n     * @param {Node} node\n     * @param {number} maxSize\n     * @param {TNodeWithLexicalScope[]} nodesWithLexicalScope\n     * @param {number} depth\n     * @returns {TNodeWithLexicalScope[]}\n     */\n    private static getLexicalScopesRecursive (\n        node: ESTree.Node,\n        maxSize: number = Infinity,\n        nodesWithLexicalScope: TNodeWithLexicalScope[] = [],\n        depth: number = 0\n    ): TNodeWithLexicalScope[] {\n        if (nodesWithLexicalScope.length >= maxSize) {\n            return nodesWithLexicalScope;\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (NodeGuards.isNodeWithLexicalScope(node)) {\n            nodesWithLexicalScope.push(node);\n        }\n\n        if (node !== parentNode) {\n            return NodeLexicalScopeUtils.getLexicalScopesRecursive(parentNode, maxSize, nodesWithLexicalScope, ++depth);\n        }\n\n        return nodesWithLexicalScope;\n    }\n}\n","module.exports = require(\"@babel/runtime/helpers/toConsumableArray\");","export enum NodeTransformer {\n    BlockStatementControlFlowTransformer = 'BlockStatementControlFlowTransformer',\n    ClassDeclarationTransformer = 'ClassDeclarationTransformer',\n    CommentsTransformer = 'CommentsTransformer',\n    CustomNodesTransformer = 'CustomNodesTransformer',\n    DeadCodeInjectionTransformer = 'DeadCodeInjectionTransformer',\n    EvalCallExpressionTransformer = 'EvalCallExpressionTransformer',\n    FunctionControlFlowTransformer = 'FunctionControlFlowTransformer',\n    CatchClauseTransformer = 'CatchClauseTransformer',\n    FunctionDeclarationTransformer = 'FunctionDeclarationTransformer',\n    FunctionTransformer = 'FunctionTransformer',\n    ImportDeclarationTransformer = 'ImportDeclarationTransformer',\n    LabeledStatementTransformer = 'LabeledStatementTransformer',\n    LiteralTransformer = 'LiteralTransformer',\n    MemberExpressionTransformer = 'MemberExpressionTransformer',\n    MetadataTransformer = 'MetadataTransformer',\n    MethodDefinitionTransformer = 'MethodDefinitionTransformer',\n    ObfuscatingGuardsTransformer = 'ObfuscatingGuardsTransformer',\n    ObjectExpressionKeysTransformer = 'ObjectExpressionKeysTransformer',\n    ObjectExpressionTransformer = 'ObjectExpressionTransformer',\n    ParentificationTransformer = 'ParentificationTransformer',\n    TemplateLiteralTransformer = 'TemplateLiteralTransformer',\n    VariableDeclarationTransformer = 'VariableDeclarationTransformer'\n}\n","module.exports = require(\"@babel/runtime/helpers/slicedToArray\");","export enum CustomNode {\n    ConsoleOutputDisableExpressionNode = 'ConsoleOutputDisableExpressionNode',\n    DebugProtectionFunctionCallNode = 'DebugProtectionFunctionCallNode',\n    DebugProtectionFunctionIntervalNode = 'DebugProtectionFunctionIntervalNode',\n    DebugProtectionFunctionNode = 'DebugProtectionFunctionNode',\n    DomainLockNode = 'DomainLockNode',\n    NodeCallsControllerFunctionNode = 'NodeCallsControllerFunctionNode',\n    SelfDefendingUnicodeNode = 'SelfDefendingUnicodeNode',\n    StringArrayCallsWrapper = 'StringArrayCallsWrapper',\n    StringArrayNode = 'StringArrayNode',\n    StringArrayRotateFunctionNode = 'StringArrayRotateFunctionNode'\n}\n","import 'reflect-metadata';\n\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport { TInputOptions } from './types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from './interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { IObfuscatedCode } from './interfaces/source-code/IObfuscatedCode';\n\nimport { InversifyContainerFacade } from './container/InversifyContainerFacade';\n\nclass JavaScriptObfuscatorFacade {\n    /**\n     * @type {string | undefined}\n     */\n    public static version: string = process.env.VERSION || 'unknown';\n\n    /**\n     * @param {string} sourceCode\n     * @param {TInputOptions} inputOptions\n     * @returns {IObfuscatedCode}\n     */\n    public static obfuscate (sourceCode: string, inputOptions: TInputOptions = {}): IObfuscatedCode {\n        const inversifyContainerFacade: IInversifyContainerFacade = new InversifyContainerFacade();\n\n        inversifyContainerFacade.load(sourceCode, '', inputOptions);\n\n        const javaScriptObfuscator: IJavaScriptObfuscator = inversifyContainerFacade\n            .get<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator);\n        const obfuscatedCode: IObfuscatedCode = javaScriptObfuscator.obfuscate(sourceCode);\n\n        inversifyContainerFacade.unload();\n\n        return obfuscatedCode;\n    }\n}\n\nexport { JavaScriptObfuscatorFacade as JavaScriptObfuscator };\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeGroup } from '../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IIdentifierNamesGenerator } from '../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { CustomNode } from '../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../enums/event-emitters/ObfuscationEvent';\n\n@injectable()\nexport abstract class AbstractCustomNodeGroup implements ICustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected abstract readonly appendEvent: ObfuscationEvent;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    protected abstract customNodes: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    protected readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public abstract appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void;\n\n    /**\n     * @returns {ObfuscationEvent}\n     */\n    public getAppendEvent (): ObfuscationEvent {\n        return this.appendEvent;\n    }\n\n    /**\n     * @returns {Map<CustomNode, ICustomNode>}\n     */\n    public getCustomNodes (): Map <CustomNode, ICustomNode> {\n        return this.customNodes;\n    }\n\n    public abstract initialize (): void;\n\n    /**\n     * @param {CustomNode} customNodeName\n     * @param {callback} callback\n     */\n    protected appendCustomNodeIfExist (customNodeName: CustomNode, callback: (customNode: ICustomNode) => void): void {\n        const customNode: ICustomNode | undefined = this.customNodes.get(customNodeName);\n\n        if (!customNode) {\n            return;\n        }\n\n        callback(customNode);\n    }\n\n    /**\n     * @param {number} stackTraceLength\n     * @returns {number}\n     */\n    protected getRandomStackTraceIndex (stackTraceLength: number): number {\n        return this.randomGenerator.getRandomInteger(0, Math.max(0, Math.round(stackTraceLength - 1)));\n    }\n}\n","export class Utils {\n    /**\n     * @type {string}\n     */\n    public static readonly hexadecimalPrefix: string = '0x';\n\n    /**\n     * @param {string} url\n     * @returns {string}\n     */\n    public static extractDomainFrom (url: string): string {\n        let domain: string;\n\n        if (url.indexOf('://') > -1 || url.indexOf('//') === 0) {\n            domain = url.split('/')[2];\n        } else {\n            domain = url.split('/')[0];\n        }\n\n        domain = domain.split(':')[0];\n\n        return domain;\n    }\n}\n","export enum IdentifierNamesGenerator {\n    HexadecimalIdentifierNamesGenerator = 'hexadecimal',\n    MangledIdentifierNamesGenerator = 'mangled'\n}\n","export enum SourceMapMode {\n    Inline = 'inline',\n    Separate = 'separate'\n}\n","export enum StringArrayEncoding {\n    Base64 = 'base64',\n    Rc4 = 'rc4'\n}\n","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\nexport const NO_ADDITIONAL_NODES_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0,\n    deadCodeInjection: false,\n    deadCodeInjectionThreshold: 0,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    exclude: [],\n    identifierNamesGenerator: IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n    identifiersPrefix: '',\n    inputFileName: '',\n    log: false,\n    renameGlobals: false,\n    reservedNames: [],\n    reservedStrings: [],\n    rotateStringArray: false,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    stringArray: false,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0,\n    target: ObfuscationTarget.Browser,\n    transformObjectKeys: false,\n    unicodeEscapeSequence: false\n});\n","module.exports = require(\"@babel/runtime/helpers/get\");","export class NumberUtils {\n    /**\n     * @param {number} dec\n     * @returns {string}\n     */\n    public static toHex (dec: number): string {\n        const radix: number = 16;\n\n        return dec.toString(radix);\n    }\n\n    /**\n     * @param {number} number\n     * @returns {boolean}\n     */\n    public static isCeil (number: number): boolean {\n        return number % 1 === 0;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../../../types/node/TNodeWithLexicalScope';\n\nimport { IObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IObfuscatingReplacer';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\n@injectable()\nexport abstract class AbstractObfuscatingReplacer implements IObfuscatingReplacer {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param {SimpleLiteral[\"value\"]} nodeValue\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @returns {Node}\n     */\n    public abstract replace (nodeValue: ESTree.SimpleLiteral['value'], lexicalScopeNode?: TNodeWithLexicalScope): ESTree.Node;\n}\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\nimport { ICalleeDataExtractor } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeDataExtractor';\n\n@injectable()\nexport abstract class AbstractCalleeDataExtractor implements ICalleeDataExtractor {\n    /**\n     * @param {Node[]} blockScopeBody\n     * @param {Node} callee\n     * @returns {ICalleeData}\n     */\n    public abstract extract (blockScopeBody: ESTree.Node[], callee: ESTree.Node): ICalleeData | null;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/control-flow-transformers/IControlFlowReplacer';\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport abstract class AbstractControlFlowReplacer implements IControlFlowReplacer {\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    protected readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {Map<string, Map<string, string[]>>}\n     */\n    protected readonly replacerDataByControlFlowStorageId: Map <string, Map<string, string[]>> = new Map();\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {Map<string, Map<string, string[]>>} identifierDataByControlFlowStorageId\n     * @param {string} controlFlowStorageId\n     * @returns {Map<string, string[]>}\n     */\n    protected static getStorageKeysByIdForCurrentStorage (\n        identifierDataByControlFlowStorageId: Map<string, Map<string, string[]>>,\n        controlFlowStorageId: string\n    ): Map<string, string[]> {\n        let storageKeysById: Map<string, string[]>;\n\n        if (identifierDataByControlFlowStorageId.has(controlFlowStorageId)) {\n            storageKeysById = <Map<string, string[]>>identifierDataByControlFlowStorageId.get(controlFlowStorageId);\n        } else {\n            storageKeysById = new Map <string, string[]>();\n        }\n\n        return storageKeysById;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {Node}\n     */\n    public abstract replace (node: ESTree.Node, parentNode: ESTree.Node, controlFlowStorage: TControlFlowStorage): ESTree.Node;\n\n    /**\n     * @param {ICustomNode} customNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @param {string} replacerId\n     * @param {number} usingExistingIdentifierChance\n     * @returns {string}\n     */\n    protected insertCustomNodeToControlFlowStorage (\n        customNode: ICustomNode,\n        controlFlowStorage: TControlFlowStorage,\n        replacerId: string,\n        usingExistingIdentifierChance: number\n    ): string {\n        const controlFlowStorageId: string = controlFlowStorage.getStorageId();\n        const storageKeysById: Map<string, string[]> = AbstractControlFlowReplacer\n            .getStorageKeysByIdForCurrentStorage(this.replacerDataByControlFlowStorageId, controlFlowStorageId);\n        const storageKeysForCurrentId: string[] | undefined = storageKeysById.get(replacerId);\n\n        if (\n            this.randomGenerator.getMathRandom() < usingExistingIdentifierChance &&\n            storageKeysForCurrentId &&\n            storageKeysForCurrentId.length\n        ) {\n            return this.randomGenerator.getRandomGenerator().pickone(storageKeysForCurrentId);\n        }\n\n        const generateStorageKey: (length: number) => string = (length: number) => {\n            const key: string = this.randomGenerator.getRandomString(length);\n\n            if (controlFlowStorage.getStorage().has(key)) {\n                return generateStorageKey(length);\n            }\n\n            return key;\n        };\n        const storageKey: string = generateStorageKey(5);\n\n        storageKeysById.set(replacerId, [storageKey]);\n        this.replacerDataByControlFlowStorageId.set(controlFlowStorageId, storageKeysById);\n        controlFlowStorage.set(storageKey, customNode);\n\n        return storageKey;\n    }\n}\n","module.exports = require(\"escodegen-wallaby\");","/**\n * @returns {string}\n */\nexport function GlobalVariableNoEvalTemplate (): string {\n    return `\n        var that = (typeof window !== 'undefined'\n           ? window\n           : (typeof process === 'object' &&\n              typeof require === 'function' &&\n              typeof global === 'object')\n             ? global\n             : this);\n    `;\n}\n","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\nexport const DEFAULT_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    config: '',\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0.75,\n    deadCodeInjection: false,\n    deadCodeInjectionThreshold: 0.4,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    exclude: [],\n    identifierNamesGenerator: IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n    identifiersPrefix: '',\n    inputFileName: '',\n    log: false,\n    renameGlobals: false,\n    reservedNames: [],\n    reservedStrings: [],\n    rotateStringArray: true,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    stringArray: true,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0.75,\n    target: ObfuscationTarget.Browser,\n    transformObjectKeys: false,\n    unicodeEscapeSequence: false\n});\n","export enum CalleeDataExtractor {\n    FunctionDeclarationCalleeDataExtractor = 'FunctionDeclarationCalleeDataExtractor',\n    FunctionExpressionCalleeDataExtractor = 'FunctionExpressionCalleeDataExtractor',\n    ObjectExpressionCalleeDataExtractor = 'ObjectExpressionCalleeDataExtractor',\n}\n","export enum ControlFlowReplacer {\n    BinaryExpressionControlFlowReplacer = 'BinaryExpressionControlFlowReplacer',\n    CallExpressionControlFlowReplacer = 'CallExpressionControlFlowReplacer',\n    LogicalExpressionControlFlowReplacer = 'LogicalExpressionControlFlowReplacer',\n    StringLiteralControlFlowReplacer = 'StringLiteralControlFlowReplacer'\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport abstract class ExpressionWithOperatorControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @param {Expression} leftExpression\n     * @param {Expression} rightExpression\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        leftExpression: ESTree.Expression,\n        rightExpression: ESTree.Expression\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, leftExpression, rightExpression);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","module.exports = require(\"@babel/runtime/helpers/typeof\");","module.exports = require(\"espree\");","export enum DeadCodeInjectionCustomNode {\n    BlockStatementDeadCodeInjectionNode = 'BlockStatementDeadCodeInjectionNode'\n}\n","export enum PropertiesExtractor {\n    AssignmentExpressionPropertiesExtractor = 'AssignmentExpressionPropertiesExtractor',\n    VariableDeclaratorPropertiesExtractor = 'VariableDeclaratorPropertiesExtractor'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IPropertiesExtractor } from '../../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport abstract class AbstractPropertiesExtractor implements IPropertiesExtractor {\n    /**\n     * @type {Map<ESTree.ObjectExpression, TNodeWithStatements>}\n     */\n    protected readonly cachedHostNodesWithStatementsMap: Map <ESTree.ObjectExpression, TNodeWithStatements> = new Map();\n\n    /**\n     * @type {Map<ESTree.ObjectExpression, ESTree.Statement>}\n     */\n    protected readonly cachedHostStatementsMap: Map <ESTree.ObjectExpression, ESTree.Statement> = new Map();\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {Property} propertyNode\n     * @returns {string | null}\n     */\n    protected static getPropertyNodeKeyName (propertyNode: ESTree.Property): string | null {\n        if (!propertyNode.key) {\n            return null;\n        }\n\n        const propertyKeyNode: ESTree.Expression = propertyNode.key;\n\n        if (NodeGuards.isLiteralNode(propertyKeyNode) && typeof propertyKeyNode.value === 'string') {\n            return propertyKeyNode.value;\n        }\n\n        if (NodeGuards.isIdentifierNode(propertyKeyNode)) {\n            return propertyKeyNode.name;\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {propertyValueNode is Pattern}\n     */\n    protected static isProhibitedHostParent (node: ESTree.Node): node is ESTree.Pattern {\n        return NodeGuards.isMemberExpressionNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {propertyValueNode is Pattern}\n     */\n    protected static isProhibitedPattern (node: ESTree.Node): node is ESTree.Pattern {\n        return !node\n            || NodeGuards.isObjectPatternNode(node)\n            || NodeGuards.isArrayPatternNode(node)\n            || NodeGuards.isAssignmentPatternNode(node)\n            || NodeGuards.isRestElementNode(node);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Node} hostNode\n     * @returns {Node}\n     */\n    public abstract extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.Node\n    ): ESTree.Node;\n\n    /**\n     * @param {Property[]} properties\n     * @param {Expression} memberExpressionHostNode\n     * @returns {[ExpressionStatement[] , number[]]}\n     */\n    protected extractPropertiesToExpressionStatements (\n        properties: ESTree.Property[],\n        memberExpressionHostNode: ESTree.Expression\n    ): [ESTree.ExpressionStatement[], number[]] {\n        const propertiesLength: number = properties.length;\n        const expressionStatements: ESTree.ExpressionStatement[] = [];\n        const removablePropertyIds: number[] = [];\n\n        for (let i: number = 0; i < propertiesLength; i++) {\n            const property: ESTree.Property = properties[i];\n            const propertyValue: ESTree.Expression | ESTree.Pattern = property.value;\n\n            // invalid property nodes\n            if (AbstractPropertiesExtractor.isProhibitedPattern(propertyValue)) {\n                continue;\n            }\n\n            /**\n             * Stage 1: extract property node key names\n             */\n            const propertyKeyName: string | null = AbstractPropertiesExtractor.getPropertyNodeKeyName(property);\n\n            if (!propertyKeyName) {\n                continue;\n            }\n\n            /**\n             * Stage 2: creating new expression statement node with member expression based on removed property\n             */\n            const shouldCreateLiteralNode: boolean = !property.computed\n                || (property.computed && !!property.key && NodeGuards.isLiteralNode(property.key));\n            const memberExpressionProperty: ESTree.Expression = shouldCreateLiteralNode\n                ? NodeFactory.literalNode(propertyKeyName)\n                : NodeFactory.identifierNode(propertyKeyName);\n            const memberExpressionNode: ESTree.MemberExpression = NodeFactory\n                .memberExpressionNode(memberExpressionHostNode, memberExpressionProperty, true);\n            const expressionStatementNode: ESTree.ExpressionStatement = NodeFactory.expressionStatementNode(\n                NodeFactory.assignmentExpressionNode('=', memberExpressionNode, propertyValue)\n            );\n\n            /**\n             * Stage 3: recursively processing nested object expressions\n             */\n            if (NodeGuards.isObjectExpressionNode(property.value)) {\n                this.transformObjectExpressionNode(property.value, memberExpressionNode);\n            }\n\n            /**\n             * Stage 4: filling arrays\n             */\n            expressionStatements.push(expressionStatementNode);\n            removablePropertyIds.push(i);\n        }\n\n        return [expressionStatements, removablePropertyIds];\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {number[]} removablePropertyIds\n     */\n    protected filterExtractedObjectExpressionProperties (\n        objectExpressionNode: ESTree.ObjectExpression,\n        removablePropertyIds: number[]\n    ): void {\n        objectExpressionNode.properties = objectExpressionNode.properties\n            .filter((property: ESTree.Property, index: number) => !removablePropertyIds.includes(index));\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Expression} memberExpressionHostNode\n     * @returns {Node}\n     */\n    protected transformObjectExpressionNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        memberExpressionHostNode: ESTree.Expression\n    ): ESTree.Node {\n        const properties: ESTree.Property[] = objectExpressionNode.properties;\n        const [expressionStatements, removablePropertyIds]: [ESTree.ExpressionStatement[], number[]] = this\n            .extractPropertiesToExpressionStatements(properties, memberExpressionHostNode);\n\n        const hostStatement: ESTree.Statement = this.getHostStatement(objectExpressionNode);\n        const hostNodeWithStatements: TNodeWithStatements = this.getHostNodeWithStatements(\n            objectExpressionNode,\n            hostStatement\n        );\n\n        this.filterExtractedObjectExpressionProperties(objectExpressionNode, removablePropertyIds);\n        NodeAppender.insertAfter(hostNodeWithStatements, expressionStatements, hostStatement);\n\n        return objectExpressionNode;\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Statement} hostStatement\n     * @returns {TNodeWithStatements}\n     */\n    protected getHostNodeWithStatements (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostStatement: ESTree.Statement\n    ): TNodeWithStatements {\n        if (this.cachedHostNodesWithStatementsMap.has(objectExpressionNode)) {\n            return <TNodeWithStatements>this.cachedHostNodesWithStatementsMap.get(objectExpressionNode);\n        }\n\n        const nodeWithStatements: TNodeWithStatements = NodeStatementUtils.getScopeOfNode(hostStatement);\n\n        this.cachedHostNodesWithStatementsMap.set(objectExpressionNode, nodeWithStatements);\n\n        return nodeWithStatements;\n    }\n\n    /**\n     * Returns host statement of object expression node\n     *\n     * @param {NodeGuards} objectExpressionNode\n     * @returns {Node}\n     */\n    protected getHostStatement (objectExpressionNode: ESTree.ObjectExpression): ESTree.Statement {\n        if (this.cachedHostStatementsMap.has(objectExpressionNode)) {\n            return <ESTree.Statement>this.cachedHostStatementsMap.get(objectExpressionNode);\n        }\n\n        const hostStatement: ESTree.Statement = NodeStatementUtils.getRootStatementOfNode(objectExpressionNode);\n\n        this.cachedHostStatementsMap.set(objectExpressionNode, hostStatement);\n\n        return hostStatement;\n    }\n}\n","export enum CustomNodeGroup {\n    ConsoleOutputCustomNodeGroup = 'ConsoleOutputCustomNodeGroup',\n    DebugProtectionCustomNodeGroup = 'DebugProtectionCustomNodeGroup',\n    DomainLockCustomNodeGroup = 'DomainLockCustomNodeGroup',\n    SelfDefendingCustomNodeGroup = 'SelfDefendingCustomNodeGroup',\n    StringArrayCustomNodeGroup = 'StringArrayCustomNodeGroup'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IIdentifierNamesGenerator } from '../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport abstract class AbstractIdentifierNamesGenerator implements IIdentifierNamesGenerator {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public abstract generate (nameLength?: number): string;\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public abstract generateWithPrefix (nameLength?: number): string;\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    public isValidIdentifierName (name: string): boolean {\n        return this.options.reservedNames.length\n            ? !this.options.reservedNames.some((reservedName: string) =>\n                new RegExp(reservedName, 'g').exec(name) !== null\n            )\n            : true;\n\n    }\n}\n","export enum LiteralObfuscatingReplacer {\n    BooleanLiteralObfuscatingReplacer = 'BooleanLiteralObfuscatingReplacer',\n    NumberLiteralObfuscatingReplacer = 'NumberLiteralObfuscatingReplacer',\n    StringLiteralObfuscatingReplacer = 'StringLiteralObfuscatingReplacer'\n}\n","export enum ObfuscatingGuard {\n    BlackListNodeGuard = 'BlackListNodeGuard',\n    ConditionalCommentNodeGuard = 'ConditionalCommentNodeGuard'\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IMapStorage } from '../interfaces/storages/IMapStorage';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport abstract class MapStorage <K, V> implements IMapStorage <K, V> {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId!: string;\n\n    /**\n     * @type {Map <K, V>}\n     */\n    @initializable()\n    protected storage!: Map <K, V>;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.storage = new Map <K, V>();\n        this.storageId = this.randomGenerator.getRandomString(6);\n    }\n\n    /**\n     * @param {K} key\n     * @returns {V}\n     */\n    public get (key: K): V {\n        const value: V | undefined = this.storage.get(key);\n\n        if (!value) {\n            throw new Error(`No value found in map storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param {V} value\n     * @returns {K | null}\n     */\n    public getKeyOf (value: V): K | null {\n        for (const [key, storageValue] of this.storage) {\n            if (value === storageValue) {\n                return key;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storage.size;\n    }\n\n    /**\n     * @returns {Map<K, V>}\n     */\n    public getStorage (): Map <K, V> {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param {K} key\n     * @returns {boolean}\n     */\n    public has (key: K): boolean {\n        return this.storage.has(key);\n    }\n\n    /**\n     * @param {this} storage\n     * @param {boolean} mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = new Map <K, V>([...this.storage, ...storage.getStorage()]);\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param {K} key\n     * @param {V} value\n     */\n    public set (key: K, value: V): void {\n        this.storage.set(key, value);\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport md5 from 'md5';\nimport { Chance } from 'chance';\n\nimport { IInitializable } from '../interfaces/IInitializable';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { ISourceCode } from '../interfaces/source-code/ISourceCode';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport class RandomGenerator implements IRandomGenerator, IInitializable {\n    /**\n     * @type {string}\n     */\n    public static readonly randomGeneratorPool: string = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {Chance.Chance}\n     */\n    @initializable()\n    private randomGenerator!: Chance.Chance;\n\n    /**\n     * @type {number}\n     */\n    @initializable()\n    private seed!: number;\n\n    /**\n     * @type {ISourceCode}\n     */\n    private readonly sourceCode: ISourceCode;\n\n    /**\n     * @param {ISourceCode} sourceCode\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ISourceCode) sourceCode: ISourceCode,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.sourceCode = sourceCode;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        const getRandomInteger: (min: number, max: number) => number = (min: number, max: number) => {\n            return Math.floor(Math.random() * (max - min + 1) + min);\n        };\n\n        /**\n         * We need to add numbers from md5 hash of source code to input seed to prevent same String Array name\n         * for different bundles with same seed\n         *\n         * @returns {number}\n         */\n        const getSeed: () => number = (): number => {\n            const md5Hash: string = md5(this.sourceCode.getSourceCode());\n\n            return this.seed + Number(md5Hash.replace(/\\D/g, ''));\n        };\n\n        this.seed = this.options.seed !== 0 ? this.options.seed : getRandomInteger(0, 999_999_999);\n        this.randomGenerator = new Chance(getSeed());\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getMathRandom (): number {\n        return this.getRandomInteger(0, 99999) / 100000;\n    }\n\n    /**\n     * @returns {Chance.Chance}\n     */\n    public getRandomGenerator (): Chance.Chance {\n        return this.randomGenerator;\n    }\n\n    /**\n     * @param {number} min\n     * @param {number} max\n     * @returns {number}\n     */\n    public getRandomInteger (min: number, max: number): number {\n        return this.getRandomGenerator().integer({\n            min: min,\n            max: max\n        });\n    }\n\n    /**\n     * @param {number} length\n     * @param {string} pool\n     * @returns {string}\n     */\n    public getRandomString (length: number, pool: string = RandomGenerator.randomGeneratorPool): string {\n        return this.getRandomGenerator().string({ length, pool });\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getSeed (): number {\n        return this.seed;\n    }\n}\n","module.exports = require(\"chalk\");","module.exports = require(\"reflect-metadata\");","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport chalk, { Chalk } from 'chalk';\n\nimport { ILogger } from '../interfaces/logger/ILogger';\nimport { IOptions } from '../interfaces/options/IOptions';\n\nimport { LoggingMessage } from '../enums/logger/LoggingMessage';\nimport { LoggingPrefix } from '../enums/logger/LoggingPrefix';\n\n@injectable()\nexport class Logger implements ILogger {\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorInfo: Chalk = chalk.cyan;\n\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorSuccess: Chalk = chalk.green;\n\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorWarn: Chalk = chalk.yellow;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param {Chalk} loggingLevelColor\n     * @param {LoggingPrefix} loggingPrefix\n     * @param {string} loggingMessage\n     * @param {string | number} value\n     */\n    public static log (\n        loggingLevelColor: Chalk,\n        loggingPrefix: LoggingPrefix,\n        loggingMessage: string,\n        value?: string | number,\n    ): void {\n        const processedMessage: string = loggingLevelColor(`\\n${loggingPrefix} ${loggingMessage}`);\n\n        console.log(processedMessage, value || '');\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public info (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorInfo, LoggingPrefix.Base, loggingMessage, value);\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public success (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorSuccess, LoggingPrefix.Base, loggingMessage, value);\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public warn (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorWarn, LoggingPrefix.Base, loggingMessage, value);\n    }\n}\n","export enum LoggingPrefix {\n    Base = '[javascript-obfuscator]',\n    CLI = '[javascript-obfuscator-cli]'\n}\n","module.exports = require(\"@babel/runtime/helpers/construct\");","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICalleeDataExtractor } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeDataExtractor';\nimport { IStackTraceAnalyzer } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\n\nimport { CalleeDataExtractor } from '../../../enums/analyzers/stack-trace-analyzer/CalleeDataExtractor';\nimport { FunctionDeclarationCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor';\nimport { FunctionExpressionCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor';\nimport { ObjectExpressionCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor';\nimport { StackTraceAnalyzer } from '../../../analyzers/stack-trace-analyzer/StackTraceAnalyzer';\n\nexport const analyzersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // stack trace analyzer\n    bind<IStackTraceAnalyzer>(ServiceIdentifiers.IStackTraceAnalyzer)\n        .to(StackTraceAnalyzer)\n        .inSingletonScope();\n\n    // callee data extractors\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionDeclarationCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.FunctionExpressionCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(ObjectExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.ObjectExpressionCalleeDataExtractor);\n\n    // callee data extractor factory\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.Factory__ICalleeDataExtractor)\n        .toFactory<ICalleeDataExtractor>(InversifyContainerFacade\n            .getCacheFactory<CalleeDataExtractor, ICalleeDataExtractor>(\n                ServiceIdentifiers.ICalleeDataExtractor\n            ));\n});\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport class FunctionDeclarationCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {Identifier} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData | null {\n        if (!NodeGuards.isIdentifierNode(callee)) {\n            return null;\n        }\n\n        const calleeBlockStatement: ESTree.BlockStatement | null = this.getCalleeBlockStatement(\n            NodeStatementUtils.getParentNodeWithStatements(blockScopeBody[0]),\n            callee.name\n        );\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name\n        };\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {string} name\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isFunctionDeclarationNode(node) && node.id.name === name) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport class FunctionExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {Identifier} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        if (NodeGuards.isIdentifierNode(callee)) {\n            calleeBlockStatement = this.getCalleeBlockStatement(\n                NodeStatementUtils.getParentNodeWithStatements(blockScopeBody[0]),\n                callee.name\n            );\n        }\n\n        if (NodeGuards.isFunctionExpressionNode(callee)) {\n            calleeBlockStatement = callee.body;\n        }\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name || null\n        };\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {string} name\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | void => {\n                if (\n                    NodeGuards.isFunctionExpressionNode(node) &&\n                    parentNode &&\n                    NodeGuards.isVariableDeclaratorNode(parentNode) &&\n                    NodeGuards.isIdentifierNode(parentNode.id) &&\n                    parentNode.id.name === name\n                ) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TObjectMembersCallsChain } from '../../../types/analyzers/stack-trace-analyzer/TObjectMembersCallsChain';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport class ObjectExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {Property} propertyNode\n     * @param {string | number} nextItemInCallsChain\n     * @returns {boolean}\n     */\n    private static isValidTargetPropertyNode (propertyNode: ESTree.Property, nextItemInCallsChain: string | number): boolean {\n        if (!propertyNode.key) {\n            return false;\n        }\n\n        const isTargetPropertyNodeWithIdentifierKey: boolean =\n            NodeGuards.isIdentifierNode(propertyNode.key) && propertyNode.key.name === nextItemInCallsChain;\n        const isTargetPropertyNodeWithLiteralKey: boolean =\n            NodeGuards.isLiteralNode(propertyNode.key) &&\n            Boolean(propertyNode.key.value) &&\n            propertyNode.key.value === nextItemInCallsChain;\n\n        return isTargetPropertyNodeWithIdentifierKey || isTargetPropertyNodeWithLiteralKey;\n    }\n\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {MemberExpression} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.MemberExpression): ICalleeData | null {\n        if (!NodeGuards.isMemberExpressionNode(callee)) {\n            return null;\n        }\n\n        const objectMembersCallsChain: TObjectMembersCallsChain = this.createObjectMembersCallsChain([], callee);\n\n        if (!objectMembersCallsChain.length) {\n            return null;\n        }\n\n        const functionExpressionName: string | number | null = objectMembersCallsChain[objectMembersCallsChain.length - 1];\n        const calleeBlockStatement: ESTree.BlockStatement | null = this.getCalleeBlockStatement(\n            NodeStatementUtils.getParentNodeWithStatements(blockScopeBody[0]),\n            objectMembersCallsChain\n        );\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: functionExpressionName\n        };\n    }\n\n    /**\n     * Creates array with MemberExpression calls chain.\n     *\n     * Example: object.foo.bar(); // ['object', 'foo', 'bar']\n     *\n     * @param {TObjectMembersCallsChain} currentChain\n     * @param {MemberExpression} memberExpression\n     * @returns {TObjectMembersCallsChain}\n     */\n    private createObjectMembersCallsChain (\n        currentChain: TObjectMembersCallsChain,\n        memberExpression: ESTree.MemberExpression\n    ): TObjectMembersCallsChain {\n        // first step: processing memberExpression `property` property\n        if (NodeGuards.isIdentifierNode(memberExpression.property) && memberExpression.computed === false) {\n            currentChain.unshift(memberExpression.property.name);\n        } else if (\n            NodeGuards.isLiteralNode(memberExpression.property) &&\n            (\n                typeof memberExpression.property.value === 'string' ||\n                typeof memberExpression.property.value === 'number'\n            )\n        ) {\n            currentChain.unshift(memberExpression.property.value);\n        } else {\n            return currentChain;\n        }\n\n        // second step: processing memberExpression `object` property\n        if (NodeGuards.isMemberExpressionNode(memberExpression.object)) {\n            return this.createObjectMembersCallsChain(currentChain, memberExpression.object);\n        } else if (NodeGuards.isIdentifierNode(memberExpression.object)) {\n            currentChain.unshift(memberExpression.object.name);\n        }\n\n        return currentChain;\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {TObjectMembersCallsChain} objectMembersCallsChain\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (\n        targetNode: ESTree.Node,\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement | null {\n        const objectName: string | number | undefined = objectMembersCallsChain.shift();\n\n        if (!objectName) {\n            return null;\n        }\n\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (\n                    NodeGuards.isVariableDeclaratorNode(node) &&\n                    NodeGuards.isIdentifierNode(node.id) &&\n                    node.init &&\n                    NodeGuards.isObjectExpressionNode(node.init) &&\n                    node.id.name === objectName\n                ) {\n                    calleeBlockStatement = this.findCalleeBlockStatement(node.init.properties, objectMembersCallsChain);\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n\n    /**\n     * @param {Property[]} objectExpressionProperties\n     * @param {TObjectMembersCallsChain} objectMembersCallsChain\n     * @returns {BlockStatement}\n     */\n    private findCalleeBlockStatement (\n        objectExpressionProperties: ESTree.Property[],\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement | null {\n        const nextItemInCallsChain: string | number | undefined = objectMembersCallsChain.shift();\n\n        if (!nextItemInCallsChain) {\n            return null;\n        }\n\n        for (const propertyNode of objectExpressionProperties) {\n            if (!ObjectExpressionCalleeDataExtractor.isValidTargetPropertyNode(propertyNode, nextItemInCallsChain)) {\n                continue;\n            }\n\n            if (NodeGuards.isObjectExpressionNode(propertyNode.value)) {\n                return this.findCalleeBlockStatement(propertyNode.value.properties, objectMembersCallsChain);\n            }\n\n            if (NodeGuards.isFunctionExpressionNode(propertyNode.value)) {\n                return propertyNode.value.body;\n            }\n        }\n\n        return null;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TCalleeDataExtractorFactory } from '../../types/container/stack-trace-analyzer/TCalleeDataExtractorFactory';\n\nimport { ICalleeData } from '../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\nimport { IStackTraceAnalyzer } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\nimport { IStackTraceData } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { CalleeDataExtractor } from '../../enums/analyzers/stack-trace-analyzer/CalleeDataExtractor';\n\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../node/NodeStatementUtils';\n\n/**\n * This class generates a data with a stack trace of functions calls\n *\n * For example:\n *\n * function Foo () {\n *     var baz = function () {\n *\n *     }\n *\n *     baz();\n * }\n *\n * foo();\n *\n * Will generate a structure like:\n *\n * [\n *      {\n *          callee: FOO_FUNCTION_NODE\n *          name: 'Foo',\n *          trace: [\n *              {\n *                  callee: BAZ_FUNCTION_NODE,\n *                  name: 'baz,\n *                  trace: []\n *              }\n *          ]\n *      }\n * ]\n */\n@injectable()\nexport class StackTraceAnalyzer implements IStackTraceAnalyzer {\n    /**\n     * @type {CalleeDataExtractor[]}\n     */\n    private static readonly calleeDataExtractorsList: CalleeDataExtractor[] = [\n        CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor,\n        CalleeDataExtractor.FunctionExpressionCalleeDataExtractor,\n        CalleeDataExtractor.ObjectExpressionCalleeDataExtractor\n    ];\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThresholdActivationLength: number = 25;\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThreshold: number = 0.002;\n\n    /**\n     * @type {TCalleeDataExtractorFactory}\n     */\n    private readonly calleeDataExtractorFactory: TCalleeDataExtractorFactory;\n\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICalleeDataExtractor) calleeDataExtractorFactory: TCalleeDataExtractorFactory\n    ) {\n        this.calleeDataExtractorFactory = calleeDataExtractorFactory;\n    }\n\n    /**\n     * @param {number} blockScopeBodyLength\n     * @returns {number}\n     */\n    public static getLimitIndex (blockScopeBodyLength: number): number {\n        const lastIndex: number = blockScopeBodyLength - 1;\n        const limitThresholdActivationIndex: number = StackTraceAnalyzer.limitThresholdActivationLength - 1;\n\n        let limitIndex: number = lastIndex;\n\n        if (lastIndex > limitThresholdActivationIndex) {\n            limitIndex = Math.round(\n                limitThresholdActivationIndex + (lastIndex * StackTraceAnalyzer.limitThreshold)\n            );\n\n            if (limitIndex > lastIndex) {\n                limitIndex = lastIndex;\n            }\n        }\n\n        return limitIndex;\n    }\n\n    /**\n     * @param {Program} astTree\n     * @returns {IStackTraceData[]}\n     */\n    public analyze (astTree: ESTree.Program): IStackTraceData[] {\n        return this.analyzeRecursive(astTree.body);\n    }\n\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @returns {IStackTraceData[]}\n     */\n    private analyzeRecursive (blockScopeBody: ESTree.Node[]): IStackTraceData[] {\n        const limitIndex: number = StackTraceAnalyzer.getLimitIndex(blockScopeBody.length);\n        const stackTraceData: IStackTraceData[] = [];\n        const blockScopeBodyLength: number = blockScopeBody.length;\n\n        for (let index: number = 0; index < blockScopeBodyLength; index++) {\n            if (index > limitIndex) {\n                break;\n            }\n\n            const blockScopeBodyNode: ESTree.Node = blockScopeBody[index];\n\n            estraverse.traverse(blockScopeBodyNode, {\n                enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                    if (!NodeGuards.isCallExpressionNode(node)) {\n                        return;\n                    }\n\n                    if (blockScopeBodyNode.parentNode !== NodeStatementUtils.getParentNodeWithStatements(node)) {\n                        return estraverse.VisitorOption.Skip;\n                    }\n\n                    this.analyzeCallExpressionNode(stackTraceData, blockScopeBody, node);\n                }\n            });\n        }\n\n        return stackTraceData;\n    }\n\n    /**\n     * @param {IStackTraceData[]} stackTraceData\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {CallExpression} callExpressionNode\n     */\n    private analyzeCallExpressionNode (\n        stackTraceData: IStackTraceData[],\n        blockScopeBody: ESTree.Node[],\n        callExpressionNode: ESTree.CallExpression\n    ): void {\n        StackTraceAnalyzer.calleeDataExtractorsList.forEach((calleeDataExtractorName: CalleeDataExtractor) => {\n            const calleeData: ICalleeData | null = this.calleeDataExtractorFactory(calleeDataExtractorName)\n                .extract(blockScopeBody, callExpressionNode.callee);\n\n            if (!calleeData) {\n                return;\n            }\n\n            stackTraceData.push({\n                ...calleeData,\n                stackTrace: this.analyzeRecursive(calleeData.callee.body)\n            });\n        });\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/control-flow-transformers/IControlFlowReplacer';\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { ControlFlowReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer';\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { BinaryExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer';\nimport { BlockStatementControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer';\nimport { CallExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer';\nimport { DeadCodeInjectionTransformer } from '../../../node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer';\nimport { FunctionControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/FunctionControlFlowTransformer';\nimport { LogicalExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer';\nimport { StringLiteralControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer';\n\nexport const controlFlowTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // control flow transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(BlockStatementControlFlowTransformer)\n        .whenTargetNamed(NodeTransformer.BlockStatementControlFlowTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(DeadCodeInjectionTransformer)\n        .whenTargetNamed(NodeTransformer.DeadCodeInjectionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionControlFlowTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionControlFlowTransformer);\n\n    // control flow replacers\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(BinaryExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.BinaryExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(CallExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.CallExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(LogicalExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.LogicalExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(StringLiteralControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.StringLiteralControlFlowReplacer);\n\n    // control flow replacer factory\n    bind<IControlFlowReplacer>(ServiceIdentifiers.Factory__IControlFlowReplacer)\n        .toFactory<IControlFlowReplacer>(InversifyContainerFacade\n            .getCacheFactory<ControlFlowReplacer, IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\n\n@injectable()\nexport class BinaryExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BinaryExpression} binaryExpressionNode\n     * @param {Node} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {Node}\n     */\n    public replace (\n        binaryExpressionNode: ESTree.BinaryExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        const replacerId: string = binaryExpressionNode.operator;\n        const binaryExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.BinaryExpressionFunctionNode\n        );\n\n        binaryExpressionFunctionCustomNode.initialize(replacerId);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            binaryExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            BinaryExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            binaryExpressionNode.left,\n            binaryExpressionNode.right\n        );\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ControlFlowCustomNode } from '../../enums/custom-nodes/ControlFlowCustomNode';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    private readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IArrayUtils} arrayUtils\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n        this.arrayUtils = arrayUtils;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private static isProhibitedStatementNode (node: ESTree.Node): boolean {\n        const isBreakOrContinueStatement: boolean = NodeGuards.isBreakStatementNode(node)\n            || NodeGuards.isContinueStatementNode(node);\n        const isVariableDeclarationWithLetOrConstKind: boolean = NodeGuards.isVariableDeclarationNode(node)\n            && (node.kind === 'const' || node.kind === 'let');\n        const isClassDeclaration: boolean = NodeGuards.isClassDeclarationNode(node);\n\n        return NodeGuards.isFunctionDeclarationNode(node)\n            || isBreakOrContinueStatement\n            || isVariableDeclarationWithLetOrConstKind\n            || isClassDeclaration;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static canTransformBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        let canTransform: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isWhileStatementNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (BlockStatementControlFlowTransformer.isProhibitedStatementNode(node)) {\n                    canTransform = false;\n                }\n            }\n        });\n\n        if (blockStatementNode.body.length <= 4) {\n            canTransform = false;\n        }\n\n        return canTransform;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.ControlFlowFlattening:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isBlockStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (blockStatementNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        if (\n            this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold ||\n            !BlockStatementControlFlowTransformer.canTransformBlockStatementNode(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const blockStatementBody: ESTree.Statement[] = blockStatementNode.body;\n        const originalKeys: number[] = this.arrayUtils.createWithRange(blockStatementBody.length);\n        const shuffledKeys: number[] = this.arrayUtils.shuffle(originalKeys);\n        const originalKeysIndexesInShuffledArray: number[] = originalKeys.map((key: number) => shuffledKeys.indexOf(key));\n        const blockStatementControlFlowFlatteningCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode\n        );\n\n        blockStatementControlFlowFlatteningCustomNode.initialize(\n            blockStatementBody,\n            shuffledKeys,\n            originalKeysIndexesInShuffledArray\n        );\n\n        const newBlockStatementNode: TStatement = blockStatementControlFlowFlatteningCustomNode.getNode()[0];\n\n        NodeUtils.parentizeNode(newBlockStatementNode, parentNode);\n\n        return newBlockStatementNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class CallExpressionControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {CallExpression} callExpressionNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        callExpressionNode: ESTree.CallExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        const callee: ESTree.Expression = <ESTree.Expression>callExpressionNode.callee;\n\n        if (!NodeGuards.isIdentifierNode(callee)) {\n            return callExpressionNode;\n        }\n\n        const replacerId: string = String(callExpressionNode.arguments.length);\n        const callExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.CallExpressionFunctionNode\n        );\n        const expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[] = callExpressionNode.arguments;\n\n        callExpressionFunctionCustomNode.initialize(expressionArguments);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            callExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            CallExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            callee,\n            expressionArguments\n        );\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        callee: ESTree.Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, callee, expressionArguments);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TDeadNodeInjectionCustomNodeFactory } from '../../types/container/custom-nodes/TDeadNodeInjectionCustomNodeFactory';\nimport { TNodeWithStatements } from '../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ITransformersRunner } from '../../interfaces/node-transformers/ITransformersRunner';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { DeadCodeInjectionCustomNode } from '../../enums/custom-nodes/DeadCodeInjectionCustomNode';\nimport { NodeTransformer } from '../../enums/node-transformers/NodeTransformer';\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../node/NodeStatementUtils';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DeadCodeInjectionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string}\n     */\n    private static readonly deadCodeInjectionRootAstHostNodeName: string = 'deadCodeInjectionRootAstHostNode';\n\n    /**\n     * @type {number}\n     */\n    private static readonly maxNestedBlockStatementsCount: number = 4;\n\n    /**\n     * @type {number}\n     */\n    private static readonly minCollectedBlockStatementsCount: number = 5;\n\n    /**\n     * @type {NodeTransformer[]}\n     */\n    private static readonly transformersToRenameBlockScopeIdentifiers: NodeTransformer[] = [\n        NodeTransformer.CatchClauseTransformer,\n        NodeTransformer.ClassDeclarationTransformer,\n        NodeTransformer.FunctionDeclarationTransformer,\n        NodeTransformer.FunctionTransformer,\n        NodeTransformer.LabeledStatementTransformer,\n        NodeTransformer.VariableDeclarationTransformer\n    ];\n\n    /**\n     * @type {Set <BlockStatement>}\n     */\n    private readonly deadCodeInjectionRootAstHostNodeSet: Set <ESTree.BlockStatement> = new Set();\n\n    /**\n     * @type {ESTree.BlockStatement[]}\n     */\n    private readonly collectedBlockStatements: ESTree.BlockStatement[] = [];\n\n    /**\n     * @type {number}\n     */\n    private collectedBlockStatementsTotalLength: number = 0;\n\n    /**\n     * @type {TDeadNodeInjectionCustomNodeFactory}\n     */\n    private readonly deadCodeInjectionCustomNodeFactory: TDeadNodeInjectionCustomNodeFactory;\n\n    /**\n     * @type {ITransformersRunner}\n     */\n    private readonly transformersRunner: ITransformersRunner;\n\n    /**\n     * @param {TDeadNodeInjectionCustomNodeFactory} deadCodeInjectionCustomNodeFactory\n     * @param {ITransformersRunner} transformersRunner\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)\n            deadCodeInjectionCustomNodeFactory: TDeadNodeInjectionCustomNodeFactory,\n        @inject(ServiceIdentifiers.ITransformersRunner) transformersRunner: ITransformersRunner,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.deadCodeInjectionCustomNodeFactory = deadCodeInjectionCustomNodeFactory;\n        this.transformersRunner = transformersRunner;\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {boolean}\n     */\n    private static isProhibitedNodeInsideCollectedBlockStatement (targetNode: ESTree.Node): boolean {\n        return NodeGuards.isBreakStatementNode(targetNode)\n            || NodeGuards.isContinueStatementNode(targetNode)\n            || NodeGuards.isAwaitExpressionNode(targetNode)\n            || NodeGuards.isSuperNode(targetNode);\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {boolean}\n     */\n    private static isScopeHoistingFunctionDeclaration (targetNode: ESTree.Node): boolean {\n        if (!NodeGuards.isFunctionDeclarationNode(targetNode)) {\n            return false;\n        }\n\n        const scopeNode: TNodeWithStatements = NodeStatementUtils.getScopeOfNode(targetNode);\n        const scopeBody: ESTree.Statement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? <ESTree.Statement[]>scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(targetNode);\n\n        if (indexInScope === 0) {\n            return false;\n        }\n\n        const slicedBody: ESTree.Statement[] = scopeBody.slice(0, indexInScope);\n        const hostBlockStatementNode: ESTree.BlockStatement = NodeFactory.blockStatementNode(slicedBody);\n        const functionDeclarationName: string = targetNode.id.name;\n\n        let isScopeHoistedFunctionDeclaration: boolean = false;\n\n        estraverse.traverse(hostBlockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isIdentifierNode(node) && node.name === functionDeclarationName) {\n                    isScopeHoistedFunctionDeclaration = true;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return isScopeHoistedFunctionDeclaration;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static isValidCollectedBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        if (!blockStatementNode.body.length) {\n            return false;\n        }\n\n        let nestedBlockStatementsCount: number = 0;\n        let isValidBlockStatementNode: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isBlockStatementNode(node)) {\n                    nestedBlockStatementsCount++;\n                }\n\n                if (\n                    nestedBlockStatementsCount > DeadCodeInjectionTransformer.maxNestedBlockStatementsCount\n                    || DeadCodeInjectionTransformer.isProhibitedNodeInsideCollectedBlockStatement(node)\n                    || DeadCodeInjectionTransformer.isScopeHoistingFunctionDeclaration(node)\n                ) {\n                    isValidBlockStatementNode = false;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return isValidBlockStatementNode;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static isValidWrappedBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        if (!blockStatementNode.body.length) {\n            return false;\n        }\n\n        let isValidBlockStatementNode: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (DeadCodeInjectionTransformer.isScopeHoistingFunctionDeclaration(node)) {\n                    isValidBlockStatementNode = false;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        if (!isValidBlockStatementNode) {\n            return false;\n        }\n\n        const parentNodeWithStatements: TNodeWithStatements = NodeStatementUtils\n            .getParentNodeWithStatements(blockStatementNode);\n\n        return parentNodeWithStatements.type !== NodeType.Program;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.DeadCodeInjection:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n\n                            return node;\n                        }\n                    },\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isBlockStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                if (!this.deadCodeInjectionRootAstHostNodeSet.size) {\n                    return null;\n                }\n\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && this.isDeadCodeInjectionRootAstHostNode(node)) {\n                            return this.restoreNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {NodeGuards} programNode\n     * @param {NodeGuards} parentNode\n     */\n    public analyzeNode (programNode: ESTree.Node, parentNode: ESTree.Node): void {\n        estraverse.traverse(programNode, {\n            enter: (node: ESTree.Node): void => {\n                if (!NodeGuards.isBlockStatementNode(node)) {\n                    return;\n                }\n\n                const clonedBlockStatementNode: ESTree.BlockStatement = NodeUtils.clone(node);\n\n                if (!DeadCodeInjectionTransformer.isValidCollectedBlockStatementNode(clonedBlockStatementNode)) {\n                    return;\n                }\n\n                /**\n                 * We should transform identifiers in the dead code block statement to avoid conflicts with original code\n                 */\n                const transformedBlockStatementNode: ESTree.BlockStatement =\n                    this.makeClonedBlockStatementNodeUnique(clonedBlockStatementNode);\n\n                this.collectedBlockStatements.push(transformedBlockStatementNode);\n            }\n        });\n\n        this.collectedBlockStatementsTotalLength = this.collectedBlockStatements.length;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards | VisitorOption}\n     */\n    public transformNode (\n        blockStatementNode: ESTree.BlockStatement,\n        parentNode: ESTree.Node\n    ): ESTree.Node | estraverse.VisitorOption {\n        const canBreakTraverse: boolean = !this.collectedBlockStatements.length\n            || this.collectedBlockStatementsTotalLength < DeadCodeInjectionTransformer.minCollectedBlockStatementsCount;\n\n        if (canBreakTraverse) {\n            return estraverse.VisitorOption.Break;\n        }\n\n        if (\n            this.randomGenerator.getMathRandom() > this.options.deadCodeInjectionThreshold\n            || !DeadCodeInjectionTransformer.isValidWrappedBlockStatementNode(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const minInteger: number = 0;\n        const maxInteger: number = this.collectedBlockStatements.length - 1;\n        const randomIndex: number = this.randomGenerator.getRandomInteger(minInteger, maxInteger);\n        const randomBlockStatementNode: ESTree.BlockStatement = this.collectedBlockStatements.splice(randomIndex, 1)[0];\n        const isDuplicateBlockStatementNodes: boolean = randomBlockStatementNode === blockStatementNode;\n\n        if (isDuplicateBlockStatementNodes) {\n            return blockStatementNode;\n        }\n\n        return this.replaceBlockStatementNode(blockStatementNode, randomBlockStatementNode, parentNode);\n    }\n\n    /**\n     * @param {FunctionExpression} deadCodeInjectionRootAstHostNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public restoreNode (deadCodeInjectionRootAstHostNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        const hostNodeFirstStatement: ESTree.Statement = deadCodeInjectionRootAstHostNode.body[0];\n\n        if (!NodeGuards.isFunctionDeclarationNode(hostNodeFirstStatement)) {\n            throw new Error('Wrong dead code injection root AST host node. Host node should contain `FunctionDeclaration` node');\n        }\n\n        return hostNodeFirstStatement.body;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private isDeadCodeInjectionRootAstHostNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return NodeGuards.isBlockStatementNode(node) && this.deadCodeInjectionRootAstHostNodeSet.has(node);\n    }\n\n    /**\n     * Make all identifiers in cloned block statement unique\n     *\n     * @param {BlockStatement} clonedBlockStatementNode\n     * @returns {BlockStatement}\n     */\n    private makeClonedBlockStatementNodeUnique (clonedBlockStatementNode: ESTree.BlockStatement): ESTree.BlockStatement {\n        // should wrap cloned block statement node into function node for correct scope encapsulation\n        const hostNode: ESTree.FunctionExpression = NodeFactory\n            .functionExpressionNode([], clonedBlockStatementNode);\n\n        NodeUtils.parentizeNode(hostNode, hostNode);\n        NodeUtils.parentizeNode(clonedBlockStatementNode, hostNode);\n\n        return this.transformersRunner.transform(\n            hostNode,\n            DeadCodeInjectionTransformer.transformersToRenameBlockScopeIdentifiers,\n            TransformationStage.Obfuscating\n        ).body;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {BlockStatement} randomBlockStatementNode\n     * @param {Node} parentNode\n     * @returns {BlockStatement}\n     */\n    private replaceBlockStatementNode (\n        blockStatementNode: ESTree.BlockStatement,\n        randomBlockStatementNode: ESTree.BlockStatement,\n        parentNode: ESTree.Node\n    ): ESTree.BlockStatement {\n        /**\n         * Should wrap original random block statement node into the parent block statement node (ast root host node)\n         * with function declaration node. This function declaration node will create block scope for all identifiers\n         * inside random block statement node and this identifiers won't affect identifiers of the rest AST tree.\n         */\n        const deadCodeInjectionRootAstHostNode: ESTree.BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.functionDeclarationNode(\n                DeadCodeInjectionTransformer.deadCodeInjectionRootAstHostNodeName,\n                [],\n                randomBlockStatementNode\n            )\n        ]);\n\n        /**\n         * Should store that host node and then extract random block statement node on the `finalizing` stage\n         */\n        this.deadCodeInjectionRootAstHostNodeSet.add(deadCodeInjectionRootAstHostNode);\n\n        const blockStatementDeadCodeInjectionCustomNode: ICustomNode = this.deadCodeInjectionCustomNodeFactory(\n            DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode\n        );\n\n        blockStatementDeadCodeInjectionCustomNode.initialize(blockStatementNode, deadCodeInjectionRootAstHostNode);\n\n        const newBlockStatementNode: ESTree.BlockStatement = <ESTree.BlockStatement>blockStatementDeadCodeInjectionCustomNode.getNode()[0];\n\n        NodeUtils.parentizeNode(newBlockStatementNode, parentNode);\n\n        return newBlockStatementNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowReplacerFactory } from '../../types/container/node-transformers/TControlFlowReplacerFactory';\nimport { TControlFlowStorage } from '../../types/storages/TControlFlowStorage';\nimport { TControlFlowStorageFactory } from '../../types/container/node-transformers/TControlFlowStorageFactory';\nimport { TNodeWithStatements } from '../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ControlFlowCustomNode } from '../../enums/custom-nodes/ControlFlowCustomNode';\nimport { ControlFlowReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer';\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeStatementUtils } from '../../node/NodeStatementUtils';\n\n@injectable()\nexport class FunctionControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map <string, ControlFlowReplacer>}\n     */\n    private static readonly controlFlowReplacersMap: Map <string, ControlFlowReplacer> = new Map([\n        [NodeType.BinaryExpression, ControlFlowReplacer.BinaryExpressionControlFlowReplacer],\n        [NodeType.CallExpression, ControlFlowReplacer.CallExpressionControlFlowReplacer],\n        [NodeType.LogicalExpression, ControlFlowReplacer.LogicalExpressionControlFlowReplacer],\n        [NodeType.Literal, ControlFlowReplacer.StringLiteralControlFlowReplacer]\n    ]);\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMinDepth: number = 0;\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMaxDepth: number = 2;\n\n    /**\n     * @type {Map<ESTree.Node, TControlFlowStorage>}\n     */\n    private readonly controlFlowData: Map <ESTree.Node, TControlFlowStorage> = new Map();\n\n    /**\n     * @type {Set<ESTree.Function>}\n     */\n    private readonly visitedFunctionNodes: Set<ESTree.Function> = new Set();\n\n    /**\n     * @type {Set<TNodeWithStatements>}\n     */\n    private readonly hostNodesWithControlFlowNode: Set<TNodeWithStatements> = new Set();\n\n    /**\n     * @type {TControlFlowReplacerFactory}\n     */\n    private readonly controlFlowReplacerFactory: TControlFlowReplacerFactory;\n\n    /**\n     * @type {TControlFlowStorageFactory}\n     */\n    private readonly controlFlowStorageFactory: TControlFlowStorageFactory;\n\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    private readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @param {TControlFlowStorageFactory} controlFlowStorageFactory\n     * @param {TControlFlowReplacerFactory} controlFlowReplacerFactory\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__TControlFlowStorage)\n            controlFlowStorageFactory: TControlFlowStorageFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowReplacer)\n            controlFlowReplacerFactory: TControlFlowReplacerFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.controlFlowStorageFactory = controlFlowStorageFactory;\n        this.controlFlowReplacerFactory = controlFlowReplacerFactory;\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.ControlFlowFlattening:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode && (\n                                NodeGuards.isFunctionDeclarationNode(node) ||\n                                NodeGuards.isFunctionExpressionNode(node) ||\n                                NodeGuards.isArrowFunctionExpressionNode(node)\n                            )\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {NodeGuards} parentNode\n     * @returns {Function}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Function {\n        this.visitedFunctionNodes.add(functionNode);\n\n        if (!NodeGuards.isBlockStatementNode(functionNode.body)) {\n            return functionNode;\n        }\n\n        const hostNode: TNodeWithStatements = this.getHostNode(functionNode.body);\n        const controlFlowStorage: TControlFlowStorage = this.getControlFlowStorage(hostNode);\n\n        this.controlFlowData.set(hostNode, controlFlowStorage);\n        this.transformFunctionBody(functionNode.body, controlFlowStorage);\n\n        if (!controlFlowStorage.getLength()) {\n            return functionNode;\n        }\n\n        const controlFlowStorageCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.ControlFlowStorageNode\n        );\n\n        controlFlowStorageCustomNode.initialize(controlFlowStorage);\n        NodeAppender.prepend(hostNode, controlFlowStorageCustomNode.getNode());\n        this.hostNodesWithControlFlowNode.add(hostNode);\n\n        return functionNode;\n    }\n\n    /**\n     * @param {TNodeWithStatements} hostNode\n     * @returns {TControlFlowStorage}\n     */\n    private getControlFlowStorage (hostNode: TNodeWithStatements): TControlFlowStorage {\n        const controlFlowStorage: TControlFlowStorage = this.controlFlowStorageFactory();\n\n        if (this.controlFlowData.has(hostNode)) {\n            if (this.hostNodesWithControlFlowNode.has(hostNode)) {\n                if (NodeGuards.isSwitchCaseNode(hostNode)) {\n                    hostNode.consequent.shift();\n                } else {\n                    hostNode.body.shift();\n                }\n            }\n\n            const hostControlFlowStorage: TControlFlowStorage = <TControlFlowStorage>this.controlFlowData.get(hostNode);\n\n            controlFlowStorage.mergeWith(hostControlFlowStorage, true);\n        }\n\n        return controlFlowStorage;\n    }\n\n    /**\n     * @param {BlockStatement} functionNodeBody\n     * @returns {TNodeWithStatements}\n     */\n    private getHostNode (functionNodeBody: ESTree.BlockStatement): TNodeWithStatements {\n        const blockScopesOfNode: TNodeWithStatements[] = NodeStatementUtils.getParentNodesWithStatements(functionNodeBody);\n\n        if (blockScopesOfNode.length === 1) {\n            return functionNodeBody;\n        } else {\n            blockScopesOfNode.pop();\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMinDepth) {\n            blockScopesOfNode.splice(0, FunctionControlFlowTransformer.hostNodeSearchMinDepth);\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMaxDepth) {\n            blockScopesOfNode.length = FunctionControlFlowTransformer.hostNodeSearchMaxDepth;\n        }\n\n        return this.randomGenerator.getRandomGenerator().pickone(blockScopesOfNode);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {boolean}\n     */\n    private isVisitedFunctionNode (node: ESTree.Node): boolean {\n        return (\n            NodeGuards.isFunctionDeclarationNode(node) ||\n            NodeGuards.isFunctionExpressionNode(node) ||\n            NodeGuards.isArrowFunctionExpressionNode(node)\n        ) && this.visitedFunctionNodes.has(node);\n    }\n\n    /**\n     * @param {BlockStatement} functionNodeBody\n     * @param {TControlFlowStorage} controlFlowStorage\n     */\n    private transformFunctionBody (functionNodeBody: ESTree.BlockStatement, controlFlowStorage: TControlFlowStorage): void {\n        estraverse.replace(functionNodeBody, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | ESTree.Node => {\n                if (NodeMetadata.isIgnoredNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (this.isVisitedFunctionNode(node) || !parentNode) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (!FunctionControlFlowTransformer.controlFlowReplacersMap.has(node.type)) {\n                    return node;\n                }\n\n                if (this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold) {\n                    return node;\n                }\n\n                const controlFlowReplacerName: ControlFlowReplacer = <ControlFlowReplacer>FunctionControlFlowTransformer\n                    .controlFlowReplacersMap.get(node.type);\n\n                if (controlFlowReplacerName === undefined) {\n                    return node;\n                }\n\n                return {\n                    ...this.controlFlowReplacerFactory(controlFlowReplacerName).replace(node, parentNode, controlFlowStorage),\n                    parentNode\n                };\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {LogicalExpression} logicalExpressionNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        logicalExpressionNode: ESTree.LogicalExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        if (this.checkForProhibitedExpressions(logicalExpressionNode.left, logicalExpressionNode.right)) {\n            return logicalExpressionNode;\n        }\n\n        const replacerId: string = logicalExpressionNode.operator;\n        const logicalExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.LogicalExpressionFunctionNode\n        );\n\n        logicalExpressionFunctionCustomNode.initialize(replacerId);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            logicalExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            LogicalExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            logicalExpressionNode.left,\n            logicalExpressionNode.right\n        );\n    }\n\n    /**\n     * @param {Expression} leftExpression\n     * @param {Expression} rightExpression\n     * @returns {boolean}\n     */\n    private checkForProhibitedExpressions (leftExpression: ESTree.Expression, rightExpression: ESTree.Expression): boolean {\n        return [leftExpression, rightExpression].some((expressionNode: ESTree.Node | ESTree.Expression): boolean => {\n            let nodeForCheck: ESTree.Node | ESTree.Expression;\n\n            if (!NodeGuards.isUnaryExpressionNode(expressionNode)) {\n                nodeForCheck = expressionNode;\n            } else {\n                nodeForCheck = NodeUtils.getUnaryExpressionArgumentNode(expressionNode);\n            }\n\n            return !NodeGuards.isLiteralNode(nodeForCheck) &&\n                !NodeGuards.isIdentifierNode(nodeForCheck) &&\n                !NodeGuards.isObjectExpressionNode(nodeForCheck) &&\n                !NodeGuards.isExpressionStatementNode(nodeForCheck);\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class StringLiteralControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 1;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        literalNode: ESTree.Literal,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        if (NodeGuards.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return literalNode;\n        }\n\n        if (typeof literalNode.value !== 'string' || literalNode.value.length < 3) {\n            return literalNode;\n        }\n\n        const replacerId: string = String(literalNode.value);\n        const literalFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.StringLiteralNode\n        );\n\n        literalFunctionCustomNode.initialize(literalNode.value);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            literalFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            StringLiteralControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(controlFlowStorage.getStorageId(), storageKey);\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IPropertiesExtractor } from '../../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\nimport { PropertiesExtractor } from '../../../enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor';\n\nimport { AssignmentExpressionPropertiesExtractor } from '../../../node-transformers/converting-transformers/properties-extractors/AssignmentExpressionPropertiesExtractor';\nimport { MemberExpressionTransformer } from '../../../node-transformers/converting-transformers/MemberExpressionTransformer';\nimport { MethodDefinitionTransformer } from '../../../node-transformers/converting-transformers/MethodDefinitionTransformer';\nimport { ObjectExpressionKeysTransformer } from '../../../node-transformers/converting-transformers/ObjectExpressionKeysTransformer';\nimport { ObjectExpressionTransformer } from '../../../node-transformers/converting-transformers/ObjectExpressionTransformer';\nimport { TemplateLiteralTransformer } from '../../../node-transformers/converting-transformers/TemplateLiteralTransformer';\nimport { VariableDeclaratorPropertiesExtractor } from '../../../node-transformers/converting-transformers/properties-extractors/VariableDeclaratorPropertiesExtractor';\n\nexport const convertingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // converting transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MemberExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.MemberExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MethodDefinitionTransformer)\n        .whenTargetNamed(NodeTransformer.MethodDefinitionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionKeysTransformer)\n        .whenTargetNamed(NodeTransformer.ObjectExpressionKeysTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.ObjectExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(TemplateLiteralTransformer)\n        .whenTargetNamed(NodeTransformer.TemplateLiteralTransformer);\n\n    // properties extractors\n    bind<IPropertiesExtractor>(ServiceIdentifiers.IPropertiesExtractor)\n        .to(AssignmentExpressionPropertiesExtractor)\n        .whenTargetNamed(PropertiesExtractor.AssignmentExpressionPropertiesExtractor);\n\n    bind<IPropertiesExtractor>(ServiceIdentifiers.IPropertiesExtractor)\n        .to(VariableDeclaratorPropertiesExtractor)\n        .whenTargetNamed(PropertiesExtractor.VariableDeclaratorPropertiesExtractor);\n\n    // properties extractor factory\n    bind<IPropertiesExtractor>(ServiceIdentifiers.Factory__IPropertiesExtractor)\n        .toFactory<IPropertiesExtractor>(InversifyContainerFacade\n            .getCacheFactory<PropertiesExtractor, IPropertiesExtractor>(\n                ServiceIdentifiers.IPropertiesExtractor\n            ));\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractPropertiesExtractor } from './AbstractPropertiesExtractor';\n\n@injectable()\nexport class AssignmentExpressionPropertiesExtractor extends AbstractPropertiesExtractor {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {AssignmentExpression} hostNode\n     * @returns {Node}\n     */\n    public extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.AssignmentExpression\n    ): ESTree.Node {\n        const hostParentNode: ESTree.Node | undefined = hostNode.parentNode;\n        const leftNode: ESTree.MemberExpression | ESTree.Pattern = hostNode.left;\n\n        // left node shouldn't be as Pattern node\n        if (AbstractPropertiesExtractor.isProhibitedPattern(leftNode)) {\n            return objectExpressionNode;\n        }\n\n        // left node shouldn't be as Pattern node\n        if (hostParentNode && AbstractPropertiesExtractor.isProhibitedHostParent(hostParentNode)) {\n            return objectExpressionNode;\n        }\n\n        return this.transformObjectExpressionNode(\n            objectExpressionNode,\n            leftNode\n        );\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class MemberExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isMemberExpressionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     *\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param {MemberExpression} memberExpressionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (memberExpressionNode: ESTree.MemberExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (NodeGuards.isIdentifierNode(memberExpressionNode.property)) {\n            if (memberExpressionNode.computed) {\n                return memberExpressionNode;\n            }\n\n            memberExpressionNode.computed = true;\n            memberExpressionNode.property = NodeFactory.literalNode(memberExpressionNode.property.name);\n        }\n\n        return memberExpressionNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * replaces:\n *     foo () { //... };\n *\n * on:\n *     ['foo'] { //... };\n *\n * Literal node will be obfuscated by LiteralTransformer\n */\n@injectable()\nexport class MethodDefinitionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly ignoredNames: string[] = ['constructor'];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isMethodDefinitionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param {MethodDefinition} methodDefinitionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (methodDefinitionNode: ESTree.MethodDefinition, parentNode: ESTree.Node): ESTree.Node {\n        if (\n            NodeGuards.isIdentifierNode(methodDefinitionNode.key) &&\n            !MethodDefinitionTransformer.ignoredNames.includes(methodDefinitionNode.key.name) &&\n            methodDefinitionNode.computed === false\n        ) {\n            methodDefinitionNode.computed = true;\n            methodDefinitionNode.key = NodeFactory.literalNode(methodDefinitionNode.key.name);\n        }\n\n        return methodDefinitionNode;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TPropertiesExtractorFactory } from '../../types/container/node-transformers/TPropertiesExtractorFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IPropertiesExtractor } from '../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { NodeType } from '../../enums/node/NodeType';\nimport { PropertiesExtractor } from '../../enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class ObjectExpressionKeysTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map<string, PropertiesExtractor>}\n     */\n    private static readonly propertiesExtractorsMap: Map <string, PropertiesExtractor> = new Map([\n        [NodeType.AssignmentExpression, PropertiesExtractor.AssignmentExpressionPropertiesExtractor],\n        [NodeType.VariableDeclarator, PropertiesExtractor.VariableDeclaratorPropertiesExtractor]\n    ]);\n\n    /**\n     * @type {TPropertiesExtractorFactory}\n     */\n    private readonly propertiesExtractorFactory: TPropertiesExtractorFactory;\n\n    /**\n     * @param {TPropertiesExtractorFactory} propertiesExtractorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IPropertiesExtractor)\n            propertiesExtractorFactory: TPropertiesExtractorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.propertiesExtractorFactory = propertiesExtractorFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        if (transformationStage !== TransformationStage.Converting) {\n            return null;\n        }\n\n        return {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                if (\n                    this.options.transformObjectKeys\n                    && parentNode\n                    && NodeGuards.isObjectExpressionNode(node)\n                ) {\n                    return this.transformNode(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * replaces:\n     *     var object = {\n     *          foo: 1,\n     *          bar: 2\n     *     };\n     *\n     * on:\n     *     var object = {};\n     *     object['foo'] = 1;\n     *     object['bar'] = 2;\n     *\n     * @param {MemberExpression} objectExpressionNode\n     * @param {Node} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (!objectExpressionNode.properties.length) {\n            return objectExpressionNode;\n        }\n\n        const propertiesExtractorName: PropertiesExtractor | undefined = ObjectExpressionKeysTransformer\n            .propertiesExtractorsMap\n            .get(parentNode.type);\n\n        if (!propertiesExtractorName) {\n            return objectExpressionNode;\n        }\n\n        const propertiesExtractor: IPropertiesExtractor = this.propertiesExtractorFactory(propertiesExtractorName);\n\n        return propertiesExtractor.extract(objectExpressionNode, parentNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * replaces:\n *     var object = { PSEUDO: 1 };\n *\n * on:\n *     var object = { 'PSEUDO': 1 };\n */\n@injectable()\nexport class ObjectExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isObjectExpressionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        objectExpressionNode.properties\n            .forEach((property: ESTree.Property) => {\n                if (!property.key) {\n                    return;\n                }\n\n                if (property.computed) {\n                    this.transformComputedProperty(property);\n                } else {\n                    this.transformBaseProperty(property);\n                }\n            });\n\n        return objectExpressionNode;\n    }\n\n    /**\n     * @param {Property} property\n     */\n    private transformComputedProperty (property: ESTree.Property): void {\n        if (!NodeGuards.isLiteralNode(property.key) || !(typeof property.key.value === 'string')) {\n            return;\n        }\n\n        property.key = NodeFactory.literalNode(this.getPropertyKeyValue(property.key.value));\n    }\n\n    /**\n     * @param {Property} property\n     */\n    private transformBaseProperty (property: ESTree.Property): void {\n        if (property.shorthand) {\n            property.shorthand = false;\n        }\n\n        if (!NodeGuards.isIdentifierNode(property.key)) {\n            return;\n        }\n\n        property.key = NodeFactory.literalNode(this.getPropertyKeyValue(property.key.name));\n    }\n\n    /**\n     * @param {string} inputValue\n     * @returns {string}\n     */\n    private getPropertyKeyValue (inputValue: string): string {\n        return this.options.unicodeEscapeSequence\n            ? this.escapeSequenceEncoder.encode(inputValue, true)\n            : inputValue;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * Transform ES2015 template literals to ES5\n * Thanks to Babel for algorithm\n */\n@injectable()\nexport class TemplateLiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {boolean}\n     */\n    private static isLiteralNodeWithStringValue (node: ESTree.Node): boolean {\n        return node && NodeGuards.isLiteralNode(node) && typeof node.value === 'string';\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node | null} parentNode\n     * @returns {boolean}\n     */\n    private static isValidTemplateLiteralNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.TemplateLiteral {\n        return NodeGuards.isTemplateLiteralNode(node) && !NodeGuards.isTaggedTemplateExpressionNode(parentNode);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && TemplateLiteralTransformer.isValidTemplateLiteralNode(node, parentNode)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {TemplateLiteral} templateLiteralNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (templateLiteralNode: ESTree.TemplateLiteral, parentNode: ESTree.Node): ESTree.Node {\n        const templateLiteralExpressions: ESTree.Expression[] = templateLiteralNode.expressions;\n\n        let nodes: ESTree.Expression[] = [];\n\n        templateLiteralNode.quasis.forEach((templateElement: ESTree.TemplateElement) => {\n            nodes.push(NodeFactory.literalNode(templateElement.value.cooked));\n\n            const expression: ESTree.Expression | undefined = templateLiteralExpressions.shift();\n\n            if (!expression) {\n                return;\n            }\n\n            nodes.push(expression);\n        });\n\n        nodes = nodes.filter((node: ESTree.Literal | ESTree.Expression) => {\n            return !(NodeGuards.isLiteralNode(node) && node.value === '');\n        });\n\n        // since `+` is left-to-right associative\n        // ensure the first node is a string if first/second isn't\n        if (\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[0]) &&\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[1])\n        ) {\n            nodes.unshift(NodeFactory.literalNode(''));\n        }\n\n        let transformedNode: ESTree.Node;\n\n        if (nodes.length > 1) {\n            let root: ESTree.BinaryExpression = NodeFactory.binaryExpressionNode(\n                '+',\n                <ESTree.Literal>nodes.shift(),\n                <ESTree.Expression>nodes.shift()\n            );\n\n            nodes.forEach((node: ESTree.Literal | ESTree.Expression) => {\n                root = NodeFactory.binaryExpressionNode('+', root, node);\n            });\n\n            transformedNode = root;\n        } else {\n            transformedNode = nodes[0];\n        }\n\n        NodeUtils.parentizeAst(transformedNode);\n\n        return transformedNode;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractPropertiesExtractor } from './AbstractPropertiesExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class VariableDeclaratorPropertiesExtractor extends AbstractPropertiesExtractor {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {VariableDeclarator} hostNode\n     * @returns {Node}\n     */\n    public extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.VariableDeclarator\n    ): ESTree.Node {\n        if (\n            !NodeGuards.isIdentifierNode(hostNode.id)\n            || this.isProhibitedObjectExpressionNode(objectExpressionNode, hostNode.id)\n        ) {\n            return objectExpressionNode;\n        }\n\n        return this.transformObjectExpressionNode(objectExpressionNode, hostNode.id);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @returns {VariableDeclarator}\n     */\n    private getHostVariableDeclaratorNode (objectExpressionNode: ESTree.ObjectExpression): ESTree.VariableDeclarator | never {\n        const { parentNode } = objectExpressionNode;\n\n        if (!parentNode || !NodeGuards.isVariableDeclaratorNode(parentNode)) {\n            throw new Error('Cannot get `VariableDeclarator` node for `ObjectExpression` node');\n        }\n\n        return parentNode;\n    }\n\n    /**\n     * @param {VariableDeclarator} variableDeclaratorNode\n     * @returns {VariableDeclaration}\n     */\n    private getHostVariableDeclarationNode (variableDeclaratorNode: ESTree.VariableDeclarator): ESTree.VariableDeclaration | never {\n        const { parentNode } = variableDeclaratorNode;\n\n        if (!parentNode || !NodeGuards.isVariableDeclarationNode(parentNode)) {\n            throw new Error('Cannot get `VariableDeclaration` node for `VariableDeclarator` node');\n        }\n\n        return parentNode;\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Identifier} memberExpressionHostNode\n     * @returns {boolean}\n     */\n    private isProhibitedObjectExpressionNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        memberExpressionHostNode: ESTree.Identifier\n    ): boolean {\n        const hostVariableDeclarator: ESTree.VariableDeclarator = this.getHostVariableDeclaratorNode(objectExpressionNode);\n        const hostVariableDeclaration: ESTree.VariableDeclaration = this.getHostVariableDeclarationNode(hostVariableDeclarator);\n        const { declarations } = hostVariableDeclaration;\n        const indexOfDeclarator: number = declarations.indexOf(hostVariableDeclarator);\n        const isLastDeclarator: boolean = indexOfDeclarator === (declarations.length - 1);\n\n        // avoid unnecessary checks\n        if (isLastDeclarator) {\n            return false;\n        }\n\n        const declaratorsAfterCurrentDeclarator: ESTree.VariableDeclarator[] = declarations.slice(indexOfDeclarator);\n\n        let isProhibitedObjectExpressionNode: boolean = false;\n\n        // should mark node as prohibited if that node using inside other variable declarators\n        declaratorsAfterCurrentDeclarator.forEach((variableDeclarator: ESTree.VariableDeclarator) => {\n            estraverse.traverse(variableDeclarator, {\n                enter: (node: ESTree.Node): estraverse.VisitorOption | ESTree.Node => {\n                    if (\n                        NodeGuards.isMemberExpressionNode(node)\n                        && NodeGuards.isIdentifierNode(node.object)\n                        && node.object.name === memberExpressionHostNode.name\n                    ) {\n                        isProhibitedObjectExpressionNode = true;\n\n                        return estraverse.VisitorOption.Break;\n                    }\n\n                    return node;\n                }\n            });\n        });\n\n        return isProhibitedObjectExpressionNode;\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeGroup } from '../../../interfaces/custom-nodes/ICustomNodeGroup';\n\nimport { ControlFlowCustomNode } from \"../../../enums/custom-nodes/ControlFlowCustomNode\";\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { CustomNodeGroup } from '../../../enums/custom-nodes/CustomNodeGroup';\nimport { DeadCodeInjectionCustomNode } from '../../../enums/custom-nodes/DeadCodeInjectionCustomNode';\n\nimport { ConsoleOutputCustomNodeGroup } from '../../../custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup';\nimport { DebugProtectionCustomNodeGroup } from '../../../custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup';\nimport { DomainLockCustomNodeGroup } from '../../../custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup';\nimport { SelfDefendingCustomNodeGroup } from '../../../custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup';\nimport { StringArrayCustomNodeGroup } from '../../../custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup';\n\nimport { BinaryExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode';\nimport { BlockStatementControlFlowFlatteningNode } from '../../../custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode';\nimport { BlockStatementDeadCodeInjectionNode } from '../../../custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode';\nimport { CallExpressionControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode';\nimport { CallExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode';\nimport { ControlFlowStorageNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode';\nimport { ConsoleOutputDisableExpressionNode } from '../../../custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode';\nimport { DebugProtectionFunctionCallNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode';\nimport { DebugProtectionFunctionIntervalNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode';\nimport { DebugProtectionFunctionNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode';\nimport { DomainLockNode } from '../../../custom-nodes/domain-lock-nodes/DomainLockNode';\nimport { ExpressionWithOperatorControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode';\nimport { LogicalExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode';\nimport { NodeCallsControllerFunctionNode } from '../../../custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode';\nimport { SelfDefendingUnicodeNode } from '../../../custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode';\nimport { StringArrayCallsWrapper } from '../../../custom-nodes/string-array-nodes/StringArrayCallsWrapper';\nimport { StringArrayNode } from '../../../custom-nodes/string-array-nodes/StringArrayNode';\nimport { StringArrayRotateFunctionNode } from '../../../custom-nodes/string-array-nodes/StringArrayRotateFunctionNode';\nimport { StringLiteralControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode';\nimport { StringLiteralNode } from '../../../custom-nodes/control-flow-flattening-nodes/StringLiteralNode';\n\nexport const customNodesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // custom nodes\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(ConsoleOutputDisableExpressionNode)\n        .whenTargetNamed(CustomNode.ConsoleOutputDisableExpressionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionCallNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionCallNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionIntervalNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionIntervalNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DomainLockNode)\n        .whenTargetNamed(CustomNode.DomainLockNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(NodeCallsControllerFunctionNode)\n        .whenTargetNamed(CustomNode.NodeCallsControllerFunctionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(SelfDefendingUnicodeNode)\n        .whenTargetNamed(CustomNode.SelfDefendingUnicodeNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayCallsWrapper)\n        .whenTargetNamed(CustomNode.StringArrayCallsWrapper);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayNode)\n        .whenTargetNamed(CustomNode.StringArrayNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayRotateFunctionNode)\n        .whenTargetNamed(CustomNode.StringArrayRotateFunctionNode);\n\n    // control flow custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BinaryExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.BinaryExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementControlFlowFlatteningNode)\n        .whenTargetNamed(ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.CallExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ControlFlowStorageNode)\n        .whenTargetNamed(ControlFlowCustomNode.ControlFlowStorageNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ExpressionWithOperatorControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(LogicalExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.LogicalExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringLiteralNode)\n        .whenTargetNamed(ControlFlowCustomNode.StringLiteralNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringLiteralControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode);\n\n    // dead code injection custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementDeadCodeInjectionNode)\n        .whenTargetNamed(DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode);\n\n    // node groups\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(ConsoleOutputCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.ConsoleOutputCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DebugProtectionCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.DebugProtectionCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DomainLockCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.DomainLockCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(SelfDefendingCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.SelfDefendingCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(StringArrayCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.StringArrayCustomNodeGroup);\n\n    // customNode factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__ICustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getFactory<CustomNode, ICustomNode>(ServiceIdentifiers.ICustomNode));\n\n    // control flow customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<ControlFlowCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions\n            ));\n\n    // dead code injection customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<DeadCodeInjectionCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions\n            ));\n\n    // customNodeGroup factory\n    bind<ICustomNodeGroup>(ServiceIdentifiers.Factory__ICustomNodeGroup)\n        .toFactory<ICustomNodeGroup>(InversifyContainerFacade\n            .getFactory<CustomNodeGroup, ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class ConsoleOutputCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // consoleOutputDisableExpressionNode append\n        this.appendCustomNodeIfExist(CustomNode.ConsoleOutputDisableExpressionNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                stackTraceData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = stackTraceData.length\n                ? NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.disableConsoleOutput) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const consoleOutputDisableExpressionNode: ICustomNode = this.customNodeFactory(CustomNode.ConsoleOutputDisableExpressionNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        consoleOutputDisableExpressionNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.ConsoleOutputDisableExpressionNode, consoleOutputDisableExpressionNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class DebugProtectionCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // debugProtectionFunctionCallNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionCallNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                stackTraceData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // debugProtectionFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.append(nodeWithStatements, customNode.getNode());\n        });\n\n        // debugProtectionFunctionIntervalNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionIntervalNode, (customNode: ICustomNode) => {\n            const programBodyLength: number = NodeGuards.isSwitchCaseNode(nodeWithStatements)\n                ? nodeWithStatements.consequent.length\n                : nodeWithStatements.body.length;\n            const randomIndex: number = this.randomGenerator.getRandomInteger(0, programBodyLength);\n\n            NodeAppender.insertAtIndex(nodeWithStatements, customNode.getNode(), randomIndex);\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = stackTraceData.length\n                ? NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.debugProtection) {\n            return;\n        }\n\n        const debugProtectionFunctionName: string = this.identifierNamesGenerator.generate();\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const debugProtectionFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionNode);\n        const debugProtectionFunctionCallNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionCallNode);\n        const debugProtectionFunctionIntervalNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionIntervalNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        debugProtectionFunctionNode.initialize(debugProtectionFunctionName);\n        debugProtectionFunctionCallNode.initialize(debugProtectionFunctionName, callsControllerFunctionName);\n        debugProtectionFunctionIntervalNode.initialize(debugProtectionFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.DebugProtectionFunctionNode, debugProtectionFunctionNode);\n        this.customNodes.set(CustomNode.DebugProtectionFunctionCallNode, debugProtectionFunctionCallNode);\n\n        if (this.options.debugProtectionInterval) {\n            this.customNodes.set(CustomNode.DebugProtectionFunctionIntervalNode, debugProtectionFunctionIntervalNode);\n        }\n\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class DomainLockCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // domainLockNode append\n        this.appendCustomNodeIfExist(CustomNode.DomainLockNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                stackTraceData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = stackTraceData.length\n                ? NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.domainLock.length) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const domainLockNode: ICustomNode = this.customNodeFactory(CustomNode.DomainLockNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        domainLockNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.DomainLockNode, domainLockNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class SelfDefendingCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected appendEvent: ObfuscationEvent = ObfuscationEvent.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // selfDefendingUnicodeNode append\n        this.appendCustomNodeIfExist(CustomNode.SelfDefendingUnicodeNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                stackTraceData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = stackTraceData.length\n                ? NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.selfDefending) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const selfDefendingUnicodeNode: ICustomNode = this.customNodeFactory(CustomNode.SelfDefendingUnicodeNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        selfDefendingUnicodeNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.SelfDefendingUnicodeNode, selfDefendingUnicodeNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\nimport { TStringArrayStorage } from '../../../types/storages/TStringArrayStorage';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class StringArrayCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected appendEvent: ObfuscationEvent = ObfuscationEvent.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @type {TStringArrayStorage}\n     */\n    private readonly stringArrayStorage: TStringArrayStorage;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: TStringArrayStorage,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n        this.stringArrayStorage = stringArrayStorage;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, stackTraceData: IStackTraceData[]): void {\n        if (!this.stringArrayStorage.getLength()) {\n            return;\n        }\n\n        // stringArrayNode append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayNode, (customNode: ICustomNode) => {\n            NodeAppender.prepend(nodeWithStatements, customNode.getNode());\n        });\n\n        // stringArrayCallsWrapper append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayCallsWrapper, (customNode: ICustomNode) => {\n            NodeAppender.insertAtIndex(nodeWithStatements, customNode.getNode(), 1);\n        });\n\n        // stringArrayRotateFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayRotateFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.insertAtIndex(nodeWithStatements, customNode.getNode(), 1);\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.stringArray) {\n            return;\n        }\n\n        const stringArrayNode: ICustomNode = this.customNodeFactory(CustomNode.StringArrayNode);\n        const stringArrayCallsWrapper: ICustomNode = this.customNodeFactory(CustomNode.StringArrayCallsWrapper);\n        const stringArrayRotateFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.StringArrayRotateFunctionNode);\n\n        const stringArrayStorageId: string = this.stringArrayStorage.getStorageId();\n\n        const [stringArrayName, stringArrayCallsWrapperName]: string[] = stringArrayStorageId.split('|');\n\n        let stringArrayRotateValue: number;\n\n        if (this.options.rotateStringArray) {\n            stringArrayRotateValue = this.randomGenerator.getRandomInteger(100, 500);\n        } else {\n            stringArrayRotateValue = 0;\n        }\n\n        stringArrayNode.initialize(this.stringArrayStorage, stringArrayName, stringArrayRotateValue);\n        stringArrayCallsWrapper.initialize(stringArrayName, stringArrayCallsWrapperName);\n        stringArrayRotateFunctionNode.initialize(stringArrayName, stringArrayRotateValue);\n\n        this.customNodes.set(CustomNode.StringArrayNode, stringArrayNode);\n        this.customNodes.set(CustomNode.StringArrayCallsWrapper, stringArrayCallsWrapper);\n\n        if (this.options.rotateStringArray) {\n            this.customNodes.set(CustomNode.StringArrayRotateFunctionNode, stringArrayRotateFunctionNode);\n        }\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BinaryExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {BinaryOperator}\n     */\n    @initializable()\n    private operator!: BinaryOperator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BinaryOperator} operator\n     */\n    public initialize (operator: BinaryOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    NodeFactory.identifierNode('x'),\n                    NodeFactory.identifierNode('y')\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.binaryExpressionNode(\n                            this.operator,\n                            NodeFactory.identifierNode('x'),\n                            NodeFactory.identifierNode('y')\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","/**\n * @returns {string}\n */\nexport function GlobalVariableTemplate1 (): string {\n    return `\n        var that;\n        \n        try {\n            var getGlobal = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');');\n            \n            that = getGlobal();\n        } catch (e) {\n            that = window;\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function GlobalVariableTemplate2 (): string {\n    return `\n        var getGlobal = function () {\n            var globalObject;\n        \n            try {\n                globalObject = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');')();\n            } catch (e) {\n                globalObject = window;\n            }\n            \n            return globalObject;\n        };\n        var that = getGlobal();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementControlFlowFlatteningNode extends AbstractCustomNode {\n    /**\n     * @type {ESTree.Statement[]}\n     */\n    @initializable()\n    private blockStatementBody!: ESTree.Statement[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private originalKeysIndexesInShuffledArray!: number[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private shuffledKeys!: number[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {Statement[]} blockStatementBody\n     * @param {number[]} shuffledKeys\n     * @param {number[]} originalKeysIndexesInShuffledArray\n     */\n    public initialize (\n        blockStatementBody: ESTree.Statement[],\n        shuffledKeys: number[],\n        originalKeysIndexesInShuffledArray: number[]\n    ): void {\n        this.blockStatementBody = blockStatementBody;\n        this.shuffledKeys = shuffledKeys;\n        this.originalKeysIndexesInShuffledArray = originalKeysIndexesInShuffledArray;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const controllerIdentifierName: string = this.randomGenerator.getRandomString(6);\n        const indexIdentifierName: string = this.randomGenerator.getRandomString(6);\n        const structure: ESTree.BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.variableDeclarationNode([\n                NodeFactory.variableDeclaratorNode(\n                    NodeFactory.identifierNode(controllerIdentifierName),\n                    NodeFactory.callExpressionNode(\n                        NodeFactory.memberExpressionNode(\n                            NodeFactory.literalNode(\n                                this.originalKeysIndexesInShuffledArray.join('|')\n                            ),\n                            NodeFactory.identifierNode('split')\n                        ),\n                        [\n                            NodeFactory.literalNode('|')\n                        ]\n                    )\n                ),\n                NodeFactory.variableDeclaratorNode(\n                    NodeFactory.identifierNode(indexIdentifierName),\n                    NodeFactory.literalNode(0)\n                )\n            ]),\n            NodeFactory.whileStatementNode(\n                NodeFactory.literalNode(true),\n                NodeFactory.blockStatementNode([\n                    NodeFactory.switchStatementNode(\n                        NodeFactory.memberExpressionNode(\n                            NodeFactory.identifierNode(controllerIdentifierName),\n                            NodeFactory.updateExpressionNode(\n                                '++',\n                                NodeFactory.identifierNode(indexIdentifierName)\n                            ),\n                            true\n                        ),\n                        this.shuffledKeys.map((key: number, index: number) => {\n                            const statement: ESTree.Statement = this.blockStatementBody[key];\n                            const consequent: ESTree.Statement[] = [statement];\n\n                            /**\n                             * We shouldn't add continue statement after return statement\n                             * to prevent `unreachable code after return statement` warnings\n                             */\n                            if (!NodeGuards.isReturnStatementNode(statement)) {\n                                consequent.push(NodeFactory.continueStatement());\n                            }\n\n                            return NodeFactory.switchCaseNode(\n                                NodeFactory.literalNode(String(index)),\n                                consequent\n                            );\n                        })\n                    ),\n                    NodeFactory.breakStatement()\n                ])\n            )\n        ]);\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator, BlockStatement } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementDeadCodeInjectionNode extends AbstractCustomNode {\n    /**\n     * @type {BlockStatement}\n     */\n    @initializable()\n    private blockStatementNode!: BlockStatement;\n\n    /**\n     * @type {BlockStatement}\n     */\n    @initializable()\n    private deadCodeInjectionRootAstHostNode!: BlockStatement;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {BlockStatement} deadCodeInjectionRootAstHostNode\n     */\n    public initialize (\n        blockStatementNode: BlockStatement,\n        deadCodeInjectionRootAstHostNode: BlockStatement\n    ): void {\n        this.blockStatementNode = blockStatementNode;\n        this.deadCodeInjectionRootAstHostNode = deadCodeInjectionRootAstHostNode;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const random1: boolean = this.randomGenerator.getMathRandom() > 0.5;\n        const random2: boolean = this.randomGenerator.getMathRandom() > 0.5;\n\n        const operator: BinaryOperator = random1 ? '===' : '!==';\n        const leftString: string = this.randomGenerator.getRandomString(5);\n        const rightString: string = random2 ? leftString : this.randomGenerator.getRandomString(5);\n\n        const [consequent, alternate]: [BlockStatement, BlockStatement] = random1 === random2\n            ? [this.blockStatementNode, this.deadCodeInjectionRootAstHostNode]\n            : [this.deadCodeInjectionRootAstHostNode, this.blockStatementNode];\n\n        const structure: BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.ifStatementNode(\n                NodeFactory.binaryExpressionNode(\n                    operator,\n                    NodeFactory.literalNode(leftString),\n                    NodeFactory.literalNode(rightString)\n                ),\n                consequent,\n                alternate\n            )\n        ]);\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\n// tslint:disable\nimport { Expression } from 'estree';\n// tslint:enable\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from \"../../../interfaces/utils/IRandomGenerator\";\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private callee!: Expression;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments!: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        callee: ESTree.Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.callee = callee;\n        this.expressionArguments = expressionArguments;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.callExpressionNode(\n                NodeFactory.memberExpressionNode(\n                    NodeFactory.identifierNode(this.controlFlowStorageName),\n                    NodeFactory.identifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.callee,\n                    ...this.expressionArguments\n                ]\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments!: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     */\n    public initialize (expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]): void {\n        this.expressionArguments = expressionArguments;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const calleeIdentifier: ESTree.Identifier = NodeFactory.identifierNode('callee');\n        const params: ESTree.Identifier[] = [];\n        const argumentsLength: number = this.expressionArguments.length;\n\n        for (let i: number = 0; i < argumentsLength; i++) {\n            params.push(NodeFactory.identifierNode(`param${i + 1}`));\n        }\n\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    calleeIdentifier,\n                    ...params\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.callExpressionNode(\n                            calleeIdentifier,\n                            params\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ControlFlowStorageNode extends AbstractCustomNode {\n    /**\n     * @type {TControlFlowStorage}\n     */\n    @initializable()\n    private controlFlowStorage!: TControlFlowStorage;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {TControlFlowStorage} controlFlowStorage\n     */\n    public initialize (controlFlowStorage: TControlFlowStorage): void {\n        this.controlFlowStorage = controlFlowStorage;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const propertyNodes: ESTree.Property[] = Array\n            .from<[string, ICustomNode]>(this.controlFlowStorage.getStorage())\n            .map(([key, value]: [string, ICustomNode]) => {\n                const node: ESTree.Node = value.getNode()[0];\n\n                if (!NodeGuards.isExpressionStatementNode(node)) {\n                    throw new Error('Function node for control flow storage object should be passed inside the `ExpressionStatement` node!');\n                }\n\n                return NodeFactory.propertyNode(\n                    NodeFactory.identifierNode(key),\n                    node.expression\n                );\n            });\n\n        let structure: ESTree.Node = NodeFactory.variableDeclarationNode([\n            NodeFactory.variableDeclaratorNode(\n                NodeFactory.identifierNode(this.controlFlowStorage.getStorageId()),\n                NodeFactory.objectExpressionNode(propertyNodes)\n            )\n        ]);\n\n        structure = NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { ConsoleOutputDisableExpressionTemplate } from '../../templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class ConsoleOutputDisableExpressionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n\n        return format(ConsoleOutputDisableExpressionTemplate(), {\n            consoleLogDisableFunctionName: this.identifierNamesGenerator.generate(),\n            globalVariableTemplate,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function ConsoleOutputDisableExpressionTemplate (): string {\n    return `\n        var {consoleLogDisableFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var func = function () {};\n            \n            {globalVariableTemplate}\n                        \n            if (!that.console) {\n                that.console = (function (func){\n                    var c = {};\n                    \n                    c.log = func;\n                    c.warn = func;\n                    c.debug = func;\n                    c.info = func;\n                    c.error = func;\n                    c.exception = func;\n                    c.trace = func;\n                    \n                    return c;\n                })(func);\n            } else {\n                that.console.log = func;\n                that.console.warn = func;\n                that.console.debug = func;\n                that.console.info = func;\n                that.console.error = func;\n                that.console.exception = func;\n                that.console.trace = func;\n            }\n        });\n        \n        {consoleLogDisableFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionCallTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string, callsControllerFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(DebugProtectionFunctionCallTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionCallTemplate (): string {\n    return `\n        (function () {\n            {singleNodeCallControllerFunctionName}(this, function () {\n                var regExp1 = new RegExp('function *\\\\\\\\( *\\\\\\\\)');\n                var regExp2 = new RegExp('\\\\\\\\+\\\\\\\\+ *\\\\(?:_0x(?:[a-f0-9]){4,6}|(?:\\\\\\\\b|\\\\\\\\d)[a-z0-9]{1,4}(?:\\\\\\\\b|\\\\\\\\d)\\\\)', 'i');\n       \n                var result = {debugProtectionFunctionName}('init');\n                \n                if (!regExp1.test(result + 'chain') || !regExp2.test(result + 'input')) {\n                    result('0');\n                } else {\n                    {debugProtectionFunctionName}();\n                }\n            })();\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionIntervalTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionIntervalNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(DebugProtectionFunctionIntervalTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionIntervalTemplate (): string {\n    return `\n        setInterval(function () {\n            {debugProtectionFunctionName}();\n        }, 4000);\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebuggerTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate';\nimport { DebuggerTemplateNoEval } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval';\nimport { DebugProtectionFunctionTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const debuggerTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? DebuggerTemplate()\n            : DebuggerTemplateNoEval();\n\n        return format(DebugProtectionFunctionTemplate(), {\n            debuggerTemplate,\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebuggerTemplate (): string {\n    return `\n        if (typeof counter === 'string') {\n            return (function (arg) {}.constructor('while (true) {}').apply('counter'));\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                (function () {return true;}.constructor('debu' + 'gger').call('action'));\n            } else {\n                (function () {return false;}.constructor('debu' + 'gger').apply('stateObject'));\n            }\n            \n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function DebuggerTemplateNoEval (): string {\n    return `\n        if (typeof counter === 'string') {\n            var func = function () {\n                while (true) {}\n            };\n            \n            return func();\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                debugger;\n            } else {\n                debugger;\n            }\n            \n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionTemplate (): string {\n    return `\n        function {debugProtectionFunctionName} (ret) {\n            function debuggerProtection (counter) {\n            \n                {debuggerTemplate}\n                \n                debuggerProtection(++counter);\n            }\n            \n            try {\n                if (ret) {\n                    return debuggerProtection;\n                } else {\n                    debuggerProtection(0);\n                }\n            } catch (y) {}\n        }\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { ICryptUtils } from '../../interfaces/utils/ICryptUtils';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DomainLockNodeTemplate } from '../../templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DomainLockNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName!: string;\n\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {ICryptUtils} cryptUtils\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.cryptUtils = cryptUtils;\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const domainsString: string = this.options.domainLock.join(';');\n        const [hiddenDomainsString, diff]: string[] = this.cryptUtils.hideString(\n            domainsString,\n            domainsString.length * 3\n        );\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n\n        return format(DomainLockNodeTemplate(), {\n            domainLockFunctionName: this.identifierNamesGenerator.generate(),\n            diff: diff,\n            domains: hiddenDomainsString,\n            globalVariableTemplate,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DomainLockNodeTemplate (): string {\n    return `\n        var {domainLockFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            \n            {globalVariableTemplate}\n            \n            var func = function () {\n                return {\n                    key: 'item',\n                    value: 'attribute',\n                    getAttribute: function () {\n                        for (var i = 0; i < 1000; i--) {\n                            var isPositive = i > 0;\n                            \n                            switch (isPositive) {\n                                case true:\n                                    return this.item + '_' + this.value + '_' + i;\n                                default:\n                                    this.item + '_' + this.value;\n                            }\n                        }\n                    }()\n                };\n            };\n                        \n            var regExp = new RegExp(\"[{diff}]\", \"g\");\n            var domains = \"{domains}\".replace(regExp, \"\").split(\";\");\n            var document;\n            var domain;\n            var location;\n            var hostname;\n\n            for (var d in that) {\n                if (d.length == 8 && d.charCodeAt(7) == 116 && d.charCodeAt(5) == 101 && d.charCodeAt(3) == 117 && d.charCodeAt(0) == 100) {\n                    document = d;\n                \n                    break;\n                }\n            }\n\n            for (var d1 in that[document]) {\n                if (d1.length == 6 && d1.charCodeAt(5) == 110 && d1.charCodeAt(0) == 100) {\n                    domain = d1;\n                    \n                    break;\n                }\n            }\n\n            if (!(\"~\" > domain)) {\n                for (var d2 in that[document]) {\n                    if (d2.length == 8 && d2.charCodeAt(7) == 110 && d2.charCodeAt(0) == 108) {\n                        location = d2;\n                        \n                        break;\n                    }\n                }\n\n                for (var d3 in that[document][location]) {\n                    if (d3.length == 8 && d3.charCodeAt(7) == 101 && d3.charCodeAt(0) == 104) {\n                        hostname = d3;\n                        \n                        break;\n                    }\n                }\n            }\n            \n            if (!document || !that[document]) {\n                return;\n            }\n            \n            var documentDomain = that[document][domain];\n            var documentLocationHostName = !!that[document][location] && that[document][location][hostname];\n            var currentDomain = documentDomain || documentLocationHostName;\n          \n            if (!currentDomain) {\n                return;\n            }\n          \n            var ok = false;\n                        \n            for (var i = 0; i < domains.length; i++) {\n                var domain = domains[i];\n                var position = currentDomain.length - domain.length;\n                var lastIndex = currentDomain.indexOf(domain, position);\n                var endsWith = lastIndex !== -1 && lastIndex === position;\n                \n                if (endsWith) {\n                    if (currentDomain.length == domain.length || domain.indexOf(\".\") === 0) {\n                        ok = true;\n                    }\n                }\n            }\n               \n            if (!ok) {\n                data;\n            } else {\n                return;\n            }\n            \n            func();\n        });\n\n        {domainLockFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { Expression } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ExpressionWithOperatorControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private leftValue!: Expression;\n\n    /**\n     * @type {ESTree.Expression}\n     */\n    @initializable()\n    private rightValue!: Expression;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     * @param {Expression} leftValue\n     * @param {Expression} rightValue\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        leftValue: Expression,\n        rightValue: Expression,\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.leftValue = leftValue;\n        this.rightValue = rightValue;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.callExpressionNode(\n                NodeFactory.memberExpressionNode(\n                    NodeFactory.identifierNode(this.controlFlowStorageName),\n                    NodeFactory.identifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.leftValue,\n                    this.rightValue\n                ]\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { LogicalOperator } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {LogicalOperator}\n     */\n    @initializable()\n    private operator!: LogicalOperator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {LogicalOperator} operator\n     */\n    public initialize (operator: LogicalOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    NodeFactory.identifierNode('x'),\n                    NodeFactory.identifierNode('y')\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.logicalExpressionNode(\n                            this.operator,\n                            NodeFactory.identifierNode('x'),\n                            NodeFactory.identifierNode('y')\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationEvent } from '../../enums/event-emitters/ObfuscationEvent';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { SingleNodeCallControllerTemplate } from '../../templates/SingleNodeCallControllerTemplate';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class NodeCallsControllerFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName!: string;\n\n    /**\n     * @type {ObfuscationEvent}\n     */\n    @initializable()\n    private appendEvent!: ObfuscationEvent;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {ObfuscationEvent} appendEvent\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (appendEvent: ObfuscationEvent, callsControllerFunctionName: string): void {\n        this.appendEvent = appendEvent;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        if (this.appendEvent === ObfuscationEvent.AfterObfuscation) {\n            return JavaScriptObfuscator.obfuscate(\n                format(SingleNodeCallControllerTemplate(), {\n                    singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n                }),\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    identifierNamesGenerator: this.options.identifierNamesGenerator,\n                    seed: this.options.seed\n                }\n            ).getObfuscatedCode();\n        }\n\n        return format(SingleNodeCallControllerTemplate(), {\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function SingleNodeCallControllerTemplate (): string {\n    return `\n        var {singleNodeCallControllerFunctionName} = (function(){\n            var firstCall = true;\n            \n            return function (context, fn){\n                var rfn = firstCall ? function(){\n                    if(fn){\n                        var res = fn.apply(context, arguments);\n                        fn = null;\n                        return res;\n                    }\n                } : function(){}\n                \n                firstCall = false;\n                \n                return rfn;\n            }\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class SelfDefendingUnicodeNode extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return JavaScriptObfuscator.obfuscate(\n            format(SelfDefendingTemplate(this.escapeSequenceEncoder), {\n                selfDefendingFunctionName: this.identifierNamesGenerator.generate(),\n                singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed,\n                unicodeEscapeSequence: true\n            }\n        ).getObfuscatedCode();\n    }\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * SelfDefendingTemplate. Enters code in infinity loop.\n * Notice, that second and third call to recursiveFunc1('indexOf') has cyrillic `е` character instead latin\n *\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n */\nexport function SelfDefendingTemplate (escapeSequenceEncoder: IEscapeSequenceEncoder): string {\n    return `\n        var {selfDefendingFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var func1 = function(){return 'dev';},\n                func2 = function () {\n                    return 'window';\n                };\n                \n            var test1 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`, true)\n                }');\n                \n                return !regExp.test(func1.toString());\n            };\n            \n            var test2 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`(\\\\\\\\[x|u](\\\\w){2,4})+`, true)\n                }');\n                \n                return regExp.test(func2.toString());\n            };\n            \n            var recursiveFunc1 = function (string) {\n                var i = ~-1 >> 1 + 255 % 0;\n                                \n                if (string.indexOf('i' === i)) {\n                    recursiveFunc2(string)\n                }\n            };\n            \n            var recursiveFunc2 = function (string) {\n                var i = ~-4 >> 1 + 255 % 0;\n                \n                if (string.indexOf((true+\"\")[3]) !== i) {\n                    recursiveFunc1(string)\n                }\n            };\n            \n            if (!test1()) {\n                if (!test2()) {\n                    recursiveFunc1('indеxOf');\n                } else {\n                    recursiveFunc1('indexOf');\n                }\n            } else {\n                recursiveFunc1('indеxOf');\n            }\n        })\n        \n        {selfDefendingFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AtobTemplate } from '../../templates/AtobTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\nimport { Rc4Template } from '../../templates/Rc4Template';\nimport { SelfDefendingTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate';\nimport { StringArrayBase64DecodeNodeTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate';\nimport { StringArrayCallsWrapperTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate';\nimport { StringArrayRc4DecodeNodeTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class StringArrayCallsWrapper extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayCallsWrapperName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} stringArrayName\n     * @param {string} stringArrayCallsWrapperName\n     */\n    public initialize (\n        stringArrayName: string,\n        stringArrayCallsWrapperName: string\n    ): void {\n        this.stringArrayName = stringArrayName;\n        this.stringArrayCallsWrapperName = stringArrayCallsWrapperName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const decodeNodeTemplate: string = this.getDecodeStringArrayTemplate();\n\n        return JavaScriptObfuscator.obfuscate(\n            format(StringArrayCallsWrapperTemplate(), {\n                decodeNodeTemplate,\n                stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                stringArrayName: this.stringArrayName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed\n            }\n        ).getObfuscatedCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    private getDecodeStringArrayTemplate (): string {\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n        const atobPolyfill: string = format(AtobTemplate(), { globalVariableTemplate });\n\n        let decodeStringArrayTemplate: string = '';\n        let selfDefendingCode: string = '';\n\n        if (this.options.selfDefending) {\n            selfDefendingCode = format(\n                SelfDefendingTemplate(\n                    this.randomGenerator,\n                    this.escapeSequenceEncoder\n                ),\n                {\n                    stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                    stringArrayName: this.stringArrayName\n                }\n            );\n        }\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.Rc4:\n                decodeStringArrayTemplate = format(\n                    StringArrayRc4DecodeNodeTemplate(this.randomGenerator),\n                    {\n                        atobPolyfill,\n                        rc4Polyfill: Rc4Template(),\n                        selfDefendingCode,\n                        stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                    }\n                );\n\n                break;\n\n            case StringArrayEncoding.Base64:\n                decodeStringArrayTemplate = format(\n                    StringArrayBase64DecodeNodeTemplate(this.randomGenerator),\n                    {\n                        atobPolyfill,\n                        selfDefendingCode,\n                        stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                    }\n                );\n        }\n\n        return decodeStringArrayTemplate;\n    }\n}\n","/**\n * @returns {string}\n */\nexport function AtobTemplate (): string {\n    return `\n        (function () {\n            {globalVariableTemplate}\n            \n            var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n            that.atob || (\n                that.atob = function(input) {\n                    var str = String(input).replace(/=+$/, '');\n                    for (\n                        var bc = 0, bs, buffer, idx = 0, output = '';\n                        buffer = str.charAt(idx++);\n                        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n                            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n                    ) {\n                        buffer = chars.indexOf(buffer);\n                    }\n                return output;\n            });\n        })();\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function Rc4Template (): string {\n    return `\n        var rc4 = function (str, key) {\n            var s = [], j = 0, x, res = '', newStr = '';\n           \n            str = atob(str);\n                \n            for (var k = 0, length = str.length; k < length; k++) {\n                newStr += '%' + ('00' + str.charCodeAt(k).toString(16)).slice(-2);\n            }\n        \n            str = decodeURIComponent(newStr);\n                    \t        \n\t        for (var i = 0; i < 256; i++) {\n                s[i] = i;\n            }\n \n            for (i = 0; i < 256; i++) {\n                j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n            }\n            \n            i = 0;\n            j = 0;\n            \n            for (var y = 0; y < str.length; y++) {\n                i = (i + 1) % 256;\n                j = (j + s[i]) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n                res += String.fromCharCode(str.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n            }\n                      \n            return res;\n        }\n    `;\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n * @constructor\n */\nexport function SelfDefendingTemplate (\n    randomGenerator: IRandomGenerator,\n    escapeSequenceEncoder: IEscapeSequenceEncoder\n): string {\n    const identifierLength: number = 6;\n    const rc4BytesIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const statesIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const newStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const firstStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const secondStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const checkStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const runStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const getStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const stateResultIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    \n    return `\n        var StatesClass = function (${rc4BytesIdentifier}) {\n            this.${rc4BytesIdentifier} = ${rc4BytesIdentifier};\n            this.${statesIdentifier} = [1, 0, 0];\n            this.${newStateIdentifier} = function(){return 'newState';};\n            this.${firstStateIdentifier} = '${\n                escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *`, true)\n            }';\n            this.${secondStateIdentifier} = '${\n                escapeSequenceEncoder.encode(`['|\"].+['|\"];? *}`, true)\n            }';\n        };\n        \n        StatesClass.prototype.${checkStateIdentifier} = function () {\n            var regExp = new RegExp(this.${firstStateIdentifier} + this.${secondStateIdentifier});\n            var expression = regExp.test(this.${newStateIdentifier}.toString())\n                ? --this.${statesIdentifier}[1]\n                : --this.${statesIdentifier}[0];\n            \n            return this.${runStateIdentifier}(expression);\n        };\n        \n        StatesClass.prototype.${runStateIdentifier} = function (${stateResultIdentifier}) {\n            if (!Boolean(~${stateResultIdentifier})) {\n                return ${stateResultIdentifier};\n            }\n            \n            return this.${getStateIdentifier}(this.${rc4BytesIdentifier});\n        };\n\n        StatesClass.prototype.${getStateIdentifier} = function (${rc4BytesIdentifier}) {\n            for (var i = 0, len = this.${statesIdentifier}.length; i < len; i++) {\n                this.${statesIdentifier}.push(Math.round(Math.random()));\n                len = this.${statesIdentifier}.length;\n            }\n            \n            return ${rc4BytesIdentifier}(this.${statesIdentifier}[0]);\n        };\n\n        new StatesClass({stringArrayCallsWrapperName}).${checkStateIdentifier}();\n    `;\n}\n","import { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @returns {string}\n * @constructor\n */\nexport function StringArrayBase64DecodeNodeTemplate (\n    randomGenerator: IRandomGenerator\n): string {\n    const identifierLength: number = 6;\n    const initializedIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const base64DecodeFunctionIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const dataIdentifier: string = randomGenerator.getRandomString(identifierLength);\n\n    return `\n        if ({stringArrayCallsWrapperName}.${initializedIdentifier} === undefined) {\n            {atobPolyfill}\n            \n            {stringArrayCallsWrapperName}.${base64DecodeFunctionIdentifier} = function (str) {\n                var string = atob(str);\n                var newStringChars = [];\n                \n                for (var i = 0, length = string.length; i < length; i++) {\n                    newStringChars += '%' + ('00' + string.charCodeAt(i).toString(16)).slice(-2);\n                }\n                \n                return decodeURIComponent(newStringChars);\n            };\n            \n            {stringArrayCallsWrapperName}.${dataIdentifier} = {};\n            \n            {stringArrayCallsWrapperName}.${initializedIdentifier} = true;\n        }\n                  \n        var cachedValue = {stringArrayCallsWrapperName}.${dataIdentifier}[index];\n                        \n        if (cachedValue === undefined) {\n            {selfDefendingCode}\n            \n            value = {stringArrayCallsWrapperName}.${base64DecodeFunctionIdentifier}(value);\n            {stringArrayCallsWrapperName}.${dataIdentifier}[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayCallsWrapperTemplate (): string {\n    return `\n        var {stringArrayCallsWrapperName} = function (index, key) {\n            index = index - 0;\n            \n            var value = {stringArrayName}[index];\n            \n            {decodeNodeTemplate}\n        \n            return value;\n        };\n    `;\n}\n","import { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @returns {string}\n * @constructor\n */\nexport function StringArrayRc4DecodeNodeTemplate (\n    randomGenerator: IRandomGenerator\n): string {\n    const identifierLength: number = 6;\n    const initializedIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const rc4Identifier: string = randomGenerator.getRandomString(identifierLength);\n    const dataIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const onceIdentifier: string = randomGenerator.getRandomString(identifierLength);\n  \n    return `\n        if ({stringArrayCallsWrapperName}.${initializedIdentifier} === undefined) {\n            {atobPolyfill}\n            \n            {rc4Polyfill}\n            {stringArrayCallsWrapperName}.${rc4Identifier} = rc4;\n            \n            {stringArrayCallsWrapperName}.${dataIdentifier} = {};\n            \n            {stringArrayCallsWrapperName}.${initializedIdentifier} = true;\n        }\n  \n        var cachedValue = {stringArrayCallsWrapperName}.${dataIdentifier}[index];\n\n        if (cachedValue === undefined) {\n            if ({stringArrayCallsWrapperName}.${onceIdentifier} === undefined) {\n                {selfDefendingCode}\n                \n                {stringArrayCallsWrapperName}.${onceIdentifier} = true;\n            }\n            \n            value = {stringArrayCallsWrapperName}.${rc4Identifier}(value, key);\n            {stringArrayCallsWrapperName}.${dataIdentifier}[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\nimport { TStringArrayStorage } from '../../types/storages/TStringArrayStorage';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { StringArrayTemplate } from '../../templates/string-array-nodes/string-array-node/StringArrayTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { StringArrayStorage } from '../../storages/string-array/StringArrayStorage';\n\n@injectable()\nexport class StringArrayNode extends AbstractCustomNode {\n    /**\n     * @type {TStringArrayStorage}\n     */\n    @initializable()\n    private stringArrayStorage!: TStringArrayStorage;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @type {number}\n     */\n    @initializable()\n    private stringArrayRotateValue!: number;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {string} stringArrayName\n     * @param {number} stringArrayRotateValue\n     */\n    public initialize (\n        stringArrayStorage: TStringArrayStorage,\n        stringArrayName: string,\n        stringArrayRotateValue: number\n    ): void {\n        this.stringArrayStorage = stringArrayStorage;\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        (<StringArrayStorage>this.stringArrayStorage).rotateArray(this.stringArrayRotateValue);\n\n        return super.getNode();\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(StringArrayTemplate(), {\n            stringArrayName: this.stringArrayName,\n            stringArray: this.stringArrayStorage.toString()\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayTemplate (): string {\n    return `\n        var {stringArrayName} = [{stringArray}];\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate';\nimport { StringArrayRotateFunctionTemplate } from '../../templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { NumberUtils } from '../../utils/NumberUtils';\n\n@injectable()\nexport class StringArrayRotateFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @param {number}\n     */\n    @initializable()\n    private stringArrayRotateValue!: number;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} stringArrayName\n     * @param {number} stringArrayRotateValue\n     */\n    public initialize (\n        stringArrayName: string,\n        stringArrayRotateValue: number\n    ): void {\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const timesName: string = this.identifierNamesGenerator.generate();\n        const whileFunctionName: string = this.identifierNamesGenerator.generate();\n\n        let code: string = '';\n\n        if (this.options.selfDefending) {\n            code = format(SelfDefendingTemplate(this.escapeSequenceEncoder), {\n                timesName,\n                whileFunctionName\n            });\n        } else {\n            code = `${whileFunctionName}(++${timesName})`;\n        }\n\n        return JavaScriptObfuscator.obfuscate(\n            format(StringArrayRotateFunctionTemplate(), {\n                code,\n                timesName,\n                stringArrayName: this.stringArrayName,\n                stringArrayRotateValue: NumberUtils.toHex(this.stringArrayRotateValue),\n                whileFunctionName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed\n            }\n        ).getObfuscatedCode();\n    }\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * SelfDefendingTemplate. Enter code in infinity loop.\n *\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n */\nexport function SelfDefendingTemplate (escapeSequenceEncoder: IEscapeSequenceEncoder): string {\n    return `\n        var selfDefendingFunc = function () {\n            var object = {\n                data: {\n                    key: 'cookie',\n                    value: 'timeout'\n                },\n                setCookie: function (options, name, value, document) {\n                    document = document || {};\n                    \n                    var updatedCookie = name + \"=\" + value;\n\n                    var i = 0;\n                                                            \n                    for (var i = 0, len = options.length; i < len; i++) {\n                        var propName = options[i];\n                                     \n                        updatedCookie += \"; \" + propName;\n                        \n                        var propValue = options[propName];\n                        \n                        options.push(propValue);\n                        len = options.length;\n                                                                        \n                        if (propValue !== true) {\n                            updatedCookie += \"=\" + propValue;\n                        }\n                    }\n\n                    document['cookie'] = updatedCookie;\n                },\n                removeCookie: function(){return 'dev';},\n                getCookie: function (document, name) {\n                    document = document || function (value) { return value };\n                    var matches = document(new RegExp(\n                        \"(?:^|; )\" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, '\\\\$1') + \"=([^;]*)\"\n                    ));\n                    \n                    var func = function (param1, param2) {\n                        param1(++param2);\n                    };\n                    \n                    func({whileFunctionName}, {timesName});\n                                        \n                    return matches ? decodeURIComponent(matches[1]) : undefined;\n                }\n            };\n            \n            var test1 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`, true)\n                }');\n                \n                return regExp.test(object.removeCookie.toString());\n            };\n            \n            object['updateCookie'] = test1;\n            \n            var cookie = '';\n            var result = object['updateCookie']();\n                                    \n            if (!result) {\n                object['setCookie'](['*'], 'counter', 1);\n            } else if (result) {\n                cookie = object['getCookie'](null, 'counter');\n            } else {\n                object['removeCookie']();\n            }\n        };\n        \n        selfDefendingFunc();\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayRotateFunctionTemplate (): string {\n    return `\n        (function (array, {timesName}) {\n            var {whileFunctionName} = function (times) {\n                while (--times) {\n                    array['push'](array['shift']());\n                }\n            };\n            \n            {code}\n        })({stringArrayName}, 0x{stringArrayRotateValue});\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class StringLiteralControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.memberExpressionNode(\n                NodeFactory.identifierNode(this.controlFlowStorageName),\n                NodeFactory.identifierNode(this.controlFlowStorageKey)\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\n\n@injectable()\nexport class StringLiteralNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private literalValue!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} literalValue\n     */\n    public initialize (literalValue: string): void {\n        this.literalValue = literalValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.literalNode(this.literalValue)\n        );\n\n        return [structure];\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\n\nexport const finalizingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // finalizing transformers\n\n});\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IIdentifierNamesGenerator } from '../../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { IdentifierNamesGenerator } from '../../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\n\nimport { HexadecimalIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator';\nimport { MangledIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/MangledIdentifierNamesGenerator';\n\nexport const generatorsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // identifier name generators\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(HexadecimalIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator);\n\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(MangledIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.MangledIdentifierNamesGenerator);\n\n    // identifier name generator factory\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n        .toFactory<IIdentifierNamesGenerator>((context: interfaces.Context): (options: IOptions) => IIdentifierNamesGenerator => {\n            let cachedIdentifierNamesGenerator: IIdentifierNamesGenerator | null = null;\n\n            return (options: IOptions) => {\n                if (cachedIdentifierNamesGenerator) {\n                    return cachedIdentifierNamesGenerator;\n                }\n\n                let identifierNamesGenerator: IIdentifierNamesGenerator;\n\n                switch (options.identifierNamesGenerator) {\n                    case IdentifierNamesGenerator.MangledIdentifierNamesGenerator:\n                        identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                            ServiceIdentifiers.IIdentifierNamesGenerator,\n                            IdentifierNamesGenerator.MangledIdentifierNamesGenerator\n                        );\n\n                        break;\n\n                    case IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator:\n                    default:\n                        identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                            ServiceIdentifiers.IIdentifierNamesGenerator,\n                            IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator\n                        );\n                }\n\n                cachedIdentifierNamesGenerator = identifierNamesGenerator;\n\n                return identifierNamesGenerator;\n            };\n        });\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\nimport { NumberUtils } from '../../utils/NumberUtils';\nimport { Utils } from '../../utils/Utils';\n\n@injectable()\nexport class HexadecimalIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {number}\n     */\n    private static readonly baseIdentifierNameLength: number = 6;\n\n    /**\n     * @type {Set<string>}\n     */\n    private readonly randomVariableNameSet: Set <string> = new Set();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public generate (nameLength?: number): string {\n        const rangeMinInteger: number = 10000;\n        const rangeMaxInteger: number = 99_999_999;\n        const randomInteger: number = this.randomGenerator.getRandomInteger(rangeMinInteger, rangeMaxInteger);\n        const hexadecimalNumber: string = NumberUtils.toHex(randomInteger);\n        const prefixLength: number = Utils.hexadecimalPrefix.length + 1;\n        const baseNameLength: number = nameLength\n            ? nameLength - prefixLength\n            : HexadecimalIdentifierNamesGenerator.baseIdentifierNameLength;\n        const baseIdentifierName: string = hexadecimalNumber.substr(0, baseNameLength);\n        const identifierName: string = `_${Utils.hexadecimalPrefix}${baseIdentifierName}`;\n\n        if (this.randomVariableNameSet.has(identifierName)) {\n            return this.generate(nameLength);\n        }\n\n        this.randomVariableNameSet.add(identifierName);\n\n        return identifierName;\n    }\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public generateWithPrefix (nameLength?: number): string {\n        const identifierName: string = this.generate(nameLength);\n\n        return `${this.options.identifiersPrefix}${identifierName}`.replace('__', '_');\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\n\n@injectable()\nexport class MangledIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {string}\n     */\n    private static readonly initMangledNameCharacter: string = '9';\n\n    /**\n     * @type {string[]}\n     */\n    private static readonly nameSequence: string[] = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n\n    /**\n     * Reserved JS words with length of 2-4 symbols that can be possible generated with this replacer\n     *\n     * @type {string[]}\n     */\n    private static readonly reservedNames: string[] = [\n        'byte', 'case', 'char', 'do', 'else', 'enum', 'eval', 'for', 'goto',\n        'if', 'in', 'int', 'let', 'long', 'new', 'null', 'this', 'true', 'try',\n        'var', 'void', 'with'\n    ];\n\n    /**\n     * @type {string}\n     */\n    private previousMangledName: string = MangledIdentifierNamesGenerator.initMangledNameCharacter;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * We can only ignore limited nameLength, it has no sense here\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public generate (nameLength?: number): string {\n        const identifierName: string = this.generateNewMangledName(this.previousMangledName);\n\n        this.previousMangledName = identifierName;\n\n        return identifierName;\n    }\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public generateWithPrefix (nameLength?: number): string {\n        const prefix: string = this.options.identifiersPrefix ?\n            `${this.options.identifiersPrefix}_`\n            : '';\n        const identifierName: string = this.generate(nameLength);\n\n        return `${prefix}${identifierName}`;\n    }\n\n    /**\n     * @param {string} mangledName\n     * @returns {boolean}\n     */\n    public isValidIdentifierName (mangledName: string): boolean {\n        return super.isValidIdentifierName(mangledName)\n            && !MangledIdentifierNamesGenerator.reservedNames.includes(mangledName);\n    }\n\n    /**\n     * @param {string} previousMangledName\n     * @returns {string}\n     */\n    private generateNewMangledName (previousMangledName: string): string {\n        const generateNewMangledName: (name: string) => string = (name: string): string => {\n            const nameSequence: string[] = MangledIdentifierNamesGenerator.nameSequence;\n            const nameLength: number = name.length;\n\n            const zeroSequence: (num: number) => string = (num: number): string => {\n                return '0'.repeat(num);\n            };\n\n            let index: number = nameLength - 1;\n\n            do {\n                const character: string = name.charAt(index);\n                const indexInSequence: number = nameSequence.indexOf(character);\n                const lastNameSequenceIndex: number = nameSequence.length - 1;\n\n                if (indexInSequence !== lastNameSequenceIndex) {\n                    const previousNamePart: string = name.substring(0, index);\n                    const nextCharacter: string = nameSequence[indexInSequence + 1];\n                    const zeroSequenceLength: number = nameLength - (index + 1);\n                    const zeroSequenceCharacters: string = zeroSequence(zeroSequenceLength);\n\n                    return previousNamePart + nextCharacter + zeroSequenceCharacters;\n                }\n\n                --index;\n            } while (index >= 0);\n\n            return `a${zeroSequence(nameLength)}`;\n        };\n\n        let newMangledName: string = generateNewMangledName(previousMangledName);\n\n        if (!this.isValidIdentifierName(newMangledName)) {\n            newMangledName = this.generateNewMangledName(newMangledName);\n        }\n\n        return newMangledName;\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nexport const nodeTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // node transformers factory\n    bind<INodeTransformer>(ServiceIdentifiers.Factory__INodeTransformer)\n        .toFactory<INodeTransformer>(InversifyContainerFacade\n            .getCacheFactory<NodeTransformer, INodeTransformer>(ServiceIdentifiers.INodeTransformer));\n});\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IIdentifierObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IObfuscatingReplacer';\n\nimport { IdentifierObfuscatingReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { LiteralObfuscatingReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer';\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { BaseIdentifierObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer';\nimport { BooleanLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer';\nimport { CatchClauseTransformer } from '../../../node-transformers/obfuscating-transformers/CatchClauseTransformer';\nimport { ClassDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/ClassDeclarationTransformer';\nimport { FunctionDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/FunctionDeclarationTransformer';\nimport { FunctionTransformer } from '../../../node-transformers/obfuscating-transformers/FunctionTransformer';\nimport { ImportDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/ImportDeclarationTransformer';\nimport { LabeledStatementTransformer } from '../../../node-transformers/obfuscating-transformers/LabeledStatementTransformer';\nimport { LiteralTransformer } from '../../../node-transformers/obfuscating-transformers/LiteralTransformer';\nimport { NumberLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer';\nimport { StringLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer';\nimport { VariableDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/VariableDeclarationTransformer';\n\nexport const obfuscatingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // obfuscating transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CatchClauseTransformer)\n        .whenTargetNamed(NodeTransformer.CatchClauseTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ClassDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.ClassDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ImportDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.ImportDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LabeledStatementTransformer)\n        .whenTargetNamed(NodeTransformer.LabeledStatementTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LiteralTransformer)\n        .whenTargetNamed(NodeTransformer.LiteralTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(VariableDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.VariableDeclarationTransformer);\n\n    // literal obfuscating replacers\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(BooleanLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.BooleanLiteralObfuscatingReplacer);\n\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(NumberLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.NumberLiteralObfuscatingReplacer);\n\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(StringLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.StringLiteralObfuscatingReplacer);\n\n    // identifier obfuscating replacers\n    bind<IIdentifierObfuscatingReplacer>(ServiceIdentifiers.IIdentifierObfuscatingReplacer)\n        .to(BaseIdentifierObfuscatingReplacer)\n        .whenTargetNamed(IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer);\n\n    // literal obfuscating replacer factory\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.Factory__IObfuscatingReplacer)\n        .toFactory<IObfuscatingReplacer>(InversifyContainerFacade\n            .getCacheFactory<LiteralObfuscatingReplacer, IObfuscatingReplacer>(\n                ServiceIdentifiers.IObfuscatingReplacer\n            ));\n\n    // identifier obfuscating replacer factory\n    bind<IIdentifierObfuscatingReplacer>(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n        .toFactory<IIdentifierObfuscatingReplacer>(InversifyContainerFacade\n            .getCacheFactory<IdentifierObfuscatingReplacer, IIdentifierObfuscatingReplacer>(\n                ServiceIdentifiers.IIdentifierObfuscatingReplacer\n            ));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithLexicalScope } from '../../../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierNamesGenerator } from '../../../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IIdentifierObfuscatingReplacer } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\n\n@injectable()\nexport class BaseIdentifierObfuscatingReplacer extends AbstractObfuscatingReplacer implements IIdentifierObfuscatingReplacer {\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    private readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {Map<TNodeWithLexicalScope, Map<string, string>>}\n     */\n    private readonly blockScopesMap: Map<TNodeWithLexicalScope, Map<string, string>> = new Map();\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @returns {Identifier}\n     */\n    public replace (nodeValue: string, lexicalScopeNode: TNodeWithLexicalScope): ESTree.Identifier {\n        if (this.blockScopesMap.has(lexicalScopeNode)) {\n            const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(lexicalScopeNode);\n\n            if (namesMap.has(nodeValue)) {\n                nodeValue = <string>namesMap.get(nodeValue);\n            }\n        }\n\n        return NodeFactory.identifierNode(nodeValue);\n    }\n\n    /**\n     * Store `nodeName` of global identifiers as key in map with random name as value.\n     * Reserved name will be ignored.\n     *\n     * @param {string} nodeName\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    public storeGlobalName (nodeName: string, lexicalScopeNode: TNodeWithLexicalScope): void {\n        if (this.isReservedName(nodeName)) {\n            return;\n        }\n\n        const identifierName: string = this.identifierNamesGenerator.generateWithPrefix();\n\n        if (!this.blockScopesMap.has(lexicalScopeNode)) {\n            this.blockScopesMap.set(lexicalScopeNode, new Map());\n        }\n\n        const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(lexicalScopeNode);\n\n        namesMap.set(nodeName, identifierName);\n    }\n\n    /**\n     * Store `nodeName` of local identifier as key in map with random name as value.\n     * Reserved name will be ignored.\n     *\n     * @param {string} nodeName\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    public storeLocalName (nodeName: string, lexicalScopeNode: TNodeWithLexicalScope): void {\n        if (this.isReservedName(nodeName)) {\n            return;\n        }\n\n        const identifierName: string = this.identifierNamesGenerator.generate();\n\n        if (!this.blockScopesMap.has(lexicalScopeNode)) {\n            this.blockScopesMap.set(lexicalScopeNode, new Map());\n        }\n\n        const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(lexicalScopeNode);\n\n        namesMap.set(nodeName, identifierName);\n    }\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    private isReservedName (name: string): boolean {\n        if (!this.options.reservedStrings.length) {\n            return false;\n        }\n\n        return this.options.reservedNames\n            .some((reservedName: string) => {\n                return new RegExp(reservedName, 'g').exec(name) !== null;\n            });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\n\n@injectable()\nexport class BooleanLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @return {ESTree.UnaryExpression}\n     */\n    private static getTrueUnaryExpressionNode (): ESTree.UnaryExpression {\n        return NodeFactory.unaryExpressionNode(\n            '!',\n            BooleanLiteralObfuscatingReplacer.getFalseUnaryExpressionNode()\n        );\n    }\n\n    /**\n     * @return {ESTree.UnaryExpression}\n     */\n    private static getFalseUnaryExpressionNode (): ESTree.UnaryExpression {\n        return NodeFactory.unaryExpressionNode(\n            '!',\n            NodeFactory.arrayExpressionNode()\n        );\n    }\n\n    /**\n     * @param {boolean} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: boolean): ESTree.Node {\n        return nodeValue\n            ? BooleanLiteralObfuscatingReplacer.getTrueUnaryExpressionNode()\n            : BooleanLiteralObfuscatingReplacer.getFalseUnaryExpressionNode();\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     try {} catch (e) { console.log(e); };\n *\n * on:\n *     try {} catch (_0x12d45f) { console.log(_0x12d45f); };\n *\n */\n@injectable()\nexport class CatchClauseTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isCatchClauseNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (catchClauseNode: ESTree.CatchClause, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(catchClauseNode);\n\n        if (!lexicalScopeNode) {\n            return catchClauseNode;\n        }\n\n        this.storeCatchClauseParam(catchClauseNode, lexicalScopeNode);\n        this.replaceCatchClauseParam(catchClauseNode, lexicalScopeNode);\n\n        return catchClauseNode;\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeCatchClauseParam (\n        catchClauseNode: ESTree.CatchClause,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        if (NodeGuards.isIdentifierNode(catchClauseNode.param)) {\n            this.identifierObfuscatingReplacer.storeLocalName(catchClauseNode.param.name, lexicalScopeNode);\n        }\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceCatchClauseParam (\n        catchClauseNode: ESTree.CatchClause,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        estraverse.replace(catchClauseNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isReplaceableIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    }\n                }\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     class Foo { //... };\n *     new Foo();\n *\n * on:\n *     class _0x12d45f { //... };\n *     new _0x12d45f();\n */\n@injectable()\nexport class ClassDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isClassDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (classDeclarationNode: ESTree.ClassDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(classDeclarationNode);\n\n        if (!lexicalScopeNode) {\n            return classDeclarationNode;\n        }\n\n        const isGlobalDeclaration: boolean = lexicalScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return classDeclarationNode;\n        }\n\n        this.storeClassName(classDeclarationNode, lexicalScopeNode, isGlobalDeclaration);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(lexicalScopeNode)) {\n            this.replaceScopeCachedIdentifiers(classDeclarationNode, lexicalScopeNode);\n        } else {\n            this.replaceScopeIdentifiers(lexicalScopeNode);\n        }\n\n        return classDeclarationNode;\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private storeClassName (\n        classDeclarationNode: ESTree.ClassDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        if (isGlobalDeclaration) {\n            this.identifierObfuscatingReplacer.storeGlobalName(classDeclarationNode.id.name, lexicalScopeNode);\n        } else {\n            this.identifierObfuscatingReplacer.storeLocalName(classDeclarationNode.id.name, lexicalScopeNode);\n        }\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeCachedIdentifiers (\n        classDeclarationNode: ESTree.ClassDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames =\n            <TReplaceableIdentifiersNames>this.replaceableIdentifiers.get(lexicalScopeNode);\n\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined = cachedReplaceableIdentifiersNamesMap\n            .get(classDeclarationNode.id.name);\n\n        if (!cachedReplaceableIdentifiers) {\n            return;\n        }\n\n        const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n        for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n            const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, lexicalScopeNode);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        }\n    }\n\n    /**\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeIdentifiers (lexicalScopeNode: TNodeWithLexicalScope): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(lexicalScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] =\n                            storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(lexicalScopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     function foo () { //... };\n *     foo();\n *\n * on:\n *     function _0x12d45f () { //... };\n *     _0x12d45f();\n */\n@injectable()\nexport class FunctionDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isFunctionDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (functionDeclarationNode: ESTree.FunctionDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(parentNode);\n\n        if (!lexicalScopeNode) {\n            return functionDeclarationNode;\n        }\n\n        const isGlobalDeclaration: boolean = lexicalScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return functionDeclarationNode;\n        }\n\n        this.storeFunctionName(functionDeclarationNode, lexicalScopeNode, isGlobalDeclaration);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(lexicalScopeNode)) {\n            this.replaceScopeCachedIdentifiers(functionDeclarationNode, lexicalScopeNode);\n        } else {\n            this.replaceScopeIdentifiers(lexicalScopeNode);\n        }\n\n        return functionDeclarationNode;\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private storeFunctionName (\n        functionDeclarationNode: ESTree.FunctionDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        if (isGlobalDeclaration) {\n            this.identifierObfuscatingReplacer.storeGlobalName(functionDeclarationNode.id.name, lexicalScopeNode);\n        } else {\n            this.identifierObfuscatingReplacer.storeLocalName(functionDeclarationNode.id.name, lexicalScopeNode);\n        }\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeCachedIdentifiers (\n        functionDeclarationNode: ESTree.FunctionDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames =\n            <TReplaceableIdentifiersNames>this.replaceableIdentifiers.get(lexicalScopeNode);\n\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined = cachedReplaceableIdentifiersNamesMap\n            .get(functionDeclarationNode.id.name);\n\n        if (!cachedReplaceableIdentifiers) {\n            return;\n        }\n\n        const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n        for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n            const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, lexicalScopeNode);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        }\n    }\n\n    /**\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeIdentifiers (lexicalScopeNode: TNodeWithLexicalScope): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(lexicalScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] =\n                            storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(lexicalScopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeType } from '../../enums/node/NodeType';\n\n/**\n * replaces:\n *     function foo (argument1) { return argument1; };\n *\n * on:\n *     function foo (_0x12d45f) { return _0x12d45f; };\n *\n */\n@injectable()\nexport class FunctionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    private static isProhibitedIdentifierOfPropertyNode (\n        node: ESTree.Node,\n        parentNode: ESTree.Node | null\n    ): node is ESTree.Identifier {\n        return NodeGuards.isIdentifierNode(node)\n            && !!parentNode\n            && NodeGuards.isPropertyNode(parentNode)\n            && parentNode.key === node;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private static isProhibitedIdentifierOfShorthandPropertyNode (\n        node: ESTree.Node,\n    ): node is ESTree.Property & {key: ESTree.Identifier} {\n        return NodeGuards.isPropertyNode(node)\n            && node.shorthand\n            && NodeGuards.isIdentifierNode(node.key);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isFunctionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(functionNode);\n\n        if (!lexicalScopeNode) {\n            return functionNode;\n        }\n\n        this.storeFunctionParams(functionNode, lexicalScopeNode);\n        this.replaceFunctionParams(functionNode, lexicalScopeNode);\n\n        return functionNode;\n    }\n\n    /**\n     * @param {Identifier} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    private isGlobalFunctionDeclarationIdentifier (node: ESTree.Identifier, parentNode: ESTree.Node): boolean {\n        if (!NodeGuards.isFunctionDeclarationNode(parentNode) || parentNode.id !== node) {\n            return false;\n        }\n\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScopes(parentNode)[1];\n\n        if (!lexicalScopeNode) {\n            return false;\n        }\n\n        const isGlobalDeclaration: boolean = lexicalScopeNode.type === NodeType.Program;\n\n        return !this.options.renameGlobals && isGlobalDeclaration;\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeFunctionParams (functionNode: ESTree.Function, lexicalScopeNode: TNodeWithLexicalScope): void {\n        const visitor: estraverse.Visitor = {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | void => {\n                // should check with identifier as first argument,\n                // because prohibited identifier can be easily ignored\n                if (FunctionTransformer.isProhibitedIdentifierOfPropertyNode(node, parentNode)) {\n                    return;\n                }\n\n                if (NodeGuards.isAssignmentPatternNode(node) && NodeGuards.isIdentifierNode(node.left)) {\n                    this.identifierObfuscatingReplacer.storeLocalName(node.left.name, lexicalScopeNode);\n\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (NodeGuards.isIdentifierNode(node)) {\n                    this.identifierObfuscatingReplacer.storeLocalName(node.name, lexicalScopeNode);\n                }\n            }\n        };\n\n        functionNode.params.forEach((paramsNode: ESTree.Node) => {\n            estraverse.traverse(paramsNode, visitor);\n        });\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {Set<string>} ignoredIdentifierNamesSet\n     */\n    private replaceFunctionParams (\n        functionNode: ESTree.Function,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        ignoredIdentifierNamesSet: Set <string> = new Set()\n    ): void {\n        const visitor: estraverse.Visitor = {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void | estraverse.VisitorOption => {\n                /**\n                 * should process nested functions in different traverse loop to avoid wrong code generation\n                 */\n                if (NodeGuards.isFunctionNode(node) && node !== functionNode) {\n                    this.replaceFunctionParams(node, lexicalScopeNode, new Set(ignoredIdentifierNamesSet));\n\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                /**\n                 * should ignore all shorthand `key` identifiers of the `PropertyNode`\n                 */\n                if (FunctionTransformer.isProhibitedIdentifierOfShorthandPropertyNode(node)) {\n                    ignoredIdentifierNamesSet.add(node.key.name);\n\n                    return;\n                }\n\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                    && !ignoredIdentifierNamesSet.has(node.name)\n                ) {\n                    // should ignore identifiers of global function declarations\n                    if (this.isGlobalFunctionDeclarationIdentifier(node, parentNode)) {\n                        return;\n                    }\n\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    }\n                }\n            }\n        };\n\n        estraverse.replace(functionNode, visitor);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TImportSpecifier } from '../../types/node/TimportSpecifier';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     import foo from './foo';\n *     import * as bar from './bar';\n *\n * on:\n *     import _0x12d45f from './foo';\n *     import * as _0x12d45f from './bar';\n */\n@injectable()\nexport class ImportDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: Map <ESTree.Node, ESTree.Identifier[]> = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TImportSpecifier} importSpecifierNode\n     * @returns {boolean}\n     */\n    private static isProhibitedImportSpecifierNode (importSpecifierNode: TImportSpecifier): boolean {\n        return NodeGuards.isImportSpecifierNode(importSpecifierNode)\n            && importSpecifierNode.imported.name === importSpecifierNode.local.name;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isImportDeclarationNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ImportDeclaration} importDeclarationNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (importDeclarationNode: ESTree.ImportDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(importDeclarationNode);\n\n        if (!lexicalScopeNode) {\n            return importDeclarationNode;\n        }\n\n        this.storeImportSpecifierNames(importDeclarationNode, lexicalScopeNode);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(lexicalScopeNode)) {\n            this.replaceScopeCachedIdentifiers(lexicalScopeNode);\n        } else {\n            this.replaceScopeIdentifiers(lexicalScopeNode);\n        }\n\n        return importDeclarationNode;\n    }\n\n    /**\n     * @param {ImportDeclaration} importDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeImportSpecifierNames (\n        importDeclarationNode: ESTree.ImportDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        importDeclarationNode.specifiers.forEach((importSpecifierNode: TImportSpecifier) => {\n            if (ImportDeclarationTransformer.isProhibitedImportSpecifierNode(importSpecifierNode)) {\n                return;\n            }\n\n            this.identifierObfuscatingReplacer.storeGlobalName(importSpecifierNode.local.name, lexicalScopeNode);\n        });\n    }\n\n    /**\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeCachedIdentifiers (lexicalScopeNode: TNodeWithLexicalScope): void {\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] =\n            <ESTree.Identifier[]>this.replaceableIdentifiers.get(lexicalScopeNode);\n\n        cachedReplaceableIdentifiers.forEach((replaceableIdentifier: ESTree.Identifier) => {\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, lexicalScopeNode);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        });\n    }\n\n    /**\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeIdentifiers (lexicalScopeNode: TNodeWithLexicalScope): void {\n        const storedReplaceableIdentifiers: ESTree.Identifier[] = [];\n\n        estraverse.replace(lexicalScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        storedReplaceableIdentifiers.push(node);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(lexicalScopeNode, storedReplaceableIdentifiers);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\n\n/**\n * replaces:\n *     label: {\n *          for (var i = 0; i < 1000; i++) {\n *              break label;\n *          }\n *     }\n *\n * on:\n *     _0x12d45f: {\n *          for (var i = 0; i < 1000; i++) {\n *              break _0x12d45f;\n *          }\n *     }\n *\n */\n@injectable()\nexport class LabeledStatementTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isLabeledStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (labeledStatementNode: ESTree.LabeledStatement, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(labeledStatementNode);\n\n        if (!lexicalScopeNode) {\n            return labeledStatementNode;\n        }\n\n        this.storeLabeledStatementName(labeledStatementNode, lexicalScopeNode);\n        this.replaceLabeledStatementName(labeledStatementNode, lexicalScopeNode);\n\n        return labeledStatementNode;\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeLabeledStatementName (\n        labeledStatementNode: ESTree.LabeledStatement,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        this.identifierObfuscatingReplacer.storeLocalName(labeledStatementNode.label.name, lexicalScopeNode);\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceLabeledStatementName (\n        labeledStatementNode: ESTree.LabeledStatement,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        estraverse.replace(labeledStatementNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isLabelIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n\n                    node.name = newIdentifier.name;\n                }\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TLiteralObfuscatingReplacerFactory } from '../../types/container/node-transformers/TLiteralObfuscatingReplacerFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { LiteralObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class LiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TLiteralObfuscatingReplacerFactory}\n     */\n    private readonly literalObfuscatingReplacerFactory: TLiteralObfuscatingReplacerFactory;\n\n    /**\n     * @param {TLiteralObfuscatingReplacerFactory} literalObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscatingReplacer)\n            literalObfuscatingReplacerFactory: TLiteralObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.literalObfuscatingReplacerFactory = literalObfuscatingReplacerFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isLiteralNode(node) && !NodeMetadata.isReplacedLiteral(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): ESTree.Node {\n        if (this.isProhibitedNode(literalNode, parentNode)) {\n            return literalNode;\n        }\n\n        let newLiteralNode: ESTree.Node;\n\n        switch (typeof literalNode.value) {\n            case 'boolean':\n                newLiteralNode = this.literalObfuscatingReplacerFactory(\n                    LiteralObfuscatingReplacer.BooleanLiteralObfuscatingReplacer\n                ).replace(<boolean>literalNode.value);\n\n                break;\n\n            case 'number':\n                newLiteralNode = this.literalObfuscatingReplacerFactory(\n                    LiteralObfuscatingReplacer.NumberLiteralObfuscatingReplacer\n                ).replace(<number>literalNode.value);\n\n                break;\n\n            case 'string':\n                newLiteralNode = this.literalObfuscatingReplacerFactory(\n                    LiteralObfuscatingReplacer.StringLiteralObfuscatingReplacer\n                ).replace(<string>literalNode.value);\n\n                break;\n\n            default:\n                newLiteralNode = literalNode;\n        }\n\n        NodeUtils.parentizeNode(newLiteralNode, parentNode);\n\n        return newLiteralNode;\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    private isProhibitedNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): boolean {\n        if (NodeGuards.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return true;\n        }\n\n        if (NodeGuards.isImportDeclarationNode(parentNode)) {\n            return true;\n        }\n\n        return false;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\nimport { NumberUtils } from '../../../../utils/NumberUtils';\nimport { Utils } from '../../../../utils/Utils';\n\n@injectable()\nexport class NumberLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly numberLiteralCache: Map <number, string> = new Map();\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param {number} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: number): ESTree.Node {\n        let rawValue: string;\n\n        if (this.numberLiteralCache.has(nodeValue)) {\n            rawValue = <string>this.numberLiteralCache.get(nodeValue);\n        } else {\n            if (!NumberUtils.isCeil(nodeValue)) {\n                rawValue = String(nodeValue);\n            } else {\n                rawValue = `${Utils.hexadecimalPrefix}${NumberUtils.toHex(nodeValue)}`;\n            }\n\n            this.numberLiteralCache.set(nodeValue, rawValue);\n        }\n\n        return NodeFactory.literalNode(nodeValue, rawValue);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TStringArrayStorage } from '../../../../types/storages/TStringArrayStorage';\n\nimport { ICryptUtils } from '../../../../interfaces/utils/ICryptUtils';\nimport { IEncodedValue } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/IEncodedValue';\nimport { IEscapeSequenceEncoder } from '../../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../../interfaces/utils/IRandomGenerator';\nimport { IStringArrayIndexData } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/IStringArrayIndexData';\n\nimport { StringArrayEncoding } from '../../../../enums/StringArrayEncoding';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeMetadata } from '../../../../node/NodeMetadata';\nimport { NodeFactory } from '../../../../node/NodeFactory';\nimport { NumberUtils } from '../../../../utils/NumberUtils';\nimport { Utils } from '../../../../utils/Utils';\n\n@injectable()\nexport class StringLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly minimumLengthForStringArray: number = 3;\n\n    /**\n     * @type {number}\n     */\n    private static readonly rc4KeyLength: number = 4;\n\n    /**\n     * @type {number}\n     */\n    private static readonly rc4KeysCount: number = 50;\n\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {Map<string, ESTree.Node>}\n     */\n    private readonly nodesCache: Map <string, ESTree.Node> = new Map();\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {string[]}\n     */\n    private readonly rc4Keys: string[];\n\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringLiteralHexadecimalIndexCache: Map <string, string> = new Map();\n\n    /**\n     * @type {TStringArrayStorage}\n     */\n    private readonly stringArrayStorage: TStringArrayStorage;\n\n    /**\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IRandomGenerator} randomGenerator\n     * @param {ICryptUtils} cryptUtils\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: TStringArrayStorage,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(\n            options\n        );\n\n        this.stringArrayStorage = stringArrayStorage;\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n        this.randomGenerator = randomGenerator;\n        this.cryptUtils = cryptUtils;\n\n        this.rc4Keys = this.randomGenerator.getRandomGenerator()\n            .n(\n                () => this.randomGenerator.getRandomGenerator().string({\n                    length: StringLiteralObfuscatingReplacer.rc4KeyLength\n                }),\n                StringLiteralObfuscatingReplacer.rc4KeysCount\n            );\n    }\n\n    /**\n     * @param {string} hexadecimalIndex\n     * @returns {Literal}\n     */\n    private static getHexadecimalLiteralNode (hexadecimalIndex: string): ESTree.Literal {\n        const hexadecimalLiteralNode: ESTree.Literal = NodeFactory.literalNode(hexadecimalIndex);\n\n        NodeMetadata.set(hexadecimalLiteralNode, { replacedLiteral: true });\n\n        return hexadecimalLiteralNode;\n    }\n\n    /**\n     * @param {string} literalValue\n     * @returns {Literal}\n     */\n    private static getRc4KeyLiteralNode (literalValue: string): ESTree.Literal {\n        const rc4KeyLiteralNode: ESTree.Literal = NodeFactory.literalNode(literalValue);\n\n        NodeMetadata.set(rc4KeyLiteralNode, { replacedLiteral: true });\n\n        return rc4KeyLiteralNode;\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: string): ESTree.Node {\n        if (this.isReservedString(nodeValue)) {\n            return this.replaceWithReservedLiteralNode(nodeValue);\n        }\n\n        const useStringArray: boolean = this.canUseStringArray(nodeValue);\n        const cacheKey: string = `${nodeValue}-${String(useStringArray)}`;\n        const useCacheValue: boolean = this.nodesCache.has(cacheKey) && this.options.stringArrayEncoding !== StringArrayEncoding.Rc4;\n\n        if (useCacheValue) {\n            return <ESTree.Node>this.nodesCache.get(cacheKey);\n        }\n\n        const resultNode: ESTree.Node = useStringArray\n            ? this.replaceWithStringArrayCallNode(nodeValue)\n            : this.replaceWithLiteralNode(nodeValue);\n\n        this.nodesCache.set(cacheKey, resultNode);\n\n        return resultNode;\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @returns {boolean}\n     */\n    private canUseStringArray (nodeValue: string): boolean {\n        return (\n            this.options.stringArray &&\n            nodeValue.length >= StringLiteralObfuscatingReplacer.minimumLengthForStringArray &&\n            this.randomGenerator.getMathRandom() <= this.options.stringArrayThreshold\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} stringArrayStorageLength\n     * @returns {IStringArrayIndexData}\n     */\n    private getStringArrayHexadecimalIndex (value: string, stringArrayStorageLength: number): IStringArrayIndexData {\n        if (this.stringLiteralHexadecimalIndexCache.has(value)) {\n            return {\n                fromCache: true,\n                index: <string>this.stringLiteralHexadecimalIndexCache.get(value)\n            };\n        }\n\n        const hexadecimalRawIndex: string = NumberUtils.toHex(stringArrayStorageLength);\n        const hexadecimalIndex: string = `${Utils.hexadecimalPrefix}${hexadecimalRawIndex}`;\n\n        this.stringLiteralHexadecimalIndexCache.set(value, hexadecimalIndex);\n\n        return {\n            fromCache: false,\n            index: hexadecimalIndex\n        };\n    }\n\n    /**\n     * @param {string} value\n     * @returns {IEncodedValue}\n     */\n    private getEncodedValue (value: string): IEncodedValue {\n        let encodedValue: string;\n        let key: string | null = null;\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.Rc4:\n                key = this.randomGenerator.getRandomGenerator().pickone(this.rc4Keys);\n                encodedValue = this.cryptUtils.btoa(this.cryptUtils.rc4(value, key));\n\n                break;\n\n            case StringArrayEncoding.Base64:\n                encodedValue = this.cryptUtils.btoa(value);\n\n                break;\n\n            default:\n                encodedValue = value;\n        }\n\n        return { encodedValue, key };\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithLiteralNode (value: string): ESTree.Node {\n        return NodeFactory.literalNode(\n            this.escapeSequenceEncoder.encode(value, this.options.unicodeEscapeSequence)\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithReservedLiteralNode (value: string): ESTree.Node {\n        return NodeFactory.literalNode(\n            this.escapeSequenceEncoder.encode(value, false)\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithStringArrayCallNode (value: string): ESTree.Node {\n        const { encodedValue, key }: IEncodedValue = this.getEncodedValue(value);\n        const escapedValue: string = this.escapeSequenceEncoder.encode(encodedValue, this.options.unicodeEscapeSequence);\n\n        const stringArrayStorageLength: number = this.stringArrayStorage.getLength();\n        const stringArrayStorageCallsWrapperName: string = this.stringArrayStorage.getStorageId().split('|')[1];\n\n        const { fromCache, index }: IStringArrayIndexData = this.getStringArrayHexadecimalIndex(\n            escapedValue,\n            stringArrayStorageLength\n        );\n\n        if (!fromCache) {\n            this.stringArrayStorage.set(stringArrayStorageLength, escapedValue);\n        }\n\n        const callExpressionArgs: (ESTree.Expression | ESTree.SpreadElement)[] = [\n            StringLiteralObfuscatingReplacer.getHexadecimalLiteralNode(index)\n        ];\n\n        if (key) {\n            callExpressionArgs.push(StringLiteralObfuscatingReplacer.getRc4KeyLiteralNode(\n                this.escapeSequenceEncoder.encode(key, this.options.unicodeEscapeSequence)\n            ));\n        }\n\n        const stringArrayIdentifierNode: ESTree.Identifier = NodeFactory.identifierNode(stringArrayStorageCallsWrapperName);\n\n        // prevent obfuscation of this identifier\n        NodeMetadata.set(stringArrayIdentifierNode, { renamedIdentifier: true });\n\n        return NodeFactory.callExpressionNode(\n            stringArrayIdentifierNode,\n            callExpressionArgs\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @returns {boolean}\n     */\n    private isReservedString (value: string): boolean {\n        if (!this.options.reservedStrings.length) {\n            return false;\n        }\n\n        return this.options.reservedStrings\n            .some((reservedString: string) => {\n                return new RegExp(reservedString, 'g').exec(value) !== null;\n            });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\nimport { NodeBlockLexicalScopeUtils } from '../../node/NodeBlockLexicalScopeUtils';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * replaces:\n *     var variable = 1;\n *     variable++;\n *\n * on:\n *     var _0x12d45f = 1;\n *     _0x12d45f++;\n *\n */\n@injectable()\nexport class VariableDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {TReplaceableIdentifiers}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isVariableDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (variableDeclarationNode: ESTree.VariableDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = variableDeclarationNode.kind === 'var'\n            ? NodeLexicalScopeUtils.getLexicalScope(variableDeclarationNode)\n            : NodeBlockLexicalScopeUtils.getLexicalScope(variableDeclarationNode);\n\n        if (!lexicalScopeNode) {\n            return variableDeclarationNode;\n        }\n\n        const isGlobalDeclaration: boolean = lexicalScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return variableDeclarationNode;\n        }\n\n        const scopeNode: ESTree.Node = variableDeclarationNode.kind === 'var'\n            ? lexicalScopeNode\n            : parentNode;\n\n        this.storeVariableNames(variableDeclarationNode, lexicalScopeNode, isGlobalDeclaration);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(scopeNode)) {\n            this.replaceScopeCachedIdentifiers(variableDeclarationNode, lexicalScopeNode, scopeNode);\n        } else {\n            this.replaceScopeIdentifiers(scopeNode, lexicalScopeNode);\n        }\n\n        return variableDeclarationNode;\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private storeVariableNames (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        this.traverseDeclarationIdentifiers(variableDeclarationNode, (identifierNode: ESTree.Identifier) => {\n            if (isGlobalDeclaration) {\n                this.identifierObfuscatingReplacer.storeGlobalName(identifierNode.name, lexicalScopeNode);\n            } else {\n                this.identifierObfuscatingReplacer.storeLocalName(identifierNode.name, lexicalScopeNode);\n            }\n        });\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {Node} scopeNode\n     */\n    private replaceScopeCachedIdentifiers (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        scopeNode: ESTree.Node\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames =\n            <TReplaceableIdentifiersNames>this.replaceableIdentifiers.get(scopeNode);\n\n        const identifierNames: string[] = [];\n\n        this.traverseDeclarationIdentifiers(variableDeclarationNode, (identifierNode: ESTree.Identifier) => {\n            identifierNames.push(identifierNode.name);\n        });\n\n        identifierNames.forEach((identifierName: string) => {\n            const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined =\n                cachedReplaceableIdentifiersNamesMap.get(identifierName);\n\n            if (!cachedReplaceableIdentifiers) {\n                return;\n            }\n\n            const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n            for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n                const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n\n                if (identifierName !== replaceableIdentifier.name) {\n                    continue;\n                }\n\n                const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                    .replace(replaceableIdentifier.name, lexicalScopeNode);\n\n                replaceableIdentifier.name = newReplaceableIdentifier.name;\n                NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n            }\n        });\n    }\n\n    /**\n     * @param {Node} scopeNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceScopeIdentifiers (scopeNode: ESTree.Node, lexicalScopeNode: TNodeWithLexicalScope): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(scopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, lexicalScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] =\n                            storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(scopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {(identifier: Identifier) => void} callback\n     */\n    private traverseDeclarationIdentifiers (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        callback: (identifier: ESTree.Identifier) => void\n    ): void {\n        variableDeclarationNode.declarations\n            .forEach((declarationNode: ESTree.VariableDeclarator) => {\n                estraverse.traverse(declarationNode.id, {\n                    enter: (node: ESTree.Node) => {\n                        if (NodeGuards.isPropertyNode(node)) {\n                            return estraverse.VisitorOption.Skip;\n                        }\n\n                        if (NodeGuards.isIdentifierNode(node)) {\n                            callback(node);\n                        }\n                    }\n                });\n            });\n    }\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../types/node/TNodeWithLexicalScope';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeBlockLexicalScopeUtils {\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithLexicalScope}\n     */\n    public static getLexicalScope (node: ESTree.Node): TNodeWithLexicalScope | undefined {\n        return NodeBlockLexicalScopeUtils.getLexicalScopesRecursive(node, 1)[0];\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithLexicalScope[]}\n     */\n    public static getLexicalScopes (node: ESTree.Node): TNodeWithLexicalScope[] {\n        return NodeBlockLexicalScopeUtils.getLexicalScopesRecursive(node);\n    }\n\n    /***\n     * @param {Node} node\n     * @param {number} maxSize\n     * @param {TNodeWithLexicalScope[]} nodesWithLexicalScope\n     * @param {number} depth\n     * @returns {TNodeWithLexicalScope[]}\n     */\n    private static getLexicalScopesRecursive (\n        node: ESTree.Node,\n        maxSize: number = Infinity,\n        nodesWithLexicalScope: TNodeWithLexicalScope[] = [],\n        depth: number = 0\n    ): TNodeWithLexicalScope[] {\n        if (nodesWithLexicalScope.length >= maxSize) {\n            return nodesWithLexicalScope;\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (NodeGuards.isNodeWithBlockLexicalScope(node)) {\n            nodesWithLexicalScope.push(node);\n        }\n\n        if (node !== parentNode) {\n            return NodeBlockLexicalScopeUtils.getLexicalScopesRecursive(parentNode, maxSize, nodesWithLexicalScope, ++depth);\n        }\n\n        return nodesWithLexicalScope;\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../../../interfaces/options/IOptionsNormalizer';\n\nimport { Options } from '../../../options/Options';\nimport { OptionsNormalizer } from '../../../options/OptionsNormalizer';\n\nexport const optionsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    bind<IOptions>(ServiceIdentifiers.IOptions)\n        .to(Options)\n        .inSingletonScope();\n\n    bind<IOptionsNormalizer>(ServiceIdentifiers.IOptionsNormalizer)\n        .to(OptionsNormalizer)\n        .inSingletonScope();\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport {\n    ArrayUnique,\n    IsArray,\n    IsBoolean,\n    IsIn,\n    IsNumber,\n    IsString,\n    IsUrl,\n    Max,\n    Min,\n    ValidateIf,\n    validateSync,\n    ValidationError,\n    ValidatorOptions\n} from 'class-validator';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\nimport { TStringArrayEncoding } from '../types/options/TStringArrayEncoding';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../interfaces/options/IOptionsNormalizer';\n\nimport { IdentifierNamesGenerator } from '../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../enums/source-map/SourceMapMode';\nimport { StringArrayEncoding } from '../enums/StringArrayEncoding';\n\nimport { DEFAULT_PRESET } from './presets/Default';\n\nimport { ValidationErrorsFormatter } from './ValidationErrorsFormatter';\n\n@injectable()\nexport class Options implements IOptions {\n    /**\n     * @type {ValidatorOptions}\n     */\n    private static readonly validatorOptions: ValidatorOptions = {\n        validationError: {\n            target: false\n        }\n    };\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly compact!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly controlFlowFlattening!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly controlFlowFlatteningThreshold!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly deadCodeInjection!: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    public readonly deadCodeInjectionThreshold!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtection!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtectionInterval!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly disableConsoleOutput!: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly domainLock!: string[];\n\n    /**\n     * @type {IdentifierNamesGenerator}\n     */\n    @IsIn([\n        IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n        IdentifierNamesGenerator.MangledIdentifierNamesGenerator\n    ])\n    public readonly identifierNamesGenerator!: IdentifierNamesGenerator;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly identifiersPrefix!: string;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly inputFileName!: string;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly log!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly renameGlobals!: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly reservedNames!: string[];\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly reservedStrings!: string[];\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly rotateStringArray!: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    public readonly seed!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly selfDefending!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly sourceMap!: boolean;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    @ValidateIf((options: IOptions) => Boolean(options.sourceMapBaseUrl))\n    @IsUrl({\n        require_protocol: true,\n        require_tld: false,\n        require_valid_protocol: true\n    })\n    public readonly sourceMapBaseUrl!: string;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly sourceMapFileName!: string;\n\n    /**\n     * @type {SourceMapMode}\n     */\n    @IsIn([SourceMapMode.Inline, SourceMapMode.Separate])\n    public readonly sourceMapMode!: SourceMapMode;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly stringArray!: boolean;\n\n    /**\n     * @type {TStringArrayEncoding}\n     */\n    @IsIn([true, false, StringArrayEncoding.Base64, StringArrayEncoding.Rc4])\n    public readonly stringArrayEncoding!: TStringArrayEncoding;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly stringArrayThreshold!: number;\n\n    /**\n     * @type {ObfuscationTarget}\n     */\n    @IsIn([ObfuscationTarget.Browser, ObfuscationTarget.BrowserNoEval, ObfuscationTarget.Node])\n    public readonly target!: ObfuscationTarget;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly transformObjectKeys!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly unicodeEscapeSequence!: boolean;\n\n    /**\n     * @param {TInputOptions} inputOptions\n     * @param {IOptionsNormalizer} optionsNormalizer\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TInputOptions) inputOptions: TInputOptions,\n        @inject(ServiceIdentifiers.IOptionsNormalizer) optionsNormalizer: IOptionsNormalizer\n    ) {\n        Object.assign(this, DEFAULT_PRESET, inputOptions);\n\n        const errors: ValidationError[] = validateSync(this, Options.validatorOptions);\n\n        if (errors.length) {\n            throw new ReferenceError(`Validation failed. errors:\\n${ValidationErrorsFormatter.format(errors)}`);\n        }\n\n        Object.assign(this, optionsNormalizer.normalize(this));\n    }\n}\n","module.exports = require(\"class-validator\");","import { ValidationError } from 'class-validator';\n\nimport { TObject } from '../types/TObject';\n\nexport class ValidationErrorsFormatter {\n    /**\n     * @param {ValidationError[]} errors\n     * @returns {string}\n     */\n    public static format (errors: ValidationError[]): string {\n        return errors\n            .reduce(\n                (errorMessages: string[], error: ValidationError) => ([\n                    ...errorMessages,\n                    ValidationErrorsFormatter.formatWithNestedConstraints(error)\n                ]),\n                []\n            )\n            .join('\\n');\n    }\n\n    /**\n     * @param {ValidationError} error\n     * @returns {string}\n     */\n    private static formatWithNestedConstraints (error: ValidationError): string {\n        const constraints: TObject<string> = error.constraints;\n\n        const rootError: string = `\\`${error.property}\\` errors:\\n`;\n        const nestedErrors: string = Object\n            .keys(constraints)\n            .map((constraint: string) => `    - ${constraints[constraint]}\\n`)\n            .join();\n\n        return `${rootError}${nestedErrors}`;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport { TOptionsNormalizerRule } from '../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../interfaces/options/IOptionsNormalizer';\n\nimport { ControlFlowFlatteningThresholdRule } from './normalizer-rules/ControlFlowFlatteningThresholdRule';\nimport { DeadCodeInjectionRule } from './normalizer-rules/DeadCodeInjectionRule';\nimport { DeadCodeInjectionThresholdRule } from './normalizer-rules/DeadCodeInjectionThresholdRule';\nimport { DomainLockRule } from './normalizer-rules/DomainLockRule';\nimport { InputFileNameRule } from './normalizer-rules/InputFileNameRule';\nimport { SelfDefendingRule } from './normalizer-rules/SelfDefendingRule';\nimport { SourceMapBaseUrlRule } from './normalizer-rules/SourceMapBaseUrlRule';\nimport { SourceMapFileNameRule } from './normalizer-rules/SourceMapFileNameRule';\nimport { StringArrayRule } from './normalizer-rules/StringArrayRule';\nimport { StringArrayEncodingRule } from './normalizer-rules/StringArrayEncodingRule';\nimport { StringArrayThresholdRule } from './normalizer-rules/StringArrayThresholdRule';\n\n@injectable()\nexport class OptionsNormalizer implements IOptionsNormalizer {\n    /**\n     * @type {TOptionsNormalizerRule[]}\n     */\n    private static readonly normalizerRules: TOptionsNormalizerRule[] = [\n        ControlFlowFlatteningThresholdRule,\n        DeadCodeInjectionRule,\n        DeadCodeInjectionThresholdRule,\n        DomainLockRule,\n        InputFileNameRule,\n        SelfDefendingRule,\n        SourceMapBaseUrlRule,\n        SourceMapFileNameRule,\n        StringArrayRule,\n        StringArrayEncodingRule,\n        StringArrayThresholdRule,\n    ];\n\n    /**\n     * @param {IOptions} options\n     * @returns {IOptions}\n     */\n    public normalize (options: IOptions): IOptions {\n        let normalizedOptions: IOptions = {\n            ...options\n        };\n\n        for (const normalizerRule of OptionsNormalizer.normalizerRules) {\n            normalizedOptions = normalizerRule(normalizedOptions);\n        }\n\n        return normalizedOptions;\n    }\n}\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const ControlFlowFlatteningThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.controlFlowFlatteningThreshold === 0) {\n        options = {\n            ...options,\n            controlFlowFlattening: false,\n            controlFlowFlatteningThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { DEFAULT_PRESET } from '../presets/Default';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DeadCodeInjectionRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.deadCodeInjection) {\n        options = {\n            ...options,\n            deadCodeInjection: true,\n            stringArray: true\n        };\n\n        if (!options.stringArrayThreshold) {\n            options = {\n                ...options,\n                stringArray: true,\n                stringArrayThreshold: <number>DEFAULT_PRESET.stringArrayThreshold\n            };\n        }\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DeadCodeInjectionThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.deadCodeInjectionThreshold === 0) {\n        options = {\n            ...options,\n            deadCodeInjection: false,\n            deadCodeInjectionThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { Utils } from '../../utils/Utils';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DomainLockRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.domainLock.length) {\n        const normalizedDomains: string[] = [];\n\n        for (const domain of options.domainLock) {\n            normalizedDomains.push(Utils.extractDomainFrom(domain));\n        }\n\n        options = {\n            ...options,\n            domainLock: normalizedDomains\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const InputFileNameRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    let { inputFileName } = options;\n\n    if (inputFileName) {\n        inputFileName = inputFileName\n            .replace(/^\\/+/, '')\n            .split('.')\n            .slice(0, -1)\n            .join('.') || inputFileName;\n\n        options = {\n            ...options,\n            inputFileName: `${inputFileName}.js`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SelfDefendingRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.selfDefending) {\n        options = {\n            ...options,\n            compact: true,\n            selfDefending: true\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SourceMapBaseUrlRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    const { sourceMapBaseUrl }: { sourceMapBaseUrl: string } = options;\n\n    if (!options.sourceMapFileName) {\n        options = {\n            ...options,\n            sourceMapBaseUrl: ''\n        };\n\n        return options;\n    }\n\n    if (sourceMapBaseUrl && !sourceMapBaseUrl.endsWith('/')) {\n        options = {\n            ...options,\n            sourceMapBaseUrl: `${sourceMapBaseUrl}/`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SourceMapFileNameRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    let { sourceMapFileName }: { sourceMapFileName: string } = options;\n\n    if (sourceMapFileName) {\n        sourceMapFileName = sourceMapFileName\n            .replace(/^\\/+/, '')\n            .split('.')[0];\n\n        options = {\n            ...options,\n            sourceMapFileName: `${sourceMapFileName}.js.map`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (!options.stringArray) {\n        options = {\n            ...options,\n            rotateStringArray: false,\n            stringArray: false,\n            stringArrayEncoding: false,\n            stringArrayThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayEncodingRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.stringArrayEncoding === true) {\n        options = {\n            ...options,\n            stringArrayEncoding: StringArrayEncoding.Base64\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.stringArrayThreshold === 0) {\n        options = {\n            ...options,\n            rotateStringArray: false,\n            stringArray: false,\n            stringArrayEncoding: false,\n            stringArrayThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\nimport { ObfuscatingGuard } from '../../../enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard';\n\nimport { BlackListObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard';\nimport { CommentsTransformer } from '../../../node-transformers/preparing-transformers/CommentsTransformer';\nimport { ConditionalCommentObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard';\nimport { CustomNodesTransformer } from '../../../node-transformers/preparing-transformers/CustomNodesTransformer';\nimport { EvalCallExpressionTransformer } from '../../../node-transformers/preparing-transformers/EvaCallExpressionTransformer';\nimport { MetadataTransformer } from '../../../node-transformers/preparing-transformers/MetadataTransformer';\nimport { ObfuscatingGuardsTransformer } from '../../../node-transformers/preparing-transformers/ObfuscatingGuardsTransformer';\nimport { ParentificationTransformer } from '../../../node-transformers/preparing-transformers/ParentificationTransformer';\n\nexport const preparingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // preparing transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CommentsTransformer)\n        .whenTargetNamed(NodeTransformer.CommentsTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CustomNodesTransformer)\n        .whenTargetNamed(NodeTransformer.CustomNodesTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(EvalCallExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.EvalCallExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MetadataTransformer)\n        .whenTargetNamed(NodeTransformer.MetadataTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObfuscatingGuardsTransformer)\n        .whenTargetNamed(NodeTransformer.ObfuscatingGuardsTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ParentificationTransformer)\n        .whenTargetNamed(NodeTransformer.ParentificationTransformer);\n\n    // obfuscating guards\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(BlackListObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.BlackListNodeGuard);\n\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(ConditionalCommentObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.ConditionalCommentNodeGuard);\n\n    // obfuscating guards factory\n    bind<IObfuscatingGuard>(ServiceIdentifiers.Factory__INodeGuard)\n        .toFactory<IObfuscatingGuard>(InversifyContainerFacade\n            .getCacheFactory<ObfuscatingGuard, IObfuscatingGuard>(\n                ServiceIdentifiers.INodeGuard\n            ));\n});\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeGuard } from '../../../types/node/TNodeGuard';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class BlackListObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {((node: Node) => boolean)[]}\n     */\n    private static readonly blackListGuards: TNodeGuard[] = [\n        NodeGuards.isUseStrictOperator\n    ];\n\n    /**\n     * @type {number}\n     */\n    private readonly blackListGuardsLength: number;\n\n    constructor () {\n        this.blackListGuardsLength = BlackListObfuscatingGuard.blackListGuards.length;\n    }\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        for (let i: number = 0; i < this.blackListGuardsLength; i++) {\n            if (BlackListObfuscatingGuard.blackListGuards[i](node)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class CommentsTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly preservedWords: string[] = [\n        '@license',\n        '@preserve'\n    ];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isNodeWithComments(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Removes all comments from node except comments that contain\n     * `@license`, `@preserve` or `javascript-obfuscator` words\n     *\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node): ESTree.Node {\n        if (node.leadingComments) {\n            node.leadingComments = this.transformComments(node.leadingComments);\n        }\n\n        if (node.trailingComments) {\n            node.trailingComments = this.transformComments(node.trailingComments);\n        }\n\n        return node;\n    }\n\n    /**\n     * @param {Comment[]} comments\n     * @returns {Comment[]}\n     */\n    private transformComments (comments: ESTree.Comment[]): ESTree.Comment[] {\n        return comments.filter((comment: ESTree.Comment) =>\n            CommentsTransformer.preservedWords\n                .some((preservedWord: string) => comment.value.includes(preservedWord))\n        );\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class ConditionalCommentObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {RegExp}\n     */\n    private static readonly obfuscationEnableCommentRegExp: RegExp = new RegExp('javascript-obfuscator *: *enable');\n\n    /**\n     * @type {RegExp}\n     */\n    private static readonly obfuscationDisableCommentRegExp: RegExp = new RegExp('javascript-obfuscator *: *disable');\n\n    /**\n     * @type {boolean}\n     */\n    private obfuscationAllowedForCurrentNode: boolean = true;\n\n    /**\n     * @type {boolean}\n     */\n    private obfuscationAllowedForNextNode: boolean | null = null;\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        if (this.obfuscationAllowedForNextNode) {\n            this.obfuscationAllowedForCurrentNode = this.obfuscationAllowedForNextNode;\n            this.obfuscationAllowedForNextNode = null;\n        }\n\n        if (!NodeGuards.isNodeWithComments(node)) {\n            return this.obfuscationAllowedForCurrentNode;\n        }\n\n        const leadingComments: ESTree.Comment[] | undefined = node.leadingComments;\n        const trailingComments: ESTree.Comment[] | undefined = node.trailingComments;\n\n        if (leadingComments) {\n            this.obfuscationAllowedForCurrentNode = this.checkComments(leadingComments);\n        }\n\n        if (trailingComments) {\n            this.obfuscationAllowedForNextNode = this.checkComments(trailingComments);\n        }\n\n        return this.obfuscationAllowedForCurrentNode;\n    }\n\n    /**\n     * @param {Comment[]} comments\n     * @returns {boolean}\n     */\n    private checkComments (comments: ESTree.Comment[]): boolean {\n        const commentsLength: number = comments.length;\n\n        let obfuscationAllowed: boolean = this.obfuscationAllowedForCurrentNode;\n\n        for (let i: number = 0; i < commentsLength; i++) {\n            const comment: ESTree.Comment = comments[i];\n\n            if (ConditionalCommentObfuscatingGuard.obfuscationEnableCommentRegExp.test(comment.value)) {\n                obfuscationAllowed = true;\n\n                continue;\n            }\n\n            if (ConditionalCommentObfuscatingGuard.obfuscationDisableCommentRegExp.test(comment.value)) {\n                obfuscationAllowed = false;\n            }\n        }\n\n        return obfuscationAllowed;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TCustomNodeGroupStorage } from '../../types/storages/TCustomNodeGroupStorage';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IObfuscationEventEmitter } from '../../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceAnalyzer } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\nimport { IStackTraceData } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ObfuscationEvent } from '../../enums/event-emitters/ObfuscationEvent';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * Analyzing AST-tree and appending custom nodes\n */\n@injectable()\nexport class CustomNodesTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TCustomNodeGroupStorage}\n     */\n    private readonly customNodeGroupStorage: TCustomNodeGroupStorage;\n\n    /**\n     * @type {IObfuscationEventEmitter}\n     */\n    private readonly obfuscationEventEmitter: IObfuscationEventEmitter;\n\n    /**\n     * @type {IStackTraceAnalyzer}\n     */\n    private readonly stackTraceAnalyzer: IStackTraceAnalyzer;\n\n    /**\n     * @type {IStackTraceData[]}\n     */\n    private stackTraceData: IStackTraceData[] = [];\n\n    /**\n     * @param {IStackTraceAnalyzer} stackTraceAnalyzer\n     * @param {IObfuscationEventEmitter} obfuscationEventEmitter\n     * @param {TCustomNodeGroupStorage} customNodeGroupStorage\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IStackTraceAnalyzer) stackTraceAnalyzer: IStackTraceAnalyzer,\n        @inject(ServiceIdentifiers.IObfuscationEventEmitter) obfuscationEventEmitter: IObfuscationEventEmitter,\n        @inject(ServiceIdentifiers.TCustomNodeGroupStorage) customNodeGroupStorage: TCustomNodeGroupStorage,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.stackTraceAnalyzer = stackTraceAnalyzer;\n        this.obfuscationEventEmitter = obfuscationEventEmitter;\n        this.customNodeGroupStorage = customNodeGroupStorage;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n                            this.appendCustomNodesBeforeObfuscation(node, parentNode);\n\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.appendCustomNodesAfterObfuscation(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    public analyzeNode (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.stackTraceData = this.stackTraceAnalyzer.analyze(node);\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Program, parentNode: ESTree.Node | null): ESTree.Node {\n        return node;\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    private appendCustomNodesBeforeObfuscation (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.customNodeGroupStorage\n            .getStorage()\n            .forEach((customNodeGroup: ICustomNodeGroup) => {\n                customNodeGroup.initialize();\n\n                this.obfuscationEventEmitter.once(\n                    customNodeGroup.getAppendEvent(),\n                    customNodeGroup.appendCustomNodes.bind(customNodeGroup)\n                );\n            });\n\n        this.obfuscationEventEmitter.emit(ObfuscationEvent.BeforeObfuscation, node, this.stackTraceData);\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    private appendCustomNodesAfterObfuscation (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.obfuscationEventEmitter.emit(ObfuscationEvent.AfterObfuscation, node, this.stackTraceData);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\nimport jsStringEscape from 'js-string-escape';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class EvalCallExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Set <FunctionExpression>}\n     */\n    private readonly evalRootAstHostNodeSet: Set <ESTree.FunctionExpression> = new Set();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {Expression | SpreadElement} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromCallExpressionArgument (node: ESTree.Expression | ESTree.SpreadElement): string | null {\n        if (NodeGuards.isLiteralNode(node)) {\n            return EvalCallExpressionTransformer\n                .extractEvalStringFromLiteralNode(node);\n        }\n\n        if (NodeGuards.isTemplateLiteralNode(node)) {\n            return EvalCallExpressionTransformer\n                .extractEvalStringFromTemplateLiteralNode(node);\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {Literal} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromLiteralNode (node: ESTree.Literal): string | null {\n        return typeof node.value === 'string' ? node.value : null;\n    }\n\n    /**\n     * @param {TemplateLiteral} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromTemplateLiteralNode (node: ESTree.TemplateLiteral): string | null {\n        const quasis: ESTree.TemplateElement[] = node.quasis;\n        const allowedQuasisLength: number = 1;\n\n        if (quasis.length !== allowedQuasisLength || node.expressions.length) {\n            return null;\n        }\n\n        return quasis[0].value.cooked;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isCallExpressionNode(node)\n                            && NodeGuards.isIdentifierNode(node.callee)\n                            && node.callee.name === 'eval'\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                if (!this.evalRootAstHostNodeSet.size) {\n                    return null;\n                }\n\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && this.isEvalRootAstHostNode(node)) {\n                            return this.restoreNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {CallExpression} callExpressionNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (callExpressionNode: ESTree.CallExpression, parentNode: ESTree.Node): ESTree.Node {\n        const callExpressionFirstArgument: ESTree.Expression | ESTree.SpreadElement = callExpressionNode.arguments[0];\n\n        if (!callExpressionFirstArgument) {\n            return callExpressionNode;\n        }\n\n        const evalString: string | null = EvalCallExpressionTransformer\n            .extractEvalStringFromCallExpressionArgument(callExpressionFirstArgument);\n\n        if (!evalString) {\n            return callExpressionNode;\n        }\n\n        let ast: ESTree.Statement[];\n\n        // wrapping into try-catch to prevent parsing of incorrect `eval` string\n        try {\n            ast = NodeUtils.convertCodeToStructure(evalString);\n        } catch {\n            return callExpressionNode;\n        }\n\n        /**\n         * we should wrap AST-tree into the parent function expression node (ast root host node).\n         * This function expression node will help to correctly transform AST-tree.\n         */\n        const evalRootAstHostNode: ESTree.FunctionExpression = NodeFactory\n            .functionExpressionNode([], NodeFactory.blockStatementNode(ast));\n\n        /**\n         * we should store that host node and then extract AST-tree on the `finalizing` stage\n         */\n        this.evalRootAstHostNodeSet.add(evalRootAstHostNode);\n\n        return evalRootAstHostNode;\n    }\n\n    /**\n     * @param {FunctionExpression} evalRootAstHostNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public restoreNode (evalRootAstHostNode: ESTree.FunctionExpression, parentNode: ESTree.Node): ESTree.Node {\n        const targetAst: ESTree.Statement[] = evalRootAstHostNode.body.body;\n        const obfuscatedCode: string = NodeUtils.convertStructureToCode(targetAst);\n\n        return NodeFactory.callExpressionNode(\n            NodeFactory.identifierNode('eval'),\n            [\n                NodeFactory.literalNode(jsStringEscape(obfuscatedCode))\n            ]\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private isEvalRootAstHostNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return NodeGuards.isFunctionExpressionNode(node) && this.evalRootAstHostNodeSet.has(node);\n    }\n}\n","module.exports = require(\"js-string-escape\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * Adds metadata properties to each node\n */\n@injectable()\nexport class MetadataTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        NodeMetadata.set(node, { ignoredNode: false });\n\n        if (NodeGuards.isIdentifierNode(node)) {\n            NodeMetadata.set(node, { renamedIdentifier: false });\n        }\n\n        if (NodeGuards.isLiteralNode(node)) {\n            NodeMetadata.set(node, { replacedLiteral: false });\n        }\n\n        return node;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TObfuscatingGuardFactory } from '../../types/container/node-transformers/TObfuscatingGuardFactory';\n\nimport { IObfuscatingGuard } from '../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ObfuscatingGuard } from '../../enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * Adds `ignoredNode` properties to each node\n */\n@injectable()\nexport class ObfuscatingGuardsTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {ObfuscatingGuard[]}\n     */\n    private static readonly obfuscatingGuardsList: ObfuscatingGuard[] = [\n        ObfuscatingGuard.BlackListNodeGuard,\n        ObfuscatingGuard.ConditionalCommentNodeGuard\n    ];\n\n    /**\n     * @type {IObfuscatingGuard[]}\n     */\n    private readonly obfuscatingGuards: IObfuscatingGuard[];\n\n    /**\n     * @param {TObfuscatingGuardFactory} obfuscatingGuardFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__INodeGuard) obfuscatingGuardFactory: TObfuscatingGuardFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.obfuscatingGuards = ObfuscatingGuardsTransformer.obfuscatingGuardsList.map(obfuscatingGuardFactory);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        const obfuscationAllowed: boolean = this.obfuscatingGuards\n            .every((nodeGuard: IObfuscatingGuard) => nodeGuard.check(node));\n\n        NodeMetadata.set(node, {\n            ignoredNode: !obfuscationAllowed\n        });\n\n        return node;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * Adds `parentNode` properties to each node\n */\n@injectable()\nexport class ParentificationTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        return NodeUtils.parentizeNode(node, parentNode);\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TCustomNodeGroupStorage } from '../../../types/storages/TCustomNodeGroupStorage';\nimport { TStringArrayStorage } from '../../../types/storages/TStringArrayStorage';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowStorage } from '../../../storages/control-flow/ControlFlowStorage';\nimport { CustomNodeGroupStorage } from '../../../storages/custom-node-group/CustomNodeGroupStorage';\nimport { StringArrayStorage } from '../../../storages/string-array/StringArrayStorage';\n\nexport const storagesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // storages\n    bind<TCustomNodeGroupStorage>(ServiceIdentifiers.TCustomNodeGroupStorage)\n        .to(CustomNodeGroupStorage)\n        .inSingletonScope();\n\n    bind<TStringArrayStorage>(ServiceIdentifiers.TStringArrayStorage)\n        .to(StringArrayStorage)\n        .inSingletonScope();\n\n    bind<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage)\n        .toConstructor(ControlFlowStorage);\n\n    // controlFlowStorage factory\n    bind<TControlFlowStorage>(ServiceIdentifiers.Factory__TControlFlowStorage)\n        .toFactory<TControlFlowStorage>((context: interfaces.Context) => {\n            return () => {\n                const constructor: interfaces.Newable<TControlFlowStorage> = context.container\n                    .get<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage);\n                const randomGenerator: IRandomGenerator = context.container\n                    .get<IRandomGenerator>(ServiceIdentifiers.IRandomGenerator);\n                const options: IOptions = context.container\n                    .get<IOptions>(ServiceIdentifiers.IOptions);\n\n                const storage: TControlFlowStorage = new constructor(randomGenerator, options);\n\n                storage.initialize();\n\n                return storage;\n            };\n        });\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class ControlFlowStorage extends MapStorage <string, ICustomNode> {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TCustomNodeGroupFactory } from '../../types/container/custom-nodes/TCustomNodeGroupFactory';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { CustomNodeGroup } from '../../enums/custom-nodes/CustomNodeGroup';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class CustomNodeGroupStorage extends MapStorage <string, ICustomNodeGroup> {\n    /**\n     * @type {CustomNodeGroup[]}\n     */\n    private static readonly customNodeGroupsList: CustomNodeGroup[] = [\n        CustomNodeGroup.ConsoleOutputCustomNodeGroup,\n        CustomNodeGroup.DebugProtectionCustomNodeGroup,\n        CustomNodeGroup.DomainLockCustomNodeGroup,\n        CustomNodeGroup.SelfDefendingCustomNodeGroup,\n        CustomNodeGroup.StringArrayCustomNodeGroup\n    ];\n\n    /**\n     * @type {TCustomNodesFactoriesFactory}\n     */\n    private readonly customNodeGroupFactory: TCustomNodeGroupFactory;\n\n    /**\n     * @param {TCustomNodeGroupFactory} customNodeGroupFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNodeGroup) customNodeGroupFactory: TCustomNodeGroupFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.customNodeGroupFactory = customNodeGroupFactory;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        super.initialize();\n\n        CustomNodeGroupStorage.customNodeGroupsList.forEach((customNodeGroupName: CustomNodeGroup) => {\n            const customNodeGroup: ICustomNodeGroup = this.customNodeGroupFactory(\n                customNodeGroupName\n            );\n\n            if (!customNodeGroup) {\n                return;\n            }\n\n            this.storage.set(customNodeGroupName, customNodeGroup);\n        });\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { IIdentifierNamesGenerator } from '../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { ArrayStorage } from '../ArrayStorage';\n\n@injectable()\nexport class StringArrayStorage extends ArrayStorage <string> {\n    /**\n     * @type {number}\n     */\n    private static readonly stringArrayNameLength: number = 7;\n\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    private readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IArrayUtils} arrayUtils\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.arrayUtils = arrayUtils;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        super.initialize();\n\n        const baseStringArrayName: string = this.identifierNamesGenerator\n            .generate(StringArrayStorage.stringArrayNameLength);\n        const baseStringArrayCallsWrapperName: string = this.identifierNamesGenerator\n            .generate(StringArrayStorage.stringArrayNameLength);\n        const stringArrayName: string = `${this.options.identifiersPrefix}${baseStringArrayName}`;\n        const stringArrayCallsWrapperName: string = `${this.options.identifiersPrefix}${baseStringArrayCallsWrapperName}`;\n\n        this.storageId = `${stringArrayName}|${stringArrayCallsWrapperName}`;\n    }\n\n    /**\n     * @param {number} rotationValue\n     */\n    public rotateArray (rotationValue: number): void {\n        this.storage = this.arrayUtils.rotate(this.storage, rotationValue);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.storage.map((value: string) => {\n            return `'${value}'`;\n        }).toString();\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IArrayStorage } from '../interfaces/storages/IArrayStorage';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport abstract class ArrayStorage <V> implements IArrayStorage <V> {\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {V[]}\n     */\n    @initializable()\n    protected storage!: V[];\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId!: string;\n\n    /**\n     * @type {number}\n     */\n    private storageLength: number = 0;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.storage = [];\n        this.storageId = this.randomGenerator.getRandomString(6);\n    }\n\n    /**\n     * @param {number} key\n     * @returns {V}\n     */\n    public get (key: number): V {\n        const value: V | undefined = this.storage[key];\n\n        if (!value) {\n            throw new Error(`No value found in array storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param {V} value\n     * @returns {number}\n     */\n    public getKeyOf (value: V): number | null {\n        const key: number = this.storage.indexOf(value);\n\n        return key >= 0 ? key : null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storageLength;\n    }\n\n    /**\n     * @returns {V[]}\n     */\n    public getStorage (): V[] {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param {this} storage\n     * @param {boolean} mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = [...this.storage, ...storage.getStorage()];\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param {number} key\n     * @param {V} value\n     */\n    public set (key: number, value: V): void {\n        if (key === this.storageLength) {\n            this.storage.push(value);\n        } else {\n            this.storage.splice(key, 0, value);\n        }\n\n        this.storageLength++;\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../../interfaces/utils/IArrayUtils';\nimport { ICryptUtils } from '../../../interfaces/utils/ICryptUtils';\nimport { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ArrayUtils } from '../../../utils/ArrayUtils';\nimport { CryptUtils } from '../../../utils/CryptUtils';\nimport { EscapeSequenceEncoder } from '../../../utils/EscapeSequenceEncoder';\nimport { RandomGenerator } from '../../../utils/RandomGenerator';\n\nexport const utilsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // array utils\n    bind<IArrayUtils>(ServiceIdentifiers.IArrayUtils)\n        .to(ArrayUtils)\n        .inSingletonScope();\n\n    // random generator\n    bind<IRandomGenerator>(ServiceIdentifiers.IRandomGenerator)\n        .to(RandomGenerator)\n        .inSingletonScope();\n\n    // crypt utils\n    bind<ICryptUtils>(ServiceIdentifiers.ICryptUtils)\n        .to(CryptUtils)\n        .inSingletonScope();\n\n    // escape sequence encoder\n    bind<IEscapeSequenceEncoder>(ServiceIdentifiers.IEscapeSequenceEncoder)\n        .to(EscapeSequenceEncoder)\n        .inSingletonScope();\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../interfaces/utils/IArrayUtils';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport class ArrayUtils implements IArrayUtils {\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator\n    ) {\n        this.randomGenerator = randomGenerator;\n    }\n\n    /**\n     * @param {number} length\n     * @returns {number[]}\n     */\n    public createWithRange (length: number): number[] {\n        const range: number[] = [];\n\n        for (let i: number = 0; i < length; i++) {\n            range.push(i);\n        }\n\n        return range;\n    }\n\n    /**\n     * @param {T[]} array\n     * @param {number} times\n     * @returns {T[]}\n     */\n    public rotate <T> (array: T[], times: number): T[] {\n        if (!array.length) {\n            throw new ReferenceError(`Cannot rotate empty array.`);\n        }\n\n        if (times <= 0) {\n            return array;\n        }\n\n        const newArray: T[] = array;\n\n        let temp: T | undefined;\n\n        while (times--) {\n            temp = newArray.pop();\n\n            if (temp) {\n                newArray.unshift(temp);\n            }\n        }\n\n        return newArray;\n    }\n\n    /**\n     * @param {T[]} array\n     * @returns {T[]}\n     */\n    public shuffle <T> (array: T[]): T[] {\n        const shuffledArray: T[] = [...array];\n\n        for (let i: number = shuffledArray.length; i; i--) {\n            const j: number = Math.floor(this.randomGenerator.getMathRandom() * i);\n\n            [shuffledArray[i - 1], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i - 1]];\n        }\n\n        return shuffledArray;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { ICryptUtils } from '../interfaces/utils/ICryptUtils';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { RandomGenerator } from './RandomGenerator';\nimport { Utils } from './Utils';\n\n@injectable()\nexport class CryptUtils implements ICryptUtils {\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator\n    ) {\n        this.randomGenerator = randomGenerator;\n    }\n\n    // tslint:disable\n    /**\n     * @param {string} string\n     * @returns {string}\n     */\n    public btoa (string: string): string {\n        const chars: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n        let output: string = '';\n\n        string = encodeURIComponent(string).replace(/%([0-9A-F]{2})/g, (match, p1) => {\n            return String.fromCharCode(parseInt(`${Utils.hexadecimalPrefix}${p1}`));\n        });\n\n        for (\n            let block: number | undefined, charCode: number, idx: number = 0, map: string = chars;\n            string.charAt(idx | 0) || (map = '=', idx % 1);\n            output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n        ) {\n            charCode = string.charCodeAt(idx += 3/4);\n\n            if (charCode > 0xFF) {\n                throw new Error(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n            }\n\n            block = <number>block << 8 | charCode;\n        }\n\n        return output;\n    }\n    // tslint:enable\n\n    /**\n     * Hides string inside a other random string with larger length\n     *\n     * @param {string} str\n     * @param {number} length\n     * @returns {[string , string]}\n     */\n    public hideString (str: string, length: number): [string, string] {\n        const escapeRegExp: (s: string) => string = (s: string) =>\n            s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n        const randomMerge: (s1: string, s2: string) => string = (s1: string, s2: string): string => {\n            let i1: number = -1;\n            let i2: number = -1;\n            let result: string = '';\n\n            while (i1 < s1.length || i2 < s2.length) {\n                if (this.randomGenerator.getMathRandom() < 0.5 && i2 < s2.length) {\n                    result += s2.charAt(++i2);\n                } else {\n                    result += s1.charAt(++i1);\n                }\n            }\n\n            return result;\n        };\n\n        const randomString: string = this.randomGenerator.getRandomGenerator().string({\n            length: length,\n            pool: RandomGenerator.randomGeneratorPool\n        });\n\n        let randomStringDiff: string = randomString.replace(\n            new RegExp(`[${escapeRegExp(str)}]`, 'g'),\n            ''\n        );\n\n        const randomStringDiffArray: string[] = randomStringDiff.split('');\n\n        this.randomGenerator.getRandomGenerator().shuffle(randomStringDiffArray);\n        randomStringDiff = randomStringDiffArray.join('');\n\n        return [randomMerge(str, randomStringDiff), randomStringDiff];\n    }\n\n    // tslint:disable\n    /**\n     * RC4 symmetric cipher encryption/decryption\n     * https://gist.github.com/farhadi/2185197\n     *\n     * @param {string} string\n     * @param {string} key\n     * @returns {string}\n     */\n    public rc4 (string: string, key: string): string {\n        let s: number[] = [],\n            j: number = 0,\n            x: number,\n            result: string = '';\n\n        for (var i = 0; i < 256; i++) {\n            s[i] = i;\n        }\n\n        for (i = 0; i < 256; i++) {\n            j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n        }\n\n        i = 0;\n        j = 0;\n\n        for (let y = 0; y < string.length; y++) {\n            i = (i + 1) % 256;\n            j = (j + s[i]) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n            result += String.fromCharCode(string.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n        }\n\n        return result;\n    }\n    // tslint:enable\n}\n","module.exports = require(\"md5\");","module.exports = require(\"chance\");","import { injectable } from 'inversify';\n\nimport { IEscapeSequenceEncoder } from '../interfaces/utils/IEscapeSequenceEncoder';\n\n@injectable()\nexport class EscapeSequenceEncoder implements IEscapeSequenceEncoder {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringsCache: Map <string, string> = new Map();\n\n    /**\n     * @param {string} string\n     * @param {boolean} encodeAllSymbols\n     * @returns {string}\n     */\n    public encode (string: string, encodeAllSymbols: boolean): string {\n        const cacheKey: string = `${string}-${String(encodeAllSymbols)}`;\n\n        if (this.stringsCache.has(cacheKey)) {\n            return <string>this.stringsCache.get(cacheKey);\n        }\n\n        const radix: number = 16;\n        const replaceRegExp: RegExp = new RegExp('[\\\\s\\\\S]', 'g');\n        const escapeSequenceRegExp: RegExp = new RegExp('[\\'\\\"\\\\\\\\\\\\s]');\n        const regExp: RegExp = new RegExp('[\\\\x00-\\\\x7F]');\n\n        let prefix: string;\n        let template: string;\n\n        const result: string = string.replace(replaceRegExp, (character: string): string => {\n            if (!encodeAllSymbols && !escapeSequenceRegExp.exec(character)) {\n                return character;\n            }\n\n            if (regExp.exec(character)) {\n                prefix = '\\\\x';\n                template = '00';\n            } else {\n                prefix = '\\\\u';\n                template = '0000';\n            }\n\n            return `${prefix}${(template + character.charCodeAt(0).toString(radix)).slice(-template.length)}`;\n        });\n\n        this.stringsCache.set(cacheKey, result);\n\n        return result;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport * as escodegen from 'escodegen-wallaby';\nimport * as espree from 'espree';\nimport * as ESTree from 'estree';\n\nimport { TObfuscatedCodeFactory } from './types/container/source-code/TObfuscatedCodeFactory';\n\nimport { IGeneratorOutput } from './interfaces/IGeneratorOutput';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { ILogger } from './interfaces/logger/ILogger';\nimport { IObfuscatedCode } from './interfaces/source-code/IObfuscatedCode';\nimport { IOptions } from './interfaces/options/IOptions';\nimport { IRandomGenerator } from './interfaces/utils/IRandomGenerator';\nimport { ITransformersRunner } from './interfaces/node-transformers/ITransformersRunner';\n\nimport { LoggingMessage } from './enums/logger/LoggingMessage';\nimport { NodeTransformer } from './enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from './enums/node-transformers/TransformationStage';\n\nimport { EspreeFacade } from './EspreeFacade';\nimport { NodeGuards } from './node/NodeGuards';\n\n@injectable()\nexport class JavaScriptObfuscator implements IJavaScriptObfuscator {\n    /**\n     * @type {Options}\n     */\n    private static readonly espreeParseOptions: espree.ParseOptions = {\n        attachComment: true,\n        comment: true,\n        ecmaFeatures: {\n            experimentalObjectRestSpread: true\n        },\n        ecmaVersion: 9,\n        loc: true,\n        range: true\n    };\n\n    /**\n     * @type {GenerateOptions}\n     */\n    private static readonly escodegenParams: escodegen.GenerateOptions = {\n        comment: true,\n        verbatim: 'x-verbatim-property',\n        sourceMapWithCode: true\n    };\n\n    /**\n     * @type {NodeTransformer[]}\n     */\n    private static readonly transformersList: NodeTransformer[] = [\n        NodeTransformer.BlockStatementControlFlowTransformer,\n        NodeTransformer.ClassDeclarationTransformer,\n        NodeTransformer.CommentsTransformer,\n        NodeTransformer.CustomNodesTransformer,\n        NodeTransformer.DeadCodeInjectionTransformer,\n        NodeTransformer.EvalCallExpressionTransformer,\n        NodeTransformer.FunctionControlFlowTransformer,\n        NodeTransformer.CatchClauseTransformer,\n        NodeTransformer.FunctionDeclarationTransformer,\n        NodeTransformer.FunctionTransformer,\n        NodeTransformer.ImportDeclarationTransformer,\n        NodeTransformer.LabeledStatementTransformer,\n        NodeTransformer.LiteralTransformer,\n        NodeTransformer.MemberExpressionTransformer,\n        NodeTransformer.MetadataTransformer,\n        NodeTransformer.MethodDefinitionTransformer,\n        NodeTransformer.ObfuscatingGuardsTransformer,\n        NodeTransformer.ObjectExpressionKeysTransformer,\n        NodeTransformer.ObjectExpressionTransformer,\n        NodeTransformer.ParentificationTransformer,\n        NodeTransformer.TemplateLiteralTransformer,\n        NodeTransformer.VariableDeclarationTransformer\n    ];\n\n    /**\n     * @type {ILogger}\n     */\n    private readonly logger: ILogger;\n\n    /**\n     * @type {TObfuscatedCodeFactory}\n     */\n    private readonly obfuscatedCodeFactory: TObfuscatedCodeFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {ITransformersRunner}\n     */\n    private readonly transformersRunner: ITransformersRunner;\n\n    /**\n     * @param {ITransformersRunner} transformersRunner\n     * @param {IRandomGenerator} randomGenerator\n     * @param {TObfuscatedCodeFactory} obfuscatedCodeFactory\n     * @param {ILogger} logger\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ITransformersRunner) transformersRunner: ITransformersRunner,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.Factory__IObfuscatedCode) obfuscatedCodeFactory: TObfuscatedCodeFactory,\n        @inject(ServiceIdentifiers.ILogger) logger: ILogger,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.transformersRunner = transformersRunner;\n        this.randomGenerator = randomGenerator;\n        this.obfuscatedCodeFactory = obfuscatedCodeFactory;\n        this.logger = logger;\n        this.options = options;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @returns {IObfuscatedCode}\n     */\n    public obfuscate (sourceCode: string): IObfuscatedCode {\n        const timeStart: number = Date.now();\n        this.logger.info(LoggingMessage.Version, process.env.VERSION);\n        this.logger.info(LoggingMessage.ObfuscationStarted);\n        this.logger.info(LoggingMessage.RandomGeneratorSeed, this.randomGenerator.getSeed());\n\n        // parse AST tree\n        const astTree: ESTree.Program = this.parseCode(sourceCode);\n\n        // obfuscate AST tree\n        const obfuscatedAstTree: ESTree.Program = this.transformAstTree(astTree);\n\n        // generate code\n        const generatorOutput: IGeneratorOutput = this.generateCode(sourceCode, obfuscatedAstTree);\n\n        const obfuscationTime: number = (Date.now() - timeStart) / 1000;\n        this.logger.success(LoggingMessage.ObfuscationCompleted, obfuscationTime);\n\n        return this.getObfuscatedCode(generatorOutput);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @returns {Program}\n     */\n    private parseCode (sourceCode: string): ESTree.Program {\n        return EspreeFacade.parse(sourceCode, JavaScriptObfuscator.espreeParseOptions);\n    }\n\n    /**\n     * @param {Program} astTree\n     * @returns {Program}\n     */\n    private transformAstTree (astTree: ESTree.Program): ESTree.Program {\n        const isEmptyAstTree: boolean = NodeGuards.isProgramNode(astTree)\n            && !astTree.body.length\n            && !astTree.leadingComments\n            && !astTree.trailingComments;\n\n        if (isEmptyAstTree) {\n            this.logger.warn(LoggingMessage.EmptySourceCode);\n\n            return astTree;\n        }\n\n        astTree = this.runTransformationStage(astTree, TransformationStage.Preparing);\n\n        if (this.options.deadCodeInjection) {\n            astTree = this.runTransformationStage(astTree, TransformationStage.DeadCodeInjection);\n        }\n\n        if (this.options.controlFlowFlattening) {\n            astTree = this.runTransformationStage(astTree, TransformationStage.ControlFlowFlattening);\n        }\n\n        astTree = this.runTransformationStage(astTree, TransformationStage.Converting);\n        astTree = this.runTransformationStage(astTree, TransformationStage.Obfuscating);\n        astTree = this.runTransformationStage(astTree, TransformationStage.Finalizing);\n\n        return astTree;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {Program} astTree\n     * @returns {IGeneratorOutput}\n     */\n    private generateCode (sourceCode: string, astTree: ESTree.Program): IGeneratorOutput {\n        const escodegenParams: escodegen.GenerateOptions = {\n            ...JavaScriptObfuscator.escodegenParams\n        };\n\n        if (this.options.sourceMap) {\n            escodegenParams.sourceMap = this.options.inputFileName || 'sourceMap';\n            escodegenParams.sourceContent = sourceCode;\n        }\n\n        const generatorOutput: IGeneratorOutput = escodegen.generate(astTree, {\n            ...escodegenParams,\n            format: {\n                compact: this.options.compact\n            }\n        });\n\n        generatorOutput.map = generatorOutput.map ? generatorOutput.map.toString() : '';\n\n        return generatorOutput;\n    }\n\n    /**\n     * @param {IGeneratorOutput} generatorOutput\n     * @returns {IObfuscatedCode}\n     */\n    private getObfuscatedCode (generatorOutput: IGeneratorOutput): IObfuscatedCode {\n        return this.obfuscatedCodeFactory(generatorOutput.code, generatorOutput.map);\n    }\n\n    /**\n     * @param {Program} astTree\n     * @param {TransformationStage} transformationStage\n     * @returns {Program}\n     */\n    private runTransformationStage (astTree: ESTree.Program, transformationStage: TransformationStage): ESTree.Program {\n        this.logger.info(LoggingMessage.TransformationStage, transformationStage);\n\n        return this.transformersRunner.transform(\n            astTree,\n            JavaScriptObfuscator.transformersList,\n            transformationStage\n        );\n    }\n}\n","export enum LoggingMessage {\n    EmptySourceCode = 'Empty source code. Obfuscation canceled...',\n    ObfuscationCompleted = 'Obfuscation completed. Total time: %s sec.',\n    ObfuscationStarted = 'Obfuscation started...',\n    RandomGeneratorSeed = 'Random generator seed: %s...',\n    TransformationStage = 'Transformation stage: %s...',\n    Version = 'Version: %s'\n}\n","import * as espree from 'espree';\nimport * as ESTree from 'estree';\n\nimport chalk, { Chalk } from 'chalk';\n\n/**\n * Facade over `espree`\n */\nexport class EspreeFacade {\n    /**\n     * @type {Chalk}\n     */\n    private static readonly colorError: Chalk = chalk.red;\n\n    /**\n     * @type {number}\n     */\n    private static readonly nearestSymbolsCount: number = 15;\n\n    /**\n     * @type {SourceType[]}\n     */\n    private static readonly sourceTypes: espree.SourceType[] = [\n        'script',\n        'module'\n    ];\n\n    /**\n     * @param {string} input\n     * @param {Options} config\n     * @returns {Program}\n     */\n    public static parse (input: string, config: espree.ParseOptions): ESTree.Program | never {\n        const sourceTypeLength: number = EspreeFacade.sourceTypes.length;\n\n        for (let i: number = 0; i < sourceTypeLength; i++) {\n            try {\n                return EspreeFacade.parseType(input, config, EspreeFacade.sourceTypes[i]);\n            } catch (error) {\n                if (i < sourceTypeLength - 1) {\n                    continue;\n                }\n\n                throw new Error(EspreeFacade.processParsingError(\n                    input,\n                    error.message,\n                    {\n                        line: error.lineNumber,\n                        column: error.column,\n                    }\n                ));\n            }\n        }\n\n        throw new Error(`Espree parsing error`);\n    }\n\n    /**\n     * @param {string} input\n     * @param {ParseOptions} inputConfig\n     * @param {SourceType} sourceType\n     * @returns {Program}\n     */\n    private static parseType (\n        input: string,\n        inputConfig: espree.ParseOptions,\n        sourceType: espree.SourceType\n    ): ESTree.Program {\n        const config: espree.ParseOptions = { ...inputConfig, sourceType };\n\n        return espree.parse(input, config);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} errorMessage\n     * @param {Position} position\n     * @returns {never}\n     */\n    private static processParsingError (sourceCode: string, errorMessage: string, position: ESTree.Position | null): never {\n        if (!position || !position.line || !position.column) {\n            throw new Error(errorMessage);\n        }\n\n        const sourceCodeLines: string[] = sourceCode.split(/\\r?\\n/);\n        const errorLine: string | undefined = sourceCodeLines[position.line - 1];\n\n        if (!errorLine) {\n            throw new Error(errorMessage);\n        }\n\n        const startErrorIndex: number = Math.max(0, position.column - EspreeFacade.nearestSymbolsCount);\n        const endErrorIndex: number = Math.min(errorLine.length, position.column + EspreeFacade.nearestSymbolsCount);\n\n        const formattedPointer: string = EspreeFacade.colorError('>');\n        const formattedCodeSlice: string = `...${\n            errorLine.substring(startErrorIndex, endErrorIndex).replace(/^\\s+/, '')\n        }...`;\n\n        throw new Error(`Line ${position.line}: ${errorMessage}\\n${formattedPointer} ${formattedCodeSlice}`);\n    }\n}\n","import { decorate, injectable } from 'inversify';\n\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\n\nimport { EventEmitter } from 'events';\n\ndecorate(injectable(), EventEmitter);\n\n@injectable()\nexport class ObfuscationEventEmitter extends EventEmitter implements IObfuscationEventEmitter {}\n","module.exports = require(\"events\");","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { ICryptUtils } from '../interfaces/utils/ICryptUtils';\nimport { IObfuscatedCode } from '../interfaces/source-code/IObfuscatedCode';\n\nimport { initializable } from '../decorators/Initializable';\nimport { SourceMapMode } from '../enums/source-map/SourceMapMode';\nimport { IOptions } from '../interfaces/options/IOptions';\n\n@injectable()\nexport class ObfuscatedCode implements IObfuscatedCode {\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private obfuscatedCode!: string;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private sourceMap!: string;\n\n    constructor (\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.cryptUtils = cryptUtils;\n        this.options = options;\n    }\n\n    /**\n     * @param {string} obfuscatedCode\n     * @param {string} sourceMap\n     */\n    public initialize (obfuscatedCode: string, sourceMap: string): void {\n        this.obfuscatedCode = obfuscatedCode;\n        this.sourceMap = sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getObfuscatedCode (): string {\n        return this.correctObfuscatedCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceMap (): string {\n        return this.sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.obfuscatedCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    private correctObfuscatedCode (): string {\n        if (!this.sourceMap) {\n            return this.obfuscatedCode;\n        }\n\n        const sourceMapUrl: string = this.options.sourceMapBaseUrl + this.options.sourceMapFileName;\n\n        let sourceMappingUrl: string = '//# sourceMappingURL=';\n\n        switch (this.options.sourceMapMode) {\n            case SourceMapMode.Inline:\n                sourceMappingUrl += `data:application/json;base64,${this.cryptUtils.btoa(this.sourceMap)}`;\n\n                break;\n\n            case SourceMapMode.Separate:\n            default:\n                if (!sourceMapUrl) {\n                    return this.obfuscatedCode;\n                }\n\n                sourceMappingUrl += sourceMapUrl;\n        }\n\n        return `${this.obfuscatedCode}\\n${sourceMappingUrl}`;\n    }\n}\n","import { ISourceCode } from '../interfaces/source-code/ISourceCode';\n\nexport class SourceCode implements ISourceCode {\n    /**\n     * @type {string}\n     */\n    private readonly sourceCode: string;\n\n    /**\n     * @type {string}\n     */\n    private readonly sourceMap: string;\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} sourceMap\n     */\n    constructor (sourceCode: string, sourceMap: string) {\n        this.sourceCode = sourceCode;\n        this.sourceMap = sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceCode (): string {\n        return this.sourceCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceMap (): string {\n        return this.sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.sourceCode;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeTransformerFactory } from '../types/container/node-transformers/TNodeTransformerFactory';\nimport { TVisitorDirection } from '../types/node-transformers/TVisitorDirection';\nimport { TVisitorFunction } from '../types/node-transformers/TVisitorFunction';\nimport { TVisitorResult } from '../types/node-transformers/TVisitorResult';\n\nimport { ITransformersRunner } from '../interfaces/node-transformers/ITransformersRunner';\nimport { IVisitor } from '../interfaces/node-transformers/IVisitor';\n\nimport { NodeTransformer } from '../enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from '../enums/node-transformers/TransformationStage';\nimport { VisitorDirection } from '../enums/node-transformers/VisitorDirection';\n\nimport { NodeGuards } from '../node/NodeGuards';\nimport { NodeMetadata } from '../node/NodeMetadata';\n\n@injectable()\nexport class TransformersRunner implements ITransformersRunner {\n    /**\n     * @type {TNodeTransformerFactory}\n     */\n    private readonly nodeTransformerFactory: TNodeTransformerFactory;\n\n    /**\n     * @param {TNodeTransformerFactory} nodeTransformerFactory\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__INodeTransformer) nodeTransformerFactory: TNodeTransformerFactory,\n    ) {\n        this.nodeTransformerFactory = nodeTransformerFactory;\n    }\n\n    /**\n     * @param {T} astTree\n     * @param {NodeTransformer[]} nodeTransformers\n     * @param {TransformationStage} transformationStage\n     * @returns {T}\n     */\n    public transform <T extends ESTree.Node = ESTree.Program> (\n        astTree: T,\n        nodeTransformers: NodeTransformer[],\n        transformationStage: TransformationStage\n    ): T {\n        if (!nodeTransformers.length) {\n            return astTree;\n        }\n\n        const enterVisitors: IVisitor[] = [];\n        const leaveVisitors: IVisitor[] = [];\n        const nodeTransformersLength: number = nodeTransformers.length;\n\n        let visitor: IVisitor | null;\n\n        for (let i: number = 0; i < nodeTransformersLength; i++) {\n            visitor = this.nodeTransformerFactory(nodeTransformers[i]).getVisitor(transformationStage);\n\n            if (!visitor) {\n                continue;\n            }\n\n            if (visitor.enter) {\n                enterVisitors.push({ enter: visitor.enter });\n            }\n\n            if (visitor.leave) {\n                leaveVisitors.push({ leave: visitor.leave });\n            }\n        }\n\n        if (!enterVisitors.length && !leaveVisitors.length) {\n            return astTree;\n        }\n\n        estraverse.replace(astTree, {\n            enter: this.mergeVisitorsForDirection(enterVisitors, VisitorDirection.Enter),\n            leave: this.mergeVisitorsForDirection(leaveVisitors, VisitorDirection.Leave)\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param {IVisitor[]} visitors\n     * @param {TVisitorDirection} direction\n     * @returns {TVisitorFunction}\n     */\n    private mergeVisitorsForDirection (visitors: IVisitor[], direction: TVisitorDirection): TVisitorFunction {\n        const visitorsLength: number = visitors.length;\n\n        if (!visitorsLength) {\n            return (node: ESTree.Node, parentNode: ESTree.Node | null) => node;\n        }\n\n        return (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n            if (NodeMetadata.isIgnoredNode(node)) {\n                return estraverse.VisitorOption.Skip;\n            }\n\n            for (let i: number = 0; i < visitorsLength; i++) {\n                const visitorFunction: TVisitorFunction | undefined = visitors[i][direction];\n\n                if (!visitorFunction) {\n                    continue;\n                }\n\n                const visitorResult: TVisitorResult = visitorFunction(node, parentNode);\n\n                if (!visitorResult || !NodeGuards.isNode(visitorResult)) {\n                    continue;\n                }\n\n                node = visitorResult;\n            }\n\n            return node;\n        };\n    }\n}\n","export enum VisitorDirection {\n    Enter = 'enter',\n    Leave = 'leave'\n}\n","import * as commander from 'commander';\nimport * as path from 'path';\n\nimport { TInputCLIOptions } from '../types/options/TInputCLIOptions';\nimport { TInputOptions } from '../types/options/TInputOptions';\nimport { TSourceCodeData } from '../types/cli/TSourceCodeData';\n\nimport { IFileData } from '../interfaces/cli/IFileData';\nimport { IInitializable } from '../interfaces/IInitializable';\nimport { IObfuscatedCode } from '../interfaces/source-code/IObfuscatedCode';\n\nimport { initializable } from '../decorators/Initializable';\n\nimport { DEFAULT_PRESET } from '../options/presets/Default';\n\nimport { ArraySanitizer } from './sanitizers/ArraySanitizer';\nimport { BooleanSanitizer } from './sanitizers/BooleanSanitizer';\nimport { IdentifierNamesGeneratorSanitizer } from './sanitizers/IdentifierNamesGeneratorSanitizer';\nimport { ObfuscationTargetSanitizer } from './sanitizers/ObfuscatingTargetSanitizer';\nimport { SourceMapModeSanitizer } from './sanitizers/SourceMapModeSanitizer';\nimport { StringArrayEncodingSanitizer } from './sanitizers/StringArrayEncodingSanitizer';\n\nimport { CLIUtils } from './utils/CLIUtils';\nimport { JavaScriptObfuscator } from '../JavaScriptObfuscatorFacade';\nimport { SourceCodeReader } from './utils/SourceCodeReader';\n\nexport class JavaScriptObfuscatorCLI implements IInitializable {\n    /**\n     * @type {BufferEncoding}\n     */\n    public static readonly encoding: BufferEncoding = 'utf8';\n\n    /**\n     * @type {string}\n     */\n    public static obfuscatedFilePrefix: string = '-obfuscated';\n\n    /**\n     * @type {string}\n     */\n    private static readonly baseIdentifiersPrefix: string = 'a';\n\n    /**\n     * @type {string[]}\n     */\n    private readonly arguments: string[];\n\n    /**\n     * @type {string[]}\n     */\n    private readonly rawArguments: string[];\n\n    /**\n     * @type {commander.CommanderStatic}\n     */\n    @initializable()\n    private commands!: commander.CommanderStatic;\n\n    /**\n     * @type {TInputCLIOptions}\n     */\n    @initializable()\n    private inputCLIOptions!: TInputCLIOptions;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private inputPath!: string;\n\n    /**\n     * @param {string[]} argv\n     */\n    constructor (argv: string[]) {\n        this.rawArguments = argv;\n        this.arguments = argv.slice(2);\n    }\n\n    /**\n     * @param {TObject} options\n     * @returns {TInputOptions}\n     */\n    private static filterOptions (options: TInputCLIOptions): TInputOptions {\n        const filteredOptions: TInputOptions = {};\n\n        Object\n            .keys(options)\n            .forEach((option: keyof TInputCLIOptions) => {\n                if (options[option] === undefined) {\n                    return;\n                }\n\n                filteredOptions[option] = options[option];\n            });\n\n        return filteredOptions;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} outputCodePath\n     * @param {TInputOptions} options\n     */\n    private static processSourceCodeWithoutSourceMap (\n        sourceCode: string,\n        outputCodePath: string,\n        options: TInputOptions\n    ): void {\n        const obfuscatedCode: string = JavaScriptObfuscator.obfuscate(sourceCode, options).getObfuscatedCode();\n\n        CLIUtils.writeFile(outputCodePath, obfuscatedCode);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} outputCodePath\n     * @param {TInputOptions} options\n     */\n    private static processSourceCodeWithSourceMap (\n        sourceCode: string,\n        outputCodePath: string,\n        options: TInputOptions\n    ): void {\n        const outputSourceMapPath: string = CLIUtils.getOutputSourceMapPath(\n            outputCodePath,\n            options.sourceMapFileName || ''\n        );\n\n        options = {\n            ...options,\n            sourceMapFileName: path.basename(outputSourceMapPath)\n        };\n\n        const obfuscatedCode: IObfuscatedCode = JavaScriptObfuscator.obfuscate(sourceCode, options);\n\n        CLIUtils.writeFile(outputCodePath, obfuscatedCode.getObfuscatedCode());\n\n        if (options.sourceMapMode === 'separate' && obfuscatedCode.getSourceMap()) {\n            CLIUtils.writeFile(outputSourceMapPath, obfuscatedCode.getSourceMap());\n        }\n    }\n\n    public initialize (): void {\n        this.inputPath = path.normalize(this.arguments[0] || '');\n        this.commands = <commander.CommanderStatic>(new commander.Command());\n\n        this.configureCommands();\n        this.configureHelp();\n\n        this.inputCLIOptions = this.commands.opts();\n    }\n\n    public run (): void {\n        const canShowHelp: boolean = !this.arguments.length || this.arguments.includes('--help');\n\n        if (canShowHelp) {\n            this.commands.outputHelp();\n\n            return;\n        }\n\n        const sourceCodeData: TSourceCodeData = new SourceCodeReader(this.inputCLIOptions)\n            .readSourceCode(this.inputPath);\n\n        this.processSourceCodeData(sourceCodeData);\n    }\n\n    /**\n     * @returns {TInputOptions}\n     */\n    private buildOptions (): TInputOptions {\n        const inputCLIOptions: TInputOptions = JavaScriptObfuscatorCLI.filterOptions(this.inputCLIOptions);\n        const configFilePath: string | undefined = this.inputCLIOptions.config;\n        const configFileLocation: string = configFilePath ? path.resolve(configFilePath, '.') : '';\n        const configFileOptions: TInputOptions = configFileLocation ? CLIUtils.getUserConfig(configFileLocation) : {};\n        const inputFileName: string = path.basename(this.inputPath);\n\n        return {\n            ...DEFAULT_PRESET,\n            ...configFileOptions,\n            ...inputCLIOptions,\n            inputFileName\n        };\n    }\n\n    private configureCommands (): void {\n        this.commands\n            .usage('<inputPath> [options]')\n            .version(\n                process.env.VERSION || 'unknown',\n                '-v, --version'\n            )\n            .option(\n                '-o, --output <path>',\n                'Output path for obfuscated code'\n            )\n            .option(\n                '--compact <boolean>',\n                'Disable one line output code compacting',\n                BooleanSanitizer\n            )\n            .option(\n                '--config <boolean>',\n                'Name of js / json config file'\n            )\n            .option(\n                '--control-flow-flattening <boolean>',\n                'Enables control flow flattening',\n                BooleanSanitizer\n            )\n            .option(\n                '--control-flow-flattening-threshold <number>',\n                'The probability that the control flow flattening transformation will be applied to the node',\n                parseFloat\n            )\n            .option(\n                '--dead-code-injection <boolean>',\n                'Enables dead code injection',\n                BooleanSanitizer\n            )\n            .option(\n                '--dead-code-injection-threshold <number>',\n                'The probability that the dead code injection transformation will be applied to the node',\n                parseFloat\n            )\n            .option(\n                '--debug-protection <boolean>',\n                'Disable browser Debug panel (can cause DevTools enabled browser freeze)',\n                BooleanSanitizer\n            )\n            .option(\n                '--debug-protection-interval <boolean>',\n                'Disable browser Debug panel even after page was loaded (can cause DevTools enabled browser freeze)',\n                BooleanSanitizer\n            )\n            .option(\n                '--disable-console-output <boolean>',\n                'Allow console.log, console.info, console.error and console.warn messages output into browser console',\n                BooleanSanitizer\n            )\n            .option(\n                '--domain-lock <list> (comma separated, without whitespaces)',\n                'Blocks the execution of the code in domains that do not match the passed RegExp patterns (comma separated)',\n                ArraySanitizer\n            )\n            .option(\n                '--exclude <list> (comma separated, without whitespaces)',\n                'A filename or glob which indicates files to exclude from obfuscation',\n                ArraySanitizer\n            )\n            .option(\n                '--identifier-names-generator <string>',\n                'Sets identifier names generator. ' +\n                'Values: hexadecimal, mangled. ' +\n                'Default: hexadecimal',\n                IdentifierNamesGeneratorSanitizer\n            )\n            .option(\n                '--identifiers-prefix <string>',\n                'Sets prefix for all global identifiers.'\n            )\n            .option(\n                '--log <boolean>', 'Enables logging of the information to the console',\n                BooleanSanitizer\n            )\n            .option(\n                '--reserved-names <list> (comma separated, without whitespaces)',\n                'Disables obfuscation and generation of identifiers, which being matched by passed RegExp patterns (comma separated)',\n                ArraySanitizer\n            )\n            .option(\n                '--reserved-strings <list> (comma separated, without whitespaces)',\n                'Disables transformation of string literals, which being matched by passed RegExp patterns (comma separated)',\n                ArraySanitizer\n            )\n            .option(\n                '--rename-globals <boolean>', 'Allows to enable obfuscation of global variable and function names with declaration.',\n                BooleanSanitizer\n            )\n            .option(\n                '--rotate-string-array <boolean>', 'Disable rotation of unicode array values during obfuscation',\n                BooleanSanitizer\n            )\n            .option(\n                '--seed <number>',\n                'Sets seed for random generator. This is useful for creating repeatable results.',\n                parseFloat\n            )\n            .option(\n                '--self-defending <boolean>',\n                'Disables self-defending for obfuscated code',\n                BooleanSanitizer\n            )\n            .option(\n                '--source-map <boolean>',\n                'Enables source map generation',\n                BooleanSanitizer\n            )\n            .option(\n                '--source-map-base-url <string>',\n                'Sets base url to the source map import url when `--source-map-mode=separate`'\n            )\n            .option(\n                '--source-map-file-name <string>',\n                'Sets file name for output source map when `--source-map-mode=separate`'\n            )\n            .option(\n                '--source-map-mode <string>',\n                'Specify source map output mode. ' +\n                'Values: inline, separate. ' +\n                'Default: separate',\n                SourceMapModeSanitizer\n            )\n            .option(\n                '--string-array <boolean>',\n                'Disables gathering of all literal strings into an array and replacing every literal string with an array call',\n                BooleanSanitizer\n            )\n            .option(\n                '--string-array-encoding <string|boolean>',\n                'Encodes all strings in strings array using base64 or rc4 (this option can slow down your code speed. ' +\n                'Values: true, false, base64, rc4. ' +\n                'Default: false',\n                StringArrayEncodingSanitizer\n            )\n            .option(\n                '--string-array-threshold <number>',\n                'The probability that the literal string will be inserted into stringArray (Default: 0.8, Min: 0, Max: 1)',\n                parseFloat\n            )\n            .option(\n                '--target <string>',\n                'Allows to set target environment for obfuscated code. ' +\n                'Values: browser, browser-no-eval, node. ' +\n                'Default: browser',\n                ObfuscationTargetSanitizer\n            )\n            .option(\n                '--transform-object-keys <boolean>',\n                'Enables transformation of object keys',\n                BooleanSanitizer\n            )\n            .option(\n                '--unicode-escape-sequence <boolean>',\n                'Allows to enable/disable string conversion to unicode escape sequence',\n                BooleanSanitizer\n            )\n            .parse(this.rawArguments);\n    }\n\n    private configureHelp (): void {\n        this.commands.on('--help', () => {\n            console.log('  Examples:\\n');\n            console.log('    %> javascript-obfuscator input_file_name.js --compact true --self-defending false');\n            console.log('    %> javascript-obfuscator input_file_name.js --output output_file_name.js --compact true --self-defending false');\n            console.log('    %> javascript-obfuscator input_directory_name --compact true --self-defending false');\n            console.log('');\n        });\n    }\n\n    /**\n     * @param {TSourceCodeData} sourceCodeData\n     */\n    private processSourceCodeData (sourceCodeData: TSourceCodeData): void {\n        const outputPath: string = this.inputCLIOptions.output\n            ? path.normalize(this.inputCLIOptions.output)\n            : '';\n\n        if (!Array.isArray(sourceCodeData)) {\n            const outputCodePath: string = outputPath || CLIUtils.getOutputCodePath(this.inputPath);\n\n            this.processSourceCode(sourceCodeData, outputCodePath, null);\n        } else {\n            sourceCodeData.forEach(({ filePath, content }: IFileData, index: number) => {\n                const outputCodePath: string = outputPath\n                    ? path.join(outputPath, filePath)\n                    : CLIUtils.getOutputCodePath(filePath);\n\n                this.processSourceCode(content, outputCodePath, index);\n            });\n        }\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} outputCodePath\n     * @param {number | null} sourceCodeIndex\n     */\n    private processSourceCode (\n        sourceCode: string,\n        outputCodePath: string,\n        sourceCodeIndex: number | null\n    ): void {\n        let options: TInputOptions = this.buildOptions();\n\n        if (sourceCodeIndex !== null) {\n            const baseIdentifiersPrefix: string = this.inputCLIOptions.identifiersPrefix\n                || JavaScriptObfuscatorCLI.baseIdentifiersPrefix;\n            const identifiersPrefix: string = `${baseIdentifiersPrefix}${sourceCodeIndex}`;\n\n            options = {\n                ...options,\n                identifiersPrefix\n            };\n        }\n\n        if (options.sourceMap) {\n            JavaScriptObfuscatorCLI.processSourceCodeWithSourceMap(sourceCode, outputCodePath, options);\n        } else {\n            JavaScriptObfuscatorCLI.processSourceCodeWithoutSourceMap(sourceCode, outputCodePath, options);\n        }\n    }\n}\n","module.exports = require(\"path\");","module.exports = require(\"fs\");","\"use strict\";\n\nimport { JavaScriptObfuscatorCLI } from './src/JavaScriptObfuscatorCLIFacade';\n\nmodule.exports = JavaScriptObfuscatorCLI;\n","import 'reflect-metadata';\n\nimport { JavaScriptObfuscatorCLI } from './cli/JavaScriptObfuscatorCLI';\n\nclass JavaScriptObfuscatorCLIFacade {\n    /**\n     * @param {string[]} argv\n     */\n    public static obfuscate (argv: string[]): void {\n        const javaScriptObfuscatorCLI: JavaScriptObfuscatorCLI = new JavaScriptObfuscatorCLI(argv);\n\n        javaScriptObfuscatorCLI.initialize();\n        javaScriptObfuscatorCLI.run();\n    }\n}\n\nexport { JavaScriptObfuscatorCLIFacade as JavaScriptObfuscatorCLI };\n","module.exports = require(\"commander\");","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\n/**\n * @param {string} value\n * @returns {string[]}\n */\nexport const ArraySanitizer: TCLISanitizer <string[]> = (value: string): string[] => {\n    if (/,$/.test(value)) {\n        throw new SyntaxError(`Multiple <list> values should be wrapped inside quotes: --option-name 'value1','value2'`);\n    }\n\n    return value.split(',').map((string: string) => string.trim());\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nexport const BooleanSanitizer: TCLISanitizer <boolean> = (value: string): boolean => {\n    return value === 'true' || value === '1';\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\n\n/**\n * @param {string} value\n * @returns {string}\n */\nexport const IdentifierNamesGeneratorSanitizer: TCLISanitizer <string> = (value: string): string => {\n    const isCorrectIdentifierNamesGenerator: boolean = Object\n        .keys(IdentifierNamesGenerator)\n        .some((key: string): boolean => {\n            return IdentifierNamesGenerator[<keyof typeof IdentifierNamesGenerator>key] === value;\n        });\n\n    if (!isCorrectIdentifierNamesGenerator) {\n        throw new ReferenceError('Invalid value of `--identifier-names-generator` option');\n    }\n\n    return value;\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\n/**\n * @param {string} value\n * @returns {string}\n */\nexport const ObfuscationTargetSanitizer: TCLISanitizer <string> = (value: string): string => {\n    const isCorrectTarget: boolean = Object\n        .keys(ObfuscationTarget)\n        .some((key: string): boolean => {\n            return ObfuscationTarget[<keyof typeof ObfuscationTarget>key] === value;\n        });\n\n    if (!isCorrectTarget) {\n        throw new ReferenceError('Invalid value of `--target` option');\n    }\n\n    return value;\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\n/**\n * @param {string} value\n * @returns {string}\n */\nexport const SourceMapModeSanitizer: TCLISanitizer <string> = (value: string): string => {\n    const isCorrectSourceMapMode: boolean = Object\n        .keys(SourceMapMode)\n        .some((key: string): boolean => {\n            return SourceMapMode[<keyof typeof SourceMapMode>key] === value;\n        });\n\n    if (!isCorrectSourceMapMode) {\n        throw new ReferenceError('Invalid value of `--source-map-mode` option');\n    }\n\n    return value;\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\nimport { TStringArrayEncoding } from '../../types/options/TStringArrayEncoding';\n\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\n/**\n * @param {string} value\n * @returns {TStringArrayEncoding}\n */\nexport const StringArrayEncodingSanitizer: TCLISanitizer <TStringArrayEncoding> = (value: string): TStringArrayEncoding => {\n    switch (value) {\n        case 'true':\n        case '1':\n        case StringArrayEncoding.Base64:\n            return true;\n\n        case StringArrayEncoding.Rc4:\n            return StringArrayEncoding.Rc4;\n\n        default:\n            return false;\n    }\n};\n","import * as fs from 'fs';\nimport * as mkdirp from 'mkdirp';\nimport * as path from 'path';\n\nimport { TObject } from '../../types/TObject';\n\nimport { JavaScriptObfuscatorCLI } from '../JavaScriptObfuscatorCLI';\n\nexport class CLIUtils {\n    /**\n     * @param {string} inputPath\n     * @returns {string}\n     */\n    public static getOutputCodePath (inputPath: string): string {\n        return path\n            .normalize(inputPath)\n            .split('.')\n            .map((value: string, index: number) => {\n                return index === 0 ? `${value}${JavaScriptObfuscatorCLI.obfuscatedFilePrefix}` : value;\n            })\n            .join('.');\n    }\n\n    /**\n     * @param {string} outputCodePath\n     * @param {string} sourceMapFileName\n     * @returns {string}\n     */\n    public static getOutputSourceMapPath (outputCodePath: string, sourceMapFileName: string = ''): string {\n        if (sourceMapFileName) {\n            outputCodePath = `${outputCodePath.substring(\n                0, outputCodePath.lastIndexOf('/')\n            )}/${sourceMapFileName}`;\n        }\n\n        if (!/\\.js\\.map$/.test(outputCodePath)) {\n            outputCodePath = `${outputCodePath.split('.')[0]}.js.map`;\n        } else if (/\\.js$/.test(outputCodePath)) {\n            outputCodePath += '.map';\n        }\n\n        return outputCodePath;\n    }\n\n    /**\n     * @param {string} configPath\n     * @returns {TObject}\n     */\n    public static getUserConfig (configPath: string): TObject {\n        let config: Object;\n\n        try {\n            config = require(configPath);\n        } catch {\n            try {\n                config = __non_webpack_require__(configPath);\n            } catch {\n                throw new ReferenceError('Given config path must be a valid `.js` or `.json` file path');\n            }\n        }\n\n        return config;\n    }\n\n    /**\n     * @param {string} outputPath\n     * @param {string} data\n     */\n    public static writeFile (outputPath: string, data: string): void {\n        mkdirp.sync(path.dirname(outputPath));\n\n        fs.writeFileSync(outputPath, data, {\n            encoding: JavaScriptObfuscatorCLI.encoding\n        });\n    }\n}\n","module.exports = require(\"mkdirp\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 213;","import * as fs from 'fs';\nimport * as path from 'path';\nimport multimatch from 'multimatch';\n\nimport { TInputCLIOptions } from '../../types/options/TInputCLIOptions';\nimport { TSourceCodeData } from '../../types/cli/TSourceCodeData';\n\nimport { IFileData } from '../../interfaces/cli/IFileData';\n\nimport { LoggingPrefix } from '../../enums/logger/LoggingPrefix';\n\nimport { JavaScriptObfuscatorCLI } from '../JavaScriptObfuscatorCLI';\nimport { Logger } from '../../logger/Logger';\n\nexport class SourceCodeReader {\n    /**\n     * @type {string[]}\n     */\n    public static readonly availableInputExtensions: string[] = [\n        '.js'\n    ];\n\n    /**\n     * @type {TInputCLIOptions}\n     */\n    private readonly options: TInputCLIOptions;\n\n    /**\n     * @param {TInputCLIOptions} options\n     */\n    constructor (options: TInputCLIOptions) {\n        this.options = options;\n    }\n\n    /**\n     * @param {string} filePath\n     * @param {string[]} excludePatterns\n     * @returns {boolean}\n     */\n    private static isExcludedPath (filePath: string, excludePatterns: string[] = []): boolean {\n        if (!excludePatterns.length) {\n            return false;\n        }\n\n        const fileName: string = path.basename(filePath);\n        const isExcludedFilePathByGlobPattern: boolean = !!multimatch([filePath], excludePatterns).length;\n        const isExcludedFilePathByInclusion: boolean = excludePatterns.some((excludePattern: string) =>\n            filePath.includes(excludePattern) || fileName.includes(excludePattern)\n        );\n\n        return isExcludedFilePathByInclusion || isExcludedFilePathByGlobPattern;\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {boolean}\n     */\n    private static isDirectoryPath (filePath: string): boolean {\n        try {\n            return fs.statSync(filePath).isDirectory();\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {boolean}\n     */\n    private static isFilePath (filePath: string): boolean {\n        try {\n            return fs.statSync(filePath).isFile();\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @param {string} filePath\n     */\n    private static logFilePath (filePath: string): void {\n        const normalizedFilePath: string = path.normalize(filePath);\n\n        Logger.log(\n            Logger.colorInfo,\n            LoggingPrefix.CLI,\n            `Obfuscating file: ${normalizedFilePath}...`\n        );\n    }\n\n    /**\n     * @param {string} inputPath\n     * @returns {TSourceCodeData}\n     */\n    public readSourceCode (inputPath: string): TSourceCodeData {\n        if (SourceCodeReader.isFilePath(inputPath) && this.isValidFile(inputPath)) {\n            return this.readFile(inputPath);\n        }\n\n        if (SourceCodeReader.isDirectoryPath(inputPath) && this.isValidDirectory(inputPath)) {\n            return this.readDirectoryRecursive(inputPath);\n        }\n\n        const availableFilePaths: string = SourceCodeReader\n            .availableInputExtensions\n            .map((extension: string) => `\\`${extension}\\``)\n            .join(', ');\n\n        throw new ReferenceError(`Given input path must be a valid ${availableFilePaths} file or directory path`);\n    }\n\n    /**\n     * @param {string} directoryPath\n     * @param {IFileData[]} fileData\n     * @returns {IFileData[]}\n     */\n    private readDirectoryRecursive (directoryPath: string, fileData: IFileData[] = []): IFileData[] {\n        fs.readdirSync(directoryPath, JavaScriptObfuscatorCLI.encoding)\n            .forEach((fileName: string) => {\n                const filePath: string = `${directoryPath}/${fileName}`;\n\n                if (SourceCodeReader.isDirectoryPath(filePath) && this.isValidDirectory(filePath)) {\n                    fileData.push(...this.readDirectoryRecursive(filePath));\n                } else if (SourceCodeReader.isFilePath(filePath) && this.isValidFile(filePath)) {\n                    const content: string = this.readFile(filePath);\n\n                    fileData.push({ filePath, content });\n                }\n            });\n\n        return fileData;\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {string}\n     */\n    private readFile (filePath: string): string {\n        SourceCodeReader.logFilePath(filePath);\n\n        return fs.readFileSync(filePath, JavaScriptObfuscatorCLI.encoding);\n    }\n\n    /**\n     * @param {string} directoryPath\n     * @returns {boolean}\n     */\n    private isValidDirectory (directoryPath: string): boolean {\n        return !SourceCodeReader.isExcludedPath(directoryPath, this.options.exclude);\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {boolean}\n     */\n    private isValidFile (filePath: string): boolean {\n        return SourceCodeReader.availableInputExtensions.includes(path.extname(filePath))\n            && !filePath.includes(JavaScriptObfuscatorCLI.obfuscatedFilePrefix)\n            && !SourceCodeReader.isExcludedPath(filePath, this.options.exclude);\n    }\n}\n","module.exports = require(\"multimatch\");"],"sourceRoot":""}